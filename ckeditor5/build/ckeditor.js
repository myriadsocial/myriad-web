(function (t) {
  const e = (t['en'] = t['en'] || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    '%0 of %1': '%0 of %1',
    Accept: 'Accept',
    Aquamarine: 'Aquamarine',
    Black: 'Black',
    Blue: 'Blue',
    Cancel: 'Cancel',
    Clear: 'Clear',
    'Click to edit block': 'Click to edit block',
    'Dim grey': 'Dim grey',
    'Drag to move': 'Drag to move',
    'Dropdown toolbar': 'Dropdown toolbar',
    'Edit block': 'Edit block',
    'Editor block content toolbar': 'Editor block content toolbar',
    'Editor contextual toolbar': 'Editor contextual toolbar',
    'Editor editing area: %0': 'Editor editing area: %0',
    'Editor toolbar': 'Editor toolbar',
    Green: 'Green',
    Grey: 'Grey',
    HEX: 'HEX',
    'Insert paragraph after block': 'Insert paragraph after block',
    'Insert paragraph before block': 'Insert paragraph before block',
    'Light blue': 'Light blue',
    'Light green': 'Light green',
    'Light grey': 'Light grey',
    Next: 'Next',
    'No results found': 'No results found',
    'No searchable items': 'No searchable items',
    Orange: 'Orange',
    'Press Enter to type after or press Shift + Enter to type before the widget':
      'Press Enter to type after or press Shift + Enter to type before the widget',
    Previous: 'Previous',
    Purple: 'Purple',
    Red: 'Red',
    Redo: 'Redo',
    'Rich Text Editor': 'Rich Text Editor',
    'Select all': 'Select all',
    'Show more items': 'Show more items',
    Turquoise: 'Turquoise',
    Undo: 'Undo',
    White: 'White',
    'Widget toolbar': 'Widget toolbar',
    Yellow: 'Yellow',
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ (function t(e, n) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = n();
  else if (typeof define === 'function' && define.amd) define([], n);
  else if (typeof exports === 'object') exports['ClassicEditor'] = n();
  else e['ClassicEditor'] = n();
})(self, () =>
  (() => {
    var t = {
      168: (t, e, n) => {
        const o = n(874);
        const i = {};
        for (const t of Object.keys(o)) {
          i[o[t]] = t;
        }
        const r = {
          rgb: { channels: 3, labels: 'rgb' },
          hsl: { channels: 3, labels: 'hsl' },
          hsv: { channels: 3, labels: 'hsv' },
          hwb: { channels: 3, labels: 'hwb' },
          cmyk: { channels: 4, labels: 'cmyk' },
          xyz: { channels: 3, labels: 'xyz' },
          lab: { channels: 3, labels: 'lab' },
          lch: { channels: 3, labels: 'lch' },
          hex: { channels: 1, labels: ['hex'] },
          keyword: { channels: 1, labels: ['keyword'] },
          ansi16: { channels: 1, labels: ['ansi16'] },
          ansi256: { channels: 1, labels: ['ansi256'] },
          hcg: { channels: 3, labels: ['h', 'c', 'g'] },
          apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
          gray: { channels: 1, labels: ['gray'] },
        };
        t.exports = r;
        for (const t of Object.keys(r)) {
          if (!('channels' in r[t])) {
            throw new Error('missing channels property: ' + t);
          }
          if (!('labels' in r[t])) {
            throw new Error('missing channel labels property: ' + t);
          }
          if (r[t].labels.length !== r[t].channels) {
            throw new Error('channel and label counts mismatch: ' + t);
          }
          const { channels: e, labels: n } = r[t];
          delete r[t].channels;
          delete r[t].labels;
          Object.defineProperty(r[t], 'channels', { value: e });
          Object.defineProperty(r[t], 'labels', { value: n });
        }
        r.rgb.hsl = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.min(e, n, o);
          const r = Math.max(e, n, o);
          const s = r - i;
          let a;
          let c;
          if (r === i) {
            a = 0;
          } else if (e === r) {
            a = (n - o) / s;
          } else if (n === r) {
            a = 2 + (o - e) / s;
          } else if (o === r) {
            a = 4 + (e - n) / s;
          }
          a = Math.min(a * 60, 360);
          if (a < 0) {
            a += 360;
          }
          const l = (i + r) / 2;
          if (r === i) {
            c = 0;
          } else if (l <= 0.5) {
            c = s / (r + i);
          } else {
            c = s / (2 - r - i);
          }
          return [a, c * 100, l * 100];
        };
        r.rgb.hsv = function (t) {
          let e;
          let n;
          let o;
          let i;
          let r;
          const s = t[0] / 255;
          const a = t[1] / 255;
          const c = t[2] / 255;
          const l = Math.max(s, a, c);
          const d = l - Math.min(s, a, c);
          const h = function (t) {
            return (l - t) / 6 / d + 1 / 2;
          };
          if (d === 0) {
            i = 0;
            r = 0;
          } else {
            r = d / l;
            e = h(s);
            n = h(a);
            o = h(c);
            if (s === l) {
              i = o - n;
            } else if (a === l) {
              i = 1 / 3 + e - o;
            } else if (c === l) {
              i = 2 / 3 + n - e;
            }
            if (i < 0) {
              i += 1;
            } else if (i > 1) {
              i -= 1;
            }
          }
          return [i * 360, r * 100, l * 100];
        };
        r.rgb.hwb = function (t) {
          const e = t[0];
          const n = t[1];
          let o = t[2];
          const i = r.rgb.hsl(t)[0];
          const s = (1 / 255) * Math.min(e, Math.min(n, o));
          o = 1 - (1 / 255) * Math.max(e, Math.max(n, o));
          return [i, s * 100, o * 100];
        };
        r.rgb.cmyk = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.min(1 - e, 1 - n, 1 - o);
          const r = (1 - e - i) / (1 - i) || 0;
          const s = (1 - n - i) / (1 - i) || 0;
          const a = (1 - o - i) / (1 - i) || 0;
          return [r * 100, s * 100, a * 100, i * 100];
        };
        function s(t, e) {
          return (t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2 + (t[2] - e[2]) ** 2;
        }
        r.rgb.keyword = function (t) {
          const e = i[t];
          if (e) {
            return e;
          }
          let n = Infinity;
          let r;
          for (const e of Object.keys(o)) {
            const i = o[e];
            const a = s(t, i);
            if (a < n) {
              n = a;
              r = e;
            }
          }
          return r;
        };
        r.keyword.rgb = function (t) {
          return o[t];
        };
        r.rgb.xyz = function (t) {
          let e = t[0] / 255;
          let n = t[1] / 255;
          let o = t[2] / 255;
          e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
          n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
          o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92;
          const i = e * 0.4124 + n * 0.3576 + o * 0.1805;
          const r = e * 0.2126 + n * 0.7152 + o * 0.0722;
          const s = e * 0.0193 + n * 0.1192 + o * 0.9505;
          return [i * 100, r * 100, s * 100];
        };
        r.rgb.lab = function (t) {
          const e = r.rgb.xyz(t);
          let n = e[0];
          let o = e[1];
          let i = e[2];
          n /= 95.047;
          o /= 100;
          i /= 108.883;
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
          i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116;
          const s = 116 * o - 16;
          const a = 500 * (n - o);
          const c = 200 * (o - i);
          return [s, a, c];
        };
        r.hsl.rgb = function (t) {
          const e = t[0] / 360;
          const n = t[1] / 100;
          const o = t[2] / 100;
          let i;
          let r;
          let s;
          if (n === 0) {
            s = o * 255;
            return [s, s, s];
          }
          if (o < 0.5) {
            i = o * (1 + n);
          } else {
            i = o + n - o * n;
          }
          const a = 2 * o - i;
          const c = [0, 0, 0];
          for (let t = 0; t < 3; t++) {
            r = e + (1 / 3) * -(t - 1);
            if (r < 0) {
              r++;
            }
            if (r > 1) {
              r--;
            }
            if (6 * r < 1) {
              s = a + (i - a) * 6 * r;
            } else if (2 * r < 1) {
              s = i;
            } else if (3 * r < 2) {
              s = a + (i - a) * (2 / 3 - r) * 6;
            } else {
              s = a;
            }
            c[t] = s * 255;
          }
          return c;
        };
        r.hsl.hsv = function (t) {
          const e = t[0];
          let n = t[1] / 100;
          let o = t[2] / 100;
          let i = n;
          const r = Math.max(o, 0.01);
          o *= 2;
          n *= o <= 1 ? o : 2 - o;
          i *= r <= 1 ? r : 2 - r;
          const s = (o + n) / 2;
          const a = o === 0 ? (2 * i) / (r + i) : (2 * n) / (o + n);
          return [e, a * 100, s * 100];
        };
        r.hsv.rgb = function (t) {
          const e = t[0] / 60;
          const n = t[1] / 100;
          let o = t[2] / 100;
          const i = Math.floor(e) % 6;
          const r = e - Math.floor(e);
          const s = 255 * o * (1 - n);
          const a = 255 * o * (1 - n * r);
          const c = 255 * o * (1 - n * (1 - r));
          o *= 255;
          switch (i) {
            case 0:
              return [o, c, s];
            case 1:
              return [a, o, s];
            case 2:
              return [s, o, c];
            case 3:
              return [s, a, o];
            case 4:
              return [c, s, o];
            case 5:
              return [o, s, a];
          }
        };
        r.hsv.hsl = function (t) {
          const e = t[0];
          const n = t[1] / 100;
          const o = t[2] / 100;
          const i = Math.max(o, 0.01);
          let r;
          let s;
          s = (2 - n) * o;
          const a = (2 - n) * i;
          r = n * i;
          r /= a <= 1 ? a : 2 - a;
          r = r || 0;
          s /= 2;
          return [e, r * 100, s * 100];
        };
        r.hwb.rgb = function (t) {
          const e = t[0] / 360;
          let n = t[1] / 100;
          let o = t[2] / 100;
          const i = n + o;
          let r;
          if (i > 1) {
            n /= i;
            o /= i;
          }
          const s = Math.floor(6 * e);
          const a = 1 - o;
          r = 6 * e - s;
          if ((s & 1) !== 0) {
            r = 1 - r;
          }
          const c = n + r * (a - n);
          let l;
          let d;
          let h;
          switch (s) {
            default:
            case 6:
            case 0:
              l = a;
              d = c;
              h = n;
              break;
            case 1:
              l = c;
              d = a;
              h = n;
              break;
            case 2:
              l = n;
              d = a;
              h = c;
              break;
            case 3:
              l = n;
              d = c;
              h = a;
              break;
            case 4:
              l = c;
              d = n;
              h = a;
              break;
            case 5:
              l = a;
              d = n;
              h = c;
              break;
          }
          return [l * 255, d * 255, h * 255];
        };
        r.cmyk.rgb = function (t) {
          const e = t[0] / 100;
          const n = t[1] / 100;
          const o = t[2] / 100;
          const i = t[3] / 100;
          const r = 1 - Math.min(1, e * (1 - i) + i);
          const s = 1 - Math.min(1, n * (1 - i) + i);
          const a = 1 - Math.min(1, o * (1 - i) + i);
          return [r * 255, s * 255, a * 255];
        };
        r.xyz.rgb = function (t) {
          const e = t[0] / 100;
          const n = t[1] / 100;
          const o = t[2] / 100;
          let i;
          let r;
          let s;
          i = e * 3.2406 + n * -1.5372 + o * -0.4986;
          r = e * -0.9689 + n * 1.8758 + o * 0.0415;
          s = e * 0.0557 + n * -0.204 + o * 1.057;
          i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92;
          r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
          s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92;
          i = Math.min(Math.max(0, i), 1);
          r = Math.min(Math.max(0, r), 1);
          s = Math.min(Math.max(0, s), 1);
          return [i * 255, r * 255, s * 255];
        };
        r.xyz.lab = function (t) {
          let e = t[0];
          let n = t[1];
          let o = t[2];
          e /= 95.047;
          n /= 100;
          o /= 108.883;
          e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116;
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116;
          const i = 116 * n - 16;
          const r = 500 * (e - n);
          const s = 200 * (n - o);
          return [i, r, s];
        };
        r.lab.xyz = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          let i;
          let r;
          let s;
          r = (e + 16) / 116;
          i = n / 500 + r;
          s = r - o / 200;
          const a = r ** 3;
          const c = i ** 3;
          const l = s ** 3;
          r = a > 0.008856 ? a : (r - 16 / 116) / 7.787;
          i = c > 0.008856 ? c : (i - 16 / 116) / 7.787;
          s = l > 0.008856 ? l : (s - 16 / 116) / 7.787;
          i *= 95.047;
          r *= 100;
          s *= 108.883;
          return [i, r, s];
        };
        r.lab.lch = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          let i;
          const r = Math.atan2(o, n);
          i = (r * 360) / 2 / Math.PI;
          if (i < 0) {
            i += 360;
          }
          const s = Math.sqrt(n * n + o * o);
          return [e, s, i];
        };
        r.lch.lab = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          const i = (o / 360) * 2 * Math.PI;
          const r = n * Math.cos(i);
          const s = n * Math.sin(i);
          return [e, r, s];
        };
        r.rgb.ansi16 = function (t, e = null) {
          const [n, o, i] = t;
          let s = e === null ? r.rgb.hsv(t)[2] : e;
          s = Math.round(s / 50);
          if (s === 0) {
            return 30;
          }
          let a =
            30 +
            ((Math.round(i / 255) << 2) |
              (Math.round(o / 255) << 1) |
              Math.round(n / 255));
          if (s === 2) {
            a += 60;
          }
          return a;
        };
        r.hsv.ansi16 = function (t) {
          return r.rgb.ansi16(r.hsv.rgb(t), t[2]);
        };
        r.rgb.ansi256 = function (t) {
          const e = t[0];
          const n = t[1];
          const o = t[2];
          if (e === n && n === o) {
            if (e < 8) {
              return 16;
            }
            if (e > 248) {
              return 231;
            }
            return Math.round(((e - 8) / 247) * 24) + 232;
          }
          const i =
            16 +
            36 * Math.round((e / 255) * 5) +
            6 * Math.round((n / 255) * 5) +
            Math.round((o / 255) * 5);
          return i;
        };
        r.ansi16.rgb = function (t) {
          let e = t % 10;
          if (e === 0 || e === 7) {
            if (t > 50) {
              e += 3.5;
            }
            e = (e / 10.5) * 255;
            return [e, e, e];
          }
          const n = (~~(t > 50) + 1) * 0.5;
          const o = (e & 1) * n * 255;
          const i = ((e >> 1) & 1) * n * 255;
          const r = ((e >> 2) & 1) * n * 255;
          return [o, i, r];
        };
        r.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = (t - 232) * 10 + 8;
            return [e, e, e];
          }
          t -= 16;
          let e;
          const n = (Math.floor(t / 36) / 5) * 255;
          const o = (Math.floor((e = t % 36) / 6) / 5) * 255;
          const i = ((e % 6) / 5) * 255;
          return [n, o, i];
        };
        r.rgb.hex = function (t) {
          const e =
            ((Math.round(t[0]) & 255) << 16) +
            ((Math.round(t[1]) & 255) << 8) +
            (Math.round(t[2]) & 255);
          const n = e.toString(16).toUpperCase();
          return '000000'.substring(n.length) + n;
        };
        r.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e) {
            return [0, 0, 0];
          }
          let n = e[0];
          if (e[0].length === 3) {
            n = n
              .split('')
              .map(t => t + t)
              .join('');
          }
          const o = parseInt(n, 16);
          const i = (o >> 16) & 255;
          const r = (o >> 8) & 255;
          const s = o & 255;
          return [i, r, s];
        };
        r.rgb.hcg = function (t) {
          const e = t[0] / 255;
          const n = t[1] / 255;
          const o = t[2] / 255;
          const i = Math.max(Math.max(e, n), o);
          const r = Math.min(Math.min(e, n), o);
          const s = i - r;
          let a;
          let c;
          if (s < 1) {
            a = r / (1 - s);
          } else {
            a = 0;
          }
          if (s <= 0) {
            c = 0;
          } else if (i === e) {
            c = ((n - o) / s) % 6;
          } else if (i === n) {
            c = 2 + (o - e) / s;
          } else {
            c = 4 + (e - n) / s;
          }
          c /= 6;
          c %= 1;
          return [c * 360, s * 100, a * 100];
        };
        r.hsl.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = n < 0.5 ? 2 * e * n : 2 * e * (1 - n);
          let i = 0;
          if (o < 1) {
            i = (n - 0.5 * o) / (1 - o);
          }
          return [t[0], o * 100, i * 100];
        };
        r.hsv.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e * n;
          let i = 0;
          if (o < 1) {
            i = (n - o) / (1 - o);
          }
          return [t[0], o * 100, i * 100];
        };
        r.hcg.rgb = function (t) {
          const e = t[0] / 360;
          const n = t[1] / 100;
          const o = t[2] / 100;
          if (n === 0) {
            return [o * 255, o * 255, o * 255];
          }
          const i = [0, 0, 0];
          const r = (e % 1) * 6;
          const s = r % 1;
          const a = 1 - s;
          let c = 0;
          switch (Math.floor(r)) {
            case 0:
              i[0] = 1;
              i[1] = s;
              i[2] = 0;
              break;
            case 1:
              i[0] = a;
              i[1] = 1;
              i[2] = 0;
              break;
            case 2:
              i[0] = 0;
              i[1] = 1;
              i[2] = s;
              break;
            case 3:
              i[0] = 0;
              i[1] = a;
              i[2] = 1;
              break;
            case 4:
              i[0] = s;
              i[1] = 0;
              i[2] = 1;
              break;
            default:
              i[0] = 1;
              i[1] = 0;
              i[2] = a;
          }
          c = (1 - n) * o;
          return [
            (n * i[0] + c) * 255,
            (n * i[1] + c) * 255,
            (n * i[2] + c) * 255,
          ];
        };
        r.hcg.hsv = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e + n * (1 - e);
          let i = 0;
          if (o > 0) {
            i = e / o;
          }
          return [t[0], i * 100, o * 100];
        };
        r.hcg.hsl = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = n * (1 - e) + 0.5 * e;
          let i = 0;
          if (o > 0 && o < 0.5) {
            i = e / (2 * o);
          } else if (o >= 0.5 && o < 1) {
            i = e / (2 * (1 - o));
          }
          return [t[0], i * 100, o * 100];
        };
        r.hcg.hwb = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = e + n * (1 - e);
          return [t[0], (o - e) * 100, (1 - o) * 100];
        };
        r.hwb.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const o = 1 - n;
          const i = o - e;
          let r = 0;
          if (i < 1) {
            r = (o - i) / (1 - i);
          }
          return [t[0], i * 100, r * 100];
        };
        r.apple.rgb = function (t) {
          return [
            (t[0] / 65535) * 255,
            (t[1] / 65535) * 255,
            (t[2] / 65535) * 255,
          ];
        };
        r.rgb.apple = function (t) {
          return [
            (t[0] / 255) * 65535,
            (t[1] / 255) * 65535,
            (t[2] / 255) * 65535,
          ];
        };
        r.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255];
        };
        r.gray.hsl = function (t) {
          return [0, 0, t[0]];
        };
        r.gray.hsv = r.gray.hsl;
        r.gray.hwb = function (t) {
          return [0, 100, t[0]];
        };
        r.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]];
        };
        r.gray.lab = function (t) {
          return [t[0], 0, 0];
        };
        r.gray.hex = function (t) {
          const e = Math.round((t[0] / 100) * 255) & 255;
          const n = (e << 16) + (e << 8) + e;
          const o = n.toString(16).toUpperCase();
          return '000000'.substring(o.length) + o;
        };
        r.rgb.gray = function (t) {
          const e = (t[0] + t[1] + t[2]) / 3;
          return [(e / 255) * 100];
        };
      },
      85: (t, e, n) => {
        const o = n(168);
        const i = n(111);
        const r = {};
        const s = Object.keys(o);
        function a(t) {
          const e = function (...e) {
            const n = e[0];
            if (n === undefined || n === null) {
              return n;
            }
            if (n.length > 1) {
              e = n;
            }
            return t(e);
          };
          if ('conversion' in t) {
            e.conversion = t.conversion;
          }
          return e;
        }
        function c(t) {
          const e = function (...e) {
            const n = e[0];
            if (n === undefined || n === null) {
              return n;
            }
            if (n.length > 1) {
              e = n;
            }
            const o = t(e);
            if (typeof o === 'object') {
              for (let t = o.length, e = 0; e < t; e++) {
                o[e] = Math.round(o[e]);
              }
            }
            return o;
          };
          if ('conversion' in t) {
            e.conversion = t.conversion;
          }
          return e;
        }
        s.forEach(t => {
          r[t] = {};
          Object.defineProperty(r[t], 'channels', { value: o[t].channels });
          Object.defineProperty(r[t], 'labels', { value: o[t].labels });
          const e = i(t);
          const n = Object.keys(e);
          n.forEach(n => {
            const o = e[n];
            r[t][n] = c(o);
            r[t][n].raw = a(o);
          });
        });
        t.exports = r;
      },
      111: (t, e, n) => {
        const o = n(168);
        function i() {
          const t = {};
          const e = Object.keys(o);
          for (let n = e.length, o = 0; o < n; o++) {
            t[e[o]] = { distance: -1, parent: null };
          }
          return t;
        }
        function r(t) {
          const e = i();
          const n = [t];
          e[t].distance = 0;
          while (n.length) {
            const t = n.pop();
            const i = Object.keys(o[t]);
            for (let o = i.length, r = 0; r < o; r++) {
              const o = i[r];
              const s = e[o];
              if (s.distance === -1) {
                s.distance = e[t].distance + 1;
                s.parent = t;
                n.unshift(o);
              }
            }
          }
          return e;
        }
        function s(t, e) {
          return function (n) {
            return e(t(n));
          };
        }
        function a(t, e) {
          const n = [e[t].parent, t];
          let i = o[e[t].parent][t];
          let r = e[t].parent;
          while (e[r].parent) {
            n.unshift(e[r].parent);
            i = s(o[e[r].parent][r], i);
            r = e[r].parent;
          }
          i.conversion = n;
          return i;
        }
        t.exports = function (t) {
          const e = r(t);
          const n = {};
          const o = Object.keys(e);
          for (let t = o.length, i = 0; i < t; i++) {
            const t = o[i];
            const r = e[t];
            if (r.parent === null) {
              continue;
            }
            n[t] = a(t, e);
          }
          return n;
        };
      },
      874: t => {
        'use strict';
        t.exports = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50],
        };
      },
      799: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css',
            ],
            names: [],
            mappings:
              'AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\tposition: absolute;\n\tpointer-events: none;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"@ckeditor/ckeditor5-ui/theme/mixins/_dir.css\";\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\theight: 0;\n\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\tbackground: var(--ck-clipboard-drop-target-color);\n\tmargin-top: -1px;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: absolute;\n\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\twidth: 0;\n\t\theight: 0;\n\t\tborder-style: solid;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tleft: -1px;\n\n\t\t\tborder-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);\n\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tright: -1px;\n\n\t\t\tborder-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;\n\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t}\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      624: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      372: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css',
            ],
            names: [],
            mappings:
              'AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      37: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css',
            ],
            names: [],
            mappings: 'AAMA,qDACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      544: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,+CAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n\t--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n\tbackground: var(--ck-color-mention-background);\n\tcolor: var(--ck-color-mention-text);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      139: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAM7C,iBAAkB,CAJlB,eAAgB,CAMhB,2BAQD,CAJC,+BAEC,aAAc,CADd,eAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n\tmax-height: var(--ck-mention-list-max-height);\n\n\toverflow-y: auto;\n\n\t/* Prevent unnecessary horizontal scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\toverflow-x: hidden;\n\n\toverscroll-behavior: contain;\n\n\t/* Prevent unnecessary vertical scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\t& > .ck-list__item {\n\t\toverflow: hidden;\n\t\tflex-shrink: 0;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      290: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-aria-live-announcer{left:-10000px;position:absolute;top:-10000px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css',
            ],
            names: [],
            mappings: 'AAKA,2BAEC,aAAc,CADd,iBAAkB,CAElB,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-aria-live-announcer {\n\tposition: absolute;\n\tleft: -10000px;\n\ttop: -10000px;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      29: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-modal)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/autocomplete/autocomplete.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-autocomplete {\n\tposition: relative;\n\n\t& > .ck-search__results {\n\t\tposition: absolute;\n\t\tz-index: var(--ck-z-modal);\n\n\t\t&.ck-search__results_n {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-search__results_s {\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck.ck-autocomplete {\n\t& > .ck-search__results {\n\t\t@mixin ck-rounded-corners;\n\t\t@mixin ck-drop-shadow;\n\n\t\tmax-height: 200px;\n\t\toverflow-y: auto;\n\t\tbackground: var(--ck-color-base-background);\n\t\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\t\tmin-width: auto;\n\n\t\t&.ck-search__results_n {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t/* Prevent duplicated borders between the input and the results pane. */\n\t\t\tmargin-bottom: -1px;\n\t\t}\n\n\t\t&.ck-search__results_s {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-top-right-radius: 0;\n\n\t\t\t/* Prevent duplicated borders between the input and the results pane. */\n\t\t\tmargin-top: -1px;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      971: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}[dir=ltr] .ck.ck-button,[dir=ltr] a.ck.ck-button{justify-content:left}[dir=rtl] .ck.ck-button,[dir=rtl] a.ck.ck-button{justify-content:right}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AAQA,6BAMC,kBAAmB,CADnB,mBAAoB,CADpB,iBAAkB,CCHlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD0BD,CA9BA,iDASE,oBAqBF,CA9BA,iDAaE,qBAiBF,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEzBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../../mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\n\t@mixin ck-dir ltr {\n\t\tjustify-content: left;\n\t}\n\n\t@mixin ck-dir rtl {\n\t\tjustify-content: right;\n\t}\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      258: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
            ],
            names: [],
            mappings:
              'AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floatingpoint numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      923: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css',
            ],
            names: [],
            mappings:
              'AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-selector__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      257: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css',
            ],
            names: [],
            mappings:
              'AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n\twidth: max-content;\n\n\t& .ck.ck-input {\n\t\tmin-width: unset;\n\t}\n}\n\n.ck.ck-color-picker__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\tmargin: var(--ck-spacing-large) 0 0;\n\twidth: unset;\n\n\t& .ck.ck-labeled-field-view {\n\t\tpadding-top: unset;\n\t}\n\n\t& .ck.ck-input-text {\n\t\twidth: unset;\n\t}\n\n\t& .ck-color-picker__hash-view {\n\t\tpadding-top: var(--ck-spacing-tiny);\n\t\tpadding-right: var(--ck-spacing-medium);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      306: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css',
            ],
            names: [],
            mappings:
              'AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tjustify-content: flex-start;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tdisplay: flex;\n\t\t\tflex-direction: row;\n\t\t\tjustify-content: space-around;\n\n\t\t\t& .ck-button-save,\n\t\t\t& .ck-button-cancel {\n\t\t\t\tflex: 1\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n\t/* View fragment with color grids. */\n\t& .ck-color-grids-fragment {\n\t\t& .ck-button.ck-color-selector__remove-color,\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t& .ck-button.ck-color-selector__color-picker {\n\t\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck.ck-icon {\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& label.ck.ck-color-grid__label {\n\t\t\tfont-weight: unset;\n\t\t}\n\t}\n\n\t/* View fragment with a color picker. */\n\t& .ck-color-picker-fragment {\n\t\t& .ck.ck-color-picker {\n\t\t\tpadding: 8px;\n\n\t\t\t& .hex-color-picker {\n\t\t\t\theight: 100px;\n\t\t\t\tmin-width: 180px;\n\n\t\t\t\t&::part(saturation) {\n\t\t\t\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\t\t\t\t}\n\n\t\t\t\t&::part(hue) {\n\t\t\t\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\t\t\t}\n\n\t\t\t\t&::part(saturation-pointer),\n\t\t\t\t&::part(hue-pointer) {\n\t\t\t\t\twidth: 15px;\n\t\t\t\t\theight: 15px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .ck.ck-color-selector_action-bar {\n\t\t\tpadding: 0 8px 8px;\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      62: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD',
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      883: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      791: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      704: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      847: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-panel-background);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-panel-background);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      668: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}[dir=ltr] .ck.ck-form__header .ck-icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-form__header .ck-icon{margin-left:var(--ck-spacing-medium)}.ck.ck-form__header .ck-form__header__label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css',
            ],
            names: [],
            mappings:
              'AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BAKD,CAHC,8CACC,WACD,CCPD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAkBD,CAbC,uCAEE,qCAMF,CARA,uCAME,oCAEF,CAEA,4CACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n\n\t& h2.ck-form__header__label {\n\t\tflex-grow: 1;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-medium);\n\t\t}\n\t}\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      746: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css',
            ],
            names: [],
            mappings:
              'AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-highlighted-text mark {\n\tbackground: var(--ck-color-highlight-background);\n\tvertical-align: initial;\n\tfont-weight: inherit;\n\tline-height: inherit;\n\tfont-size: inherit;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      977: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css',
            ],
            names: [],
            mappings:
              'AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      470: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      525: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css',
            ],
            names: [],
            mappings: 'AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      933: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0;transform:translate(calc(var(--ck-spacing-medium)*-1),-6px) scale(.75);transform-origin:100% 0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD+GD,CA1GA,2FCDE,qCD2GF,CAvGC,mEACC,UAoCD,CAlCC,gFACC,KAgCD,CAjCA,0FAIE,MAAS,CAGT,6DAA+D,CAF/D,oBA4BF,CAjCA,0FAWE,OAAU,CAEV,sEAA0E,CAD1E,uBAqBF,CAjCA,gFAkBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAH9C,mBAAoB,CAQpB,sBAAuB,CAKvB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t\ttransform-origin: 0 0;\n\t\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t\ttransform-origin: 100% 0;\n\t\t\t\ttransform: translate(calc(-1 * var(--ck-spacing-medium)), -6px) scale(.75);\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      179: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;width:100%}[dir=ltr] .ck.ck-list__item .ck-button{text-align:left}[dir=rtl] .ck.ck-list__item .ck-button{text-align:right}.ck.ck-list__item .ck-button{padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>.ck-label{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEdD,YCCC,eDID,CALA,+DCKE,qCDAF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cAkED,CAhEC,6BAGC,eAAgB,CAFhB,gBAAiB,CACjB,UA+CD,CAjDA,uCAME,eA2CF,CAjDA,uCAUE,gBAuCF,CAjDA,6BAgBC,iIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,mCACC,cAAe,CACf,eAAiB,CACjB,oFACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\tborder-radius: 0;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-list .ck-list__group {\n\tpadding-top: var(--ck-spacing-medium);\n\n\t/* The group should have a border when it\'s not the first item. */\n\t*:not(.ck-hidden) ~ & {\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& > .ck-label {\n\t\tfont-size: 11px;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium);\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      460: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      592: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css',
            ],
            names: [],
            mappings:
              'AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      356: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      707: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      332: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/search/search.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css',
            ],
            names: [],
            mappings:
              'AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-search {\n\t& > .ck-labeled-field-view {\n\t\t& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: var(--ck-spacing-medium);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: var(--ck-spacing-medium);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-search__reset {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\t}\n\n\t& > .ck-search__results {\n\t\t& > .ck-search__info {\n\t\t\t& > span:first-child {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\n\t\t\t/* Hide the filtered view when nothing was found */\n\t\t\t&:not(.ck-hidden) ~ * {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));\n}\n\n.ck.ck-search {\n\t& > .ck-labeled-field-view {\n\t\t& .ck-input {\n\t\t\twidth: 100%;\n\t\t}\n\n\t\t&.ck-search__query_with-icon {\n\t\t\t--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);\n\n\t\t\t& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n\t\t\t\topacity: .5;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tpadding-left: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t&:not(.ck-input-text_empty) {\n\t\t\t\t\t\tpadding-left: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-search__query_with-reset {\n\t\t\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);\n\n\t\t\t&.ck-labeled-field-view_empty {\n\t\t\t\t--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);\n\t\t\t}\n\n\t\t\t& .ck-search__reset {\n\t\t\t\tmin-width: auto;\n\t\t\t\tmin-height: auto;\n\n\t\t\t\tbackground: none;\n\t\t\t\topacity: .5;\n\t\t\t\tpadding: 0;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-medium);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-medium);\n\t\t\t\t}\n\n\t\t\t\t&:hover {\n\t\t\t\t\topacity: 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t&:not(.ck-input-text_empty) {\n\t\t\t\t\t\tpadding-right: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tpadding-right: var(--ck-search-field-view-horizontal-spacing);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-search__results {\n\t\tmin-width: 100%;\n\n\t\t& > .ck-search__info {\n\t\t\twidth: 100%;\n\t\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\n\t\t\t& * {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\n\t\t\t& > span:first-child {\n\t\t\t\tfont-weight: bold;\n\t\t\t}\n\n\t\t\t& > span:last-child {\n\t\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t\t}\n\t\t}\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      446: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:rotate 1.5s linear infinite}.ck.ck-spinner,.ck.ck-spinner-container{height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent}@keyframes rotate{to{transform:rotate(1turn)}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/spinner/spinner.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css',
            ],
            names: [],
            mappings:
              'AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,qCACD,CAEA,wCAJC,qCAAsC,CADtC,oCAWD,CANA,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCACD,CAEA,kBACC,GACC,uBACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n\tdisplay: block;\n\tposition: relative;\n}\n\n.ck.ck-spinner {\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 0;\n\tright: 0;\n\tmargin: 0 auto;\n\ttransform: translateY(-50%);\n\tz-index: 1;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n\twidth: var(--ck-toolbar-spinner-size);\n\theight: var(--ck-toolbar-spinner-size);\n\tanimation: 1.5s infinite rotate linear;\n}\n\n.ck.ck-spinner {\n\twidth: var(--ck-toolbar-spinner-size);\n\theight: var(--ck-toolbar-spinner-size);\n\tborder-radius: 50%;\n\tborder: 2px solid var(--ck-color-text);\n\tborder-top-color: transparent;\n}\n\n@keyframes rotate {\n\tto {\n\t\ttransform: rotate(360deg)\n\t}\n}\n\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      224: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck-textarea{overflow-x:hidden}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css',
            ],
            names: [],
            mappings: 'AASA,aACC,iBACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/*\n * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.\n * This bug is especially visible when rows=1.\n */\n.ck-textarea {\n\toverflow-x: hidden\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      176: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css',
            ],
            names: [],
            mappings:
              'AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      768: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css',
            ],
            names: [],
            mappings:
              'AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      888: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css',
            ],
            names: [],
            mappings:
              'AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDRnC,mBAAoB,CAEpB,qCACD,CCOC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CACrB,wCAAyC,CAFzC,wBAGD,CApBD,gCAuBC,eAMD,CAHC,uCACC,YACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-tooltip-text-padding: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t&.ck-tooltip_multi-line .ck-tooltip__text {\n\t\twhite-space: break-spaces;\n\t\tdisplay: inline-block;\n\t\tpadding: var(--ck-tooltip-text-padding) 0;\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      167: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-color-light-red:#fcc;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_poweredby.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css',
            ],
            names: [],
            mappings:
              'AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAyD,CAIzD,yBAAgD,CC3GhD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJ2GD,CIrGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-powered-by-line-height: 10px;\n\t--ck-powered-by-padding-vertical: 2px;\n\t--ck-powered-by-padding-horizontal: 4px;\n\t--ck-powered-by-text-color: hsl(0, 0%, 31%);\n\t--ck-powered-by-border-radius: var(--ck-border-radius);\n\t--ck-powered-by-background: hsl(0, 0%, 100%);\n\t--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n\t--ck-border-radius: var(--ck-powered-by-border-radius);\n\n\tbox-shadow: none;\n\tbackground: var(--ck-powered-by-background);\n\tmin-height: unset;\n\tz-index: calc( var(--ck-z-modal) - 1 );\n\n\t& .ck.ck-powered-by {\n\t\tline-height: var(--ck-powered-by-line-height);\n\n\t\t& a {\n\t\t\tcursor: pointer;\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\t\t\topacity: .66;\n\t\t\tfilter: grayscale(80%);\n\t\t\tline-height: var(--ck-powered-by-line-height);\n\t\t\tpadding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n\t\t}\n\n\t\t& .ck-powered-by__label {\n\t\t\tfont-size: 7.5px;\n\t\t\tletter-spacing: -.2px;\n\t\t\tpadding-left: 2px;\n\t\t\ttext-transform: uppercase;\n\t\t\tfont-weight: bold;\n\t\t\tmargin-right: 4px;\n\t\t\tcursor: pointer;\n\t\t\tline-height: normal;\n\t\t\tcolor: var(--ck-powered-by-text-color);\n\n\t\t}\n\n\t\t& .ck-icon {\n\t\t\tdisplay: block;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t&:hover {\n\t\t\t& a {\n\t\t\t\tfilter: grayscale(0%);\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[class*="position_inside"] {\n\t\tborder-color: transparent;\n\t}\n\n\t&[class*="position_border"] {\n\t\tborder: var(--ck-focus-ring);\n\t\tborder-color: var(--ck-powered-by-border-color);\n\t}\n}\n\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------- */\n\n\t--ck-color-light-red:\t\t\t\t\t\t\t\t\t\thsl(0, 100%, 90%);\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      153: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          ':root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css',
            ],
            names: [],
            mappings:
              'AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      875: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css',
            ],
            names: [],
            mappings:
              'AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      347: (t, e, n) => {
        'use strict';
        n.d(e, { Z: () => c });
        var o = n(15);
        var i = n.n(o);
        var r = n(645);
        var s = n.n(r);
        var a = s()(i());
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          '',
          {
            version: 3,
            sources: [
              'webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css',
              'webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css',
            ],
            names: [],
            mappings:
              'AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD',
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        const c = a;
      },
      645: t => {
        'use strict';
        t.exports = function (t) {
          var e = [];
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e);
              if (e[2]) {
                return '@media '.concat(e[2], ' {').concat(n, '}');
              }
              return n;
            }).join('');
          };
          e.i = function (t, n, o) {
            if (typeof t === 'string') {
              t = [[null, t, '']];
            }
            var i = {};
            if (o) {
              for (var r = 0; r < this.length; r++) {
                var s = this[r][0];
                if (s != null) {
                  i[s] = true;
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a]);
              if (o && i[c[0]]) {
                continue;
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n;
                } else {
                  c[2] = ''.concat(n, ' and ').concat(c[2]);
                }
              }
              e.push(c);
            }
          };
          return e;
        };
      },
      15: t => {
        'use strict';
        function e(t, e) {
          return s(t) || r(t, e) || o(t, e) || n();
        }
        function n() {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
          );
        }
        function o(t, e) {
          if (!t) return;
          if (typeof t === 'string') return i(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          if (n === 'Object' && t.constructor) n = t.constructor.name;
          if (n === 'Map' || n === 'Set') return Array.from(t);
          if (
            n === 'Arguments' ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return i(t, e);
        }
        function i(t, e) {
          if (e == null || e > t.length) e = t.length;
          for (var n = 0, o = new Array(e); n < e; n++) {
            o[n] = t[n];
          }
          return o;
        }
        function r(t, e) {
          var n =
            t &&
            ((typeof Symbol !== 'undefined' && t[Symbol.iterator]) ||
              t['@@iterator']);
          if (n == null) return;
          var o = [];
          var i = true;
          var r = false;
          var s, a;
          try {
            for (n = n.call(t); !(i = (s = n.next()).done); i = true) {
              o.push(s.value);
              if (e && o.length === e) break;
            }
          } catch (t) {
            r = true;
            a = t;
          } finally {
            try {
              if (!i && n['return'] != null) n['return']();
            } finally {
              if (r) throw a;
            }
          }
          return o;
        }
        function s(t) {
          if (Array.isArray(t)) return t;
        }
        t.exports = function t(n) {
          var o = e(n, 4),
            i = o[1],
            r = o[3];
          if (!r) {
            return i;
          }
          if (typeof btoa === 'function') {
            var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
            var a =
              'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(
                s,
              );
            var c = '/*# '.concat(a, ' */');
            var l = r.sources.map(function (t) {
              return '/*# sourceURL='
                .concat(r.sourceRoot || '')
                .concat(t, ' */');
            });
            return [i].concat(l).concat([c]).join('\n');
          }
          return [i].join('\n');
        };
      },
      379: (t, e, n) => {
        'use strict';
        var o = (function t() {
          var e;
          return function t() {
            if (typeof e === 'undefined') {
              e = Boolean(window && document && document.all && !window.atob);
            }
            return e;
          };
        })();
        var i = (function t() {
          var e = {};
          return function t(n) {
            if (typeof e[n] === 'undefined') {
              var o = document.querySelector(n);
              if (
                window.HTMLIFrameElement &&
                o instanceof window.HTMLIFrameElement
              ) {
                try {
                  o = o.contentDocument.head;
                } catch (t) {
                  o = null;
                }
              }
              e[n] = o;
            }
            return e[n];
          };
        })();
        var r = [];
        function s(t) {
          var e = -1;
          for (var n = 0; n < r.length; n++) {
            if (r[n].identifier === t) {
              e = n;
              break;
            }
          }
          return e;
        }
        function a(t, e) {
          var n = {};
          var o = [];
          for (var i = 0; i < t.length; i++) {
            var a = t[i];
            var c = e.base ? a[0] + e.base : a[0];
            var l = n[c] || 0;
            var d = ''.concat(c, ' ').concat(l);
            n[c] = l + 1;
            var h = s(d);
            var u = { css: a[1], media: a[2], sourceMap: a[3] };
            if (h !== -1) {
              r[h].references++;
              r[h].updater(u);
            } else {
              r.push({ identifier: d, updater: g(u, e), references: 1 });
            }
            o.push(d);
          }
          return o;
        }
        function c(t) {
          var e = document.createElement('style');
          var o = t.attributes || {};
          if (typeof o.nonce === 'undefined') {
            var r = true ? n.nc : 0;
            if (r) {
              o.nonce = r;
            }
          }
          Object.keys(o).forEach(function (t) {
            e.setAttribute(t, o[t]);
          });
          if (typeof t.insert === 'function') {
            t.insert(e);
          } else {
            var s = i(t.insert || 'head');
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.",
              );
            }
            s.appendChild(e);
          }
          return e;
        }
        function l(t) {
          if (t.parentNode === null) {
            return false;
          }
          t.parentNode.removeChild(t);
        }
        var d = (function t() {
          var e = [];
          return function t(n, o) {
            e[n] = o;
            return e.filter(Boolean).join('\n');
          };
        })();
        function h(t, e, n, o) {
          var i = n
            ? ''
            : o.media
            ? '@media '.concat(o.media, ' {').concat(o.css, '}')
            : o.css;
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, i);
          } else {
            var r = document.createTextNode(i);
            var s = t.childNodes;
            if (s[e]) {
              t.removeChild(s[e]);
            }
            if (s.length) {
              t.insertBefore(r, s[e]);
            } else {
              t.appendChild(r);
            }
          }
        }
        function u(t, e, n) {
          var o = n.css;
          var i = n.media;
          var r = n.sourceMap;
          if (i) {
            t.setAttribute('media', i);
          } else {
            t.removeAttribute('media');
          }
          if (r && typeof btoa !== 'undefined') {
            o += '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
              btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
              ' */',
            );
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = o;
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild);
            }
            t.appendChild(document.createTextNode(o));
          }
        }
        var f = null;
        var p = 0;
        function g(t, e) {
          var n;
          var o;
          var i;
          if (e.singleton) {
            var r = p++;
            n = f || (f = c(e));
            o = h.bind(null, n, r, false);
            i = h.bind(null, n, r, true);
          } else {
            n = c(e);
            o = u.bind(null, n, e);
            i = function t() {
              l(n);
            };
          }
          o(t);
          return function e(n) {
            if (n) {
              if (
                n.css === t.css &&
                n.media === t.media &&
                n.sourceMap === t.sourceMap
              ) {
                return;
              }
              o((t = n));
            } else {
              i();
            }
          };
        }
        t.exports = function (t, e) {
          e = e || {};
          if (!e.singleton && typeof e.singleton !== 'boolean') {
            e.singleton = o();
          }
          t = t || [];
          var n = a(t, e);
          return function t(o) {
            o = o || [];
            if (Object.prototype.toString.call(o) !== '[object Array]') {
              return;
            }
            for (var i = 0; i < n.length; i++) {
              var c = n[i];
              var l = s(c);
              r[l].references--;
            }
            var d = a(o, e);
            for (var h = 0; h < n.length; h++) {
              var u = n[h];
              var f = s(u);
              if (r[f].references === 0) {
                r[f].updater();
                r.splice(f, 1);
              }
            }
            n = d;
          };
        };
      },
    };
    var e = {};
    function n(o) {
      var i = e[o];
      if (i !== undefined) {
        return i.exports;
      }
      var r = (e[o] = { id: o, exports: {} });
      t[o](r, r.exports, n);
      return r.exports;
    }
    (() => {
      n.n = t => {
        var e = t && t.__esModule ? () => t['default'] : () => t;
        n.d(e, { a: e });
        return e;
      };
    })();
    (() => {
      n.d = (t, e) => {
        for (var o in e) {
          if (n.o(e, o) && !n.o(t, o)) {
            Object.defineProperty(t, o, { enumerable: true, get: e[o] });
          }
        }
      };
    })();
    (() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
    })();
    (() => {
      n.nc = undefined;
    })();
    var o = {};
    (() => {
      'use strict';
      n.d(o, { default: () => VR });
      function t({
        emitter: t,
        activator: e,
        callback: n,
        contextElements: o,
      }) {
        t.listenTo(document, 'mousedown', (t, i) => {
          if (!e()) {
            return;
          }
          const r = typeof i.composedPath == 'function' ? i.composedPath() : [];
          const s = typeof o == 'function' ? o() : o;
          for (const t of s) {
            if (t.contains(i.target) || r.includes(t)) {
              return;
            }
          }
          n();
        });
      }
      function e() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch (t) {
          return '';
        }
      }
      const i = e();
      const r = {
        isMac: a(i),
        isWindows: c(i),
        isGecko: l(i),
        isSafari: d(i),
        isiOS: h(i),
        isAndroid: u(i),
        isBlink: f(i),
        features: { isRegExpUnicodePropertySupported: p() },
      };
      const s = r;
      function a(t) {
        return t.indexOf('macintosh') > -1;
      }
      function c(t) {
        return t.indexOf('windows') > -1;
      }
      function l(t) {
        return !!t.match(/gecko\/\d+/);
      }
      function d(t) {
        return t.indexOf(' applewebkit/') > -1 && t.indexOf('chrome') === -1;
      }
      function h(t) {
        return (
          !!t.match(/iphone|ipad/i) || (a(t) && navigator.maxTouchPoints > 0)
        );
      }
      function u(t) {
        return t.indexOf('android') > -1;
      }
      function f(t) {
        return t.indexOf('chrome/') > -1 && t.indexOf('edge/') < 0;
      }
      function p() {
        let t = false;
        try {
          t = ''.search(new RegExp('[\\p{L}]', 'u')) === 0;
        } catch (t) {}
        return t;
      }
      function g(t, e, n, o) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const i = Array.isArray(t) ? t : Array.prototype.slice.call(t);
        const r = Array.isArray(e) ? e : Array.prototype.slice.call(e);
        const s = m(i, r, n);
        const a = o ? _(s, r.length) : w(r, s);
        return a;
      }
      function m(t, e, n) {
        const o = k(t, e, n);
        if (o === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
        }
        const i = b(t, o);
        const r = b(e, o);
        const s = k(i, r, n);
        const a = t.length - s;
        const c = e.length - s;
        return { firstIndex: o, lastIndexOld: a, lastIndexNew: c };
      }
      function k(t, e, n) {
        for (let o = 0; o < Math.max(t.length, e.length); o++) {
          if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
            return o;
          }
        }
        return -1;
      }
      function b(t, e) {
        return t.slice(e).reverse();
      }
      function w(t, e) {
        const n = [];
        const { firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e;
        if (r - o > 0) {
          n.push({ index: o, type: 'insert', values: t.slice(o, r) });
        }
        if (i - o > 0) {
          n.push({ index: o + (r - o), type: 'delete', howMany: i - o });
        }
        return n;
      }
      function _(t, e) {
        const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t;
        if (n === -1) {
          return Array(e).fill('equal');
        }
        let r = [];
        if (n > 0) {
          r = r.concat(Array(n).fill('equal'));
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill('insert'));
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill('delete'));
        }
        if (i < e) {
          r = r.concat(Array(e - i).fill('equal'));
        }
        return r;
      }
      function v(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const o = t.length;
        const i = e.length;
        if (o > 200 || i > 200 || o + i > 300) {
          return v.fastDiff(t, e, n, true);
        }
        let r, s;
        if (i < o) {
          const n = t;
          t = e;
          e = n;
          r = 'delete';
          s = 'insert';
        } else {
          r = 'insert';
          s = 'delete';
        }
        const a = t.length;
        const c = e.length;
        const l = c - a;
        const d = {};
        const h = {};
        function u(o) {
          const i = (h[o - 1] !== undefined ? h[o - 1] : -1) + 1;
          const l = h[o + 1] !== undefined ? h[o + 1] : -1;
          const u = i > l ? -1 : 1;
          if (d[o + u]) {
            d[o] = d[o + u].slice(0);
          }
          if (!d[o]) {
            d[o] = [];
          }
          d[o].push(i > l ? r : s);
          let f = Math.max(i, l);
          let p = f - o;
          while (p < a && f < c && n(t[p], e[f])) {
            p++;
            f++;
            d[o].push('equal');
          }
          return f;
        }
        let f = 0;
        let p;
        do {
          for (p = -f; p < l; p++) {
            h[p] = u(p);
          }
          for (p = l + f; p > l; p--) {
            h[p] = u(p);
          }
          h[l] = u(l);
          f++;
        } while (h[l] !== c);
        return d[l].slice(1);
      }
      v.fastDiff = g;
      function A() {
        return function t() {
          t.called = true;
        };
      }
      const C = A;
      class y {
        constructor(t, e) {
          this.source = t;
          this.name = e;
          this.path = [];
          this.stop = C();
          this.off = C();
        }
      }
      const x = new Array(256)
        .fill('')
        .map((t, e) => ('0' + e.toString(16)).slice(-2));
      function E() {
        const t = (Math.random() * 4294967296) >>> 0;
        const e = (Math.random() * 4294967296) >>> 0;
        const n = (Math.random() * 4294967296) >>> 0;
        const o = (Math.random() * 4294967296) >>> 0;
        return (
          'e' +
          x[(t >> 0) & 255] +
          x[(t >> 8) & 255] +
          x[(t >> 16) & 255] +
          x[(t >> 24) & 255] +
          x[(e >> 0) & 255] +
          x[(e >> 8) & 255] +
          x[(e >> 16) & 255] +
          x[(e >> 24) & 255] +
          x[(n >> 0) & 255] +
          x[(n >> 8) & 255] +
          x[(n >> 16) & 255] +
          x[(n >> 24) & 255] +
          x[(o >> 0) & 255] +
          x[(o >> 8) & 255] +
          x[(o >> 16) & 255] +
          x[(o >> 24) & 255]
        );
      }
      const D = {
        get(t = 'normal') {
          if (typeof t != 'number') {
            return this[t] || this.normal;
          } else {
            return t;
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      };
      const T = D;
      function S(t, e) {
        const n = T.get(e.priority);
        for (let o = 0; o < t.length; o++) {
          if (T.get(t[o].priority) < n) {
            t.splice(o, 0, e);
            return;
          }
        }
        t.push(e);
      }
      const P =
        'https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html';
      class B extends Error {
        constructor(t, e, n) {
          super(M(t, n));
          this.name = 'CKEditorError';
          this.context = e;
          this.data = n;
        }
        is(t) {
          return t === 'CKEditorError';
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is('CKEditorError')) {
            throw t;
          }
          const n = new B(t.message, e);
          n.stack = t.stack;
          throw n;
        }
      }
      function R(t, e) {
        console.warn(...V(t, e));
      }
      function O(t, e) {
        console.error(...V(t, e));
      }
      function I(t) {
        return `\nRead more: ${P}#error-${t}`;
      }
      function M(t, e) {
        const n = new WeakSet();
        const o = (t, e) => {
          if (typeof e === 'object' && e !== null) {
            if (n.has(e)) {
              return `[object ${e.constructor.name}]`;
            }
            n.add(e);
          }
          return e;
        };
        const i = e ? ` ${JSON.stringify(e, o)}` : '';
        const r = I(t);
        return t + i + r;
      }
      function V(t, e) {
        const n = I(t);
        return e ? [t, e, n] : [t, n];
      }
      const z = '40.1.0';
      const F = null && z;
      const N = new Date(2023, 10, 15);
      if (globalThis.CKEDITOR_VERSION) {
        throw new B('ckeditor-duplicated-modules', null);
      } else {
        globalThis.CKEDITOR_VERSION = z;
      }
      const L = Symbol('listeningTo');
      const H = Symbol('emitterId');
      const j = Symbol('delegations');
      const q = $(Object);
      function $(t) {
        if (!t) {
          return q;
        }
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n);
          }
          once(t, e, n) {
            let o = false;
            const i = (t, ...n) => {
              if (!o) {
                o = true;
                t.off();
                e.call(this, t, ...n);
              }
            };
            this.listenTo(this, t, i, n);
          }
          off(t, e) {
            this.stopListening(this, t, e);
          }
          listenTo(t, e, n, o = {}) {
            let i, r;
            if (!this[L]) {
              this[L] = {};
            }
            const s = this[L];
            if (!K(t)) {
              G(t);
            }
            const a = K(t);
            if (!(i = s[a])) {
              i = s[a] = { emitter: t, callbacks: {} };
            }
            if (!(r = i.callbacks[e])) {
              r = i.callbacks[e] = [];
            }
            r.push(n);
            tt(this, t, e, n, o);
          }
          stopListening(t, e, n) {
            const o = this[L];
            let i = t && K(t);
            const r = o && i ? o[i] : undefined;
            const s = r && e ? r.callbacks[e] : undefined;
            if (!o || (t && !r) || (e && !s)) {
              return;
            }
            if (n) {
              et(this, t, e, n);
              const o = s.indexOf(n);
              if (o !== -1) {
                if (s.length === 1) {
                  delete r.callbacks[e];
                } else {
                  et(this, t, e, n);
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                et(this, t, e, n);
              }
              delete r.callbacks[e];
            } else if (r) {
              for (e in r.callbacks) {
                this.stopListening(t, e);
              }
              delete o[i];
            } else {
              for (i in o) {
                this.stopListening(o[i].emitter);
              }
              delete this[L];
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof y ? t : new y(this, t);
              const o = n.name;
              let i = Q(this, o);
              n.path.push(this);
              if (i) {
                const t = [n, ...e];
                i = Array.from(i);
                for (let e = 0; e < i.length; e++) {
                  i[e].callback.apply(this, t);
                  if (n.off.called) {
                    delete n.off.called;
                    this._removeEventListener(o, i[e].callback);
                  }
                  if (n.stop.called) {
                    break;
                  }
                }
              }
              const r = this[j];
              if (r) {
                const t = r.get(o);
                const i = r.get('*');
                if (t) {
                  X(t, n, e);
                }
                if (i) {
                  X(i, n, e);
                }
              }
              return n.return;
            } catch (t) {
              B.rethrowUnexpectedError(t, this);
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[j]) {
                  this[j] = new Map();
                }
                t.forEach(t => {
                  const o = this[j].get(t);
                  if (!o) {
                    this[j].set(t, new Map([[e, n]]));
                  } else {
                    o.set(e, n);
                  }
                });
              },
            };
          }
          stopDelegating(t, e) {
            if (!this[j]) {
              return;
            }
            if (!t) {
              this[j].clear();
            } else if (!e) {
              this[j].delete(t);
            } else {
              const n = this[j].get(t);
              if (n) {
                n.delete(e);
              }
            }
          }
          _addEventListener(t, e, n) {
            J(this, t);
            const o = Y(this, t);
            const i = T.get(n.priority);
            const r = { callback: e, priority: i };
            for (const t of o) {
              S(t, r);
            }
          }
          _removeEventListener(t, e) {
            const n = Y(this, t);
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1);
                  n--;
                }
              }
            }
          }
        }
        return e;
      }
      [
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach(t => {
        $[t] = q.prototype[t];
      });
      function W(t, e) {
        const n = t[L];
        if (n && n[e]) {
          return n[e].emitter;
        }
        return null;
      }
      function G(t, e) {
        if (!t[H]) {
          t[H] = e || E();
        }
      }
      function K(t) {
        return t[H];
      }
      function U(t) {
        if (!t._events) {
          Object.defineProperty(t, '_events', { value: {} });
        }
        return t._events;
      }
      function Z() {
        return { callbacks: [], childEvents: [] };
      }
      function J(t, e) {
        const n = U(t);
        if (n[e]) {
          return;
        }
        let o = e;
        let i = null;
        const r = [];
        while (o !== '') {
          if (n[o]) {
            break;
          }
          n[o] = Z();
          r.push(n[o]);
          if (i) {
            n[o].childEvents.push(i);
          }
          i = o;
          o = o.substr(0, o.lastIndexOf(':'));
        }
        if (o !== '') {
          for (const t of r) {
            t.callbacks = n[o].callbacks.slice();
          }
          n[o].childEvents.push(i);
        }
      }
      function Y(t, e) {
        const n = U(t)[e];
        if (!n) {
          return [];
        }
        let o = [n.callbacks];
        for (let e = 0; e < n.childEvents.length; e++) {
          const i = Y(t, n.childEvents[e]);
          o = o.concat(i);
        }
        return o;
      }
      function Q(t, e) {
        let n;
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(':') > -1) {
            return Q(t, e.substr(0, e.lastIndexOf(':')));
          } else {
            return null;
          }
        }
        return n.callbacks;
      }
      function X(t, e, n) {
        for (let [o, i] of t) {
          if (!i) {
            i = e.name;
          } else if (typeof i == 'function') {
            i = i(e.name);
          }
          const t = new y(e.source, i);
          t.path = [...e.path];
          o.fire(t, ...n);
        }
      }
      function tt(t, e, n, o, i) {
        if (e._addEventListener) {
          e._addEventListener(n, o, i);
        } else {
          t._addEventListener.call(e, n, o, i);
        }
      }
      function et(t, e, n, o) {
        if (e._removeEventListener) {
          e._removeEventListener(n, o);
        } else {
          t._removeEventListener.call(e, n, o);
        }
      }
      function nt(t) {
        var e = typeof t;
        return t != null && (e == 'object' || e == 'function');
      }
      const ot = nt;
      const it = Symbol('observableProperties');
      const rt = Symbol('boundObservables');
      const st = Symbol('boundProperties');
      const at = Symbol('decoratedMethods');
      const ct = Symbol('decoratedOriginal');
      const lt = dt($());
      function dt(t) {
        if (!t) {
          return lt;
        }
        class e extends t {
          set(t, e) {
            if (ot(t)) {
              Object.keys(t).forEach(e => {
                this.set(e, t[e]);
              }, this);
              return;
            }
            ht(this);
            const n = this[it];
            if (t in this && !n.has(t)) {
              throw new B('observable-set-cannot-override', this);
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t);
              },
              set(e) {
                const o = n.get(t);
                let i = this.fire(`set:${t}`, t, e, o);
                if (i === undefined) {
                  i = e;
                }
                if (o !== i || !n.has(t)) {
                  n.set(t, i);
                  this.fire(`change:${t}`, t, i, o);
                }
              },
            });
            this[t] = e;
          }
          bind(...t) {
            if (!t.length || !gt(t)) {
              throw new B('observable-bind-wrong-properties', this);
            }
            if (new Set(t).size !== t.length) {
              throw new B('observable-bind-duplicate-properties', this);
            }
            ht(this);
            const e = this[st];
            t.forEach(t => {
              if (e.has(t)) {
                throw new B('observable-bind-rebind', this);
              }
            });
            const n = new Map();
            t.forEach(t => {
              const o = { property: t, to: [] };
              e.set(t, o);
              n.set(t, o);
            });
            return {
              to: ut,
              toMany: ft,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            };
          }
          unbind(...t) {
            if (!this[it]) {
              return;
            }
            const e = this[st];
            const n = this[rt];
            if (t.length) {
              if (!gt(t)) {
                throw new B('observable-unbind-wrong-properties', this);
              }
              t.forEach(t => {
                const o = e.get(t);
                if (!o) {
                  return;
                }
                o.to.forEach(([t, e]) => {
                  const i = n.get(t);
                  const r = i[e];
                  r.delete(o);
                  if (!r.size) {
                    delete i[e];
                  }
                  if (!Object.keys(i).length) {
                    n.delete(t);
                    this.stopListening(t, 'change');
                  }
                });
                e.delete(t);
              });
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, 'change');
              });
              n.clear();
              e.clear();
            }
          }
          decorate(t) {
            ht(this);
            const e = this[t];
            if (!e) {
              throw new B('observablemixin-cannot-decorate-undefined', this, {
                object: this,
                methodName: t,
              });
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n);
            });
            this[t] = function (...e) {
              return this.fire(t, e);
            };
            this[t][ct] = e;
            if (!this[at]) {
              this[at] = [];
            }
            this[at].push(t);
          }
          stopListening(t, e, n) {
            if (!t && this[at]) {
              for (const t of this[at]) {
                this[t] = this[t][ct];
              }
              delete this[at];
            }
            super.stopListening(t, e, n);
          }
        }
        return e;
      }
      [
        'set',
        'bind',
        'unbind',
        'decorate',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach(t => {
        dt[t] = lt.prototype[t];
      });
      function ht(t) {
        if (t[it]) {
          return;
        }
        Object.defineProperty(t, it, { value: new Map() });
        Object.defineProperty(t, rt, { value: new Map() });
        Object.defineProperty(t, st, { value: new Map() });
      }
      function ut(...t) {
        const e = mt(...t);
        const n = Array.from(this._bindings.keys());
        const o = n.length;
        if (!e.callback && e.to.length > 1) {
          throw new B('observable-bind-to-no-callback', this);
        }
        if (o > 1 && e.callback) {
          throw new B('observable-bind-to-extra-callback', this);
        }
        e.to.forEach(t => {
          if (t.properties.length && t.properties.length !== o) {
            throw new B('observable-bind-to-properties-length', this);
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties;
          }
        });
        this._to = e.to;
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback;
        }
        _t(this._observable, this._to);
        bt(this);
        this._bindProperties.forEach(t => {
          wt(this._observable, t);
        });
      }
      function ft(t, e, n) {
        if (this._bindings.size > 1) {
          throw new B('observable-bind-to-many-not-one-binding', this);
        }
        this.to(...pt(t, e), n);
      }
      function pt(t, e) {
        const n = t.map(t => [t, e]);
        return Array.prototype.concat.apply([], n);
      }
      function gt(t) {
        return t.every(t => typeof t == 'string');
      }
      function mt(...t) {
        if (!t.length) {
          throw new B('observable-bind-to-parse-error', null);
        }
        const e = { to: [] };
        let n;
        if (typeof t[t.length - 1] == 'function') {
          e.callback = t.pop();
        }
        t.forEach(t => {
          if (typeof t == 'string') {
            n.properties.push(t);
          } else if (typeof t == 'object') {
            n = { observable: t, properties: [] };
            e.to.push(n);
          } else {
            throw new B('observable-bind-to-parse-error', null);
          }
        });
        return e;
      }
      function kt(t, e, n, o) {
        const i = t[rt];
        const r = i.get(n);
        const s = r || {};
        if (!s[o]) {
          s[o] = new Set();
        }
        s[o].add(e);
        if (!r) {
          i.set(n, s);
        }
      }
      function bt(t) {
        let e;
        t._bindings.forEach((n, o) => {
          t._to.forEach(i => {
            e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)];
            n.to.push([i.observable, e]);
            kt(t._observable, n, i.observable, e);
          });
        });
      }
      function wt(t, e) {
        const n = t[st];
        const o = n.get(e);
        let i;
        if (o.callback) {
          i = o.callback.apply(
            t,
            o.to.map(t => t[0][t[1]]),
          );
        } else {
          i = o.to[0];
          i = i[0][i[1]];
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = i;
        } else {
          t.set(e, i);
        }
      }
      function _t(t, e) {
        e.forEach(e => {
          const n = t[rt];
          let o;
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, 'change', (i, r) => {
              o = n.get(e.observable)[r];
              if (o) {
                o.forEach(e => {
                  wt(t, e.property);
                });
              }
            });
          }
        });
      }
      class vt {
        constructor() {
          this._replacedElements = [];
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e });
          t.style.display = 'none';
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling);
          }
        }
        restore() {
          this._replacedElements.forEach(({ element: t, newElement: e }) => {
            t.style.display = '';
            if (e) {
              e.remove();
            }
          });
          this._replacedElements = [];
        }
      }
      function At(t) {
        let e = 0;
        for (const n of t) {
          e++;
        }
        return e;
      }
      function Ct(t, e) {
        const n = Math.min(t.length, e.length);
        for (let o = 0; o < n; o++) {
          if (t[o] != e[o]) {
            return o;
          }
        }
        if (t.length == e.length) {
          return 'same';
        } else if (t.length < e.length) {
          return 'prefix';
        } else {
          return 'extension';
        }
      }
      function yt(t) {
        return !!(t && t[Symbol.iterator]);
      }
      var xt =
        typeof global == 'object' &&
        global &&
        global.Object === Object &&
        global;
      const Et = xt;
      var Dt =
        typeof self == 'object' && self && self.Object === Object && self;
      var Tt = Et || Dt || Function('return this')();
      const St = Tt;
      var Pt = St.Symbol;
      const Bt = Pt;
      var Rt = Object.prototype;
      var Ot = Rt.hasOwnProperty;
      var It = Rt.toString;
      var Mt = Bt ? Bt.toStringTag : undefined;
      function Vt(t) {
        var e = Ot.call(t, Mt),
          n = t[Mt];
        try {
          t[Mt] = undefined;
          var o = true;
        } catch (t) {}
        var i = It.call(t);
        if (o) {
          if (e) {
            t[Mt] = n;
          } else {
            delete t[Mt];
          }
        }
        return i;
      }
      const zt = Vt;
      var Ft = Object.prototype;
      var Nt = Ft.toString;
      function Lt(t) {
        return Nt.call(t);
      }
      const Ht = Lt;
      var jt = '[object Null]',
        qt = '[object Undefined]';
      var $t = Bt ? Bt.toStringTag : undefined;
      function Wt(t) {
        if (t == null) {
          return t === undefined ? qt : jt;
        }
        return $t && $t in Object(t) ? zt(t) : Ht(t);
      }
      const Gt = Wt;
      var Kt = Array.isArray;
      const Ut = Kt;
      function Zt(t) {
        return t != null && typeof t == 'object';
      }
      const Jt = Zt;
      var Yt = '[object String]';
      function Qt(t) {
        return typeof t == 'string' || (!Ut(t) && Jt(t) && Gt(t) == Yt);
      }
      const Xt = Qt;
      function te(t, e, n = {}, o = []) {
        const i = n && n.xmlns;
        const r = i ? t.createElementNS(i, e) : t.createElement(e);
        for (const t in n) {
          r.setAttribute(t, n[t]);
        }
        if (Xt(o) || !yt(o)) {
          o = [o];
        }
        for (let e of o) {
          if (Xt(e)) {
            e = t.createTextNode(e);
          }
          r.appendChild(e);
        }
        return r;
      }
      function ee(t, e) {
        return function (n) {
          return t(e(n));
        };
      }
      const ne = ee;
      var oe = ne(Object.getPrototypeOf, Object);
      const ie = oe;
      var re = '[object Object]';
      var se = Function.prototype,
        ae = Object.prototype;
      var ce = se.toString;
      var le = ae.hasOwnProperty;
      var de = ce.call(Object);
      function he(t) {
        if (!Jt(t) || Gt(t) != re) {
          return false;
        }
        var e = ie(t);
        if (e === null) {
          return true;
        }
        var n = le.call(e, 'constructor') && e.constructor;
        return typeof n == 'function' && n instanceof n && ce.call(n) == de;
      }
      const ue = he;
      function fe() {
        this.__data__ = [];
        this.size = 0;
      }
      const pe = fe;
      function ge(t, e) {
        return t === e || (t !== t && e !== e);
      }
      const me = ge;
      function ke(t, e) {
        var n = t.length;
        while (n--) {
          if (me(t[n][0], e)) {
            return n;
          }
        }
        return -1;
      }
      const be = ke;
      var we = Array.prototype;
      var _e = we.splice;
      function ve(t) {
        var e = this.__data__,
          n = be(e, t);
        if (n < 0) {
          return false;
        }
        var o = e.length - 1;
        if (n == o) {
          e.pop();
        } else {
          _e.call(e, n, 1);
        }
        --this.size;
        return true;
      }
      const Ae = ve;
      function Ce(t) {
        var e = this.__data__,
          n = be(e, t);
        return n < 0 ? undefined : e[n][1];
      }
      const ye = Ce;
      function xe(t) {
        return be(this.__data__, t) > -1;
      }
      const Ee = xe;
      function De(t, e) {
        var n = this.__data__,
          o = be(n, t);
        if (o < 0) {
          ++this.size;
          n.push([t, e]);
        } else {
          n[o][1] = e;
        }
        return this;
      }
      const Te = De;
      function Se(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Se.prototype.clear = pe;
      Se.prototype['delete'] = Ae;
      Se.prototype.get = ye;
      Se.prototype.has = Ee;
      Se.prototype.set = Te;
      const Pe = Se;
      function Be() {
        this.__data__ = new Pe();
        this.size = 0;
      }
      const Re = Be;
      function Oe(t) {
        var e = this.__data__,
          n = e['delete'](t);
        this.size = e.size;
        return n;
      }
      const Ie = Oe;
      function Me(t) {
        return this.__data__.get(t);
      }
      const Ve = Me;
      function ze(t) {
        return this.__data__.has(t);
      }
      const Fe = ze;
      var Ne = '[object AsyncFunction]',
        Le = '[object Function]',
        He = '[object GeneratorFunction]',
        je = '[object Proxy]';
      function qe(t) {
        if (!ot(t)) {
          return false;
        }
        var e = Gt(t);
        return e == Le || e == He || e == Ne || e == je;
      }
      const $e = qe;
      var We = St['__core-js_shared__'];
      const Ge = We;
      var Ke = (function () {
        var t = /[^.]+$/.exec((Ge && Ge.keys && Ge.keys.IE_PROTO) || '');
        return t ? 'Symbol(src)_1.' + t : '';
      })();
      function Ue(t) {
        return !!Ke && Ke in t;
      }
      const Ze = Ue;
      var Je = Function.prototype;
      var Ye = Je.toString;
      function Qe(t) {
        if (t != null) {
          try {
            return Ye.call(t);
          } catch (t) {}
          try {
            return t + '';
          } catch (t) {}
        }
        return '';
      }
      const Xe = Qe;
      var tn = /[\\^$.*+?()[\]{}|]/g;
      var en = /^\[object .+?Constructor\]$/;
      var nn = Function.prototype,
        on = Object.prototype;
      var rn = nn.toString;
      var sn = on.hasOwnProperty;
      var an = RegExp(
        '^' +
          rn
            .call(sn)
            .replace(tn, '\\$&')
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              '$1.*?',
            ) +
          '$',
      );
      function cn(t) {
        if (!ot(t) || Ze(t)) {
          return false;
        }
        var e = $e(t) ? an : en;
        return e.test(Xe(t));
      }
      const ln = cn;
      function dn(t, e) {
        return t == null ? undefined : t[e];
      }
      const hn = dn;
      function un(t, e) {
        var n = hn(t, e);
        return ln(n) ? n : undefined;
      }
      const fn = un;
      var pn = fn(St, 'Map');
      const gn = pn;
      var mn = fn(Object, 'create');
      const kn = mn;
      function bn() {
        this.__data__ = kn ? kn(null) : {};
        this.size = 0;
      }
      const wn = bn;
      function _n(t) {
        var e = this.has(t) && delete this.__data__[t];
        this.size -= e ? 1 : 0;
        return e;
      }
      const vn = _n;
      var An = '__lodash_hash_undefined__';
      var Cn = Object.prototype;
      var yn = Cn.hasOwnProperty;
      function xn(t) {
        var e = this.__data__;
        if (kn) {
          var n = e[t];
          return n === An ? undefined : n;
        }
        return yn.call(e, t) ? e[t] : undefined;
      }
      const En = xn;
      var Dn = Object.prototype;
      var Tn = Dn.hasOwnProperty;
      function Sn(t) {
        var e = this.__data__;
        return kn ? e[t] !== undefined : Tn.call(e, t);
      }
      const Pn = Sn;
      var Bn = '__lodash_hash_undefined__';
      function Rn(t, e) {
        var n = this.__data__;
        this.size += this.has(t) ? 0 : 1;
        n[t] = kn && e === undefined ? Bn : e;
        return this;
      }
      const On = Rn;
      function In(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      In.prototype.clear = wn;
      In.prototype['delete'] = vn;
      In.prototype.get = En;
      In.prototype.has = Pn;
      In.prototype.set = On;
      const Mn = In;
      function Vn() {
        this.size = 0;
        this.__data__ = {
          hash: new Mn(),
          map: new (gn || Pe)(),
          string: new Mn(),
        };
      }
      const zn = Vn;
      function Fn(t) {
        var e = typeof t;
        return e == 'string' || e == 'number' || e == 'symbol' || e == 'boolean'
          ? t !== '__proto__'
          : t === null;
      }
      const Nn = Fn;
      function Ln(t, e) {
        var n = t.__data__;
        return Nn(e) ? n[typeof e == 'string' ? 'string' : 'hash'] : n.map;
      }
      const Hn = Ln;
      function jn(t) {
        var e = Hn(this, t)['delete'](t);
        this.size -= e ? 1 : 0;
        return e;
      }
      const qn = jn;
      function $n(t) {
        return Hn(this, t).get(t);
      }
      const Wn = $n;
      function Gn(t) {
        return Hn(this, t).has(t);
      }
      const Kn = Gn;
      function Un(t, e) {
        var n = Hn(this, t),
          o = n.size;
        n.set(t, e);
        this.size += n.size == o ? 0 : 1;
        return this;
      }
      const Zn = Un;
      function Jn(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Jn.prototype.clear = zn;
      Jn.prototype['delete'] = qn;
      Jn.prototype.get = Wn;
      Jn.prototype.has = Kn;
      Jn.prototype.set = Zn;
      const Yn = Jn;
      var Qn = 200;
      function Xn(t, e) {
        var n = this.__data__;
        if (n instanceof Pe) {
          var o = n.__data__;
          if (!gn || o.length < Qn - 1) {
            o.push([t, e]);
            this.size = ++n.size;
            return this;
          }
          n = this.__data__ = new Yn(o);
        }
        n.set(t, e);
        this.size = n.size;
        return this;
      }
      const to = Xn;
      function eo(t) {
        var e = (this.__data__ = new Pe(t));
        this.size = e.size;
      }
      eo.prototype.clear = Re;
      eo.prototype['delete'] = Ie;
      eo.prototype.get = Ve;
      eo.prototype.has = Fe;
      eo.prototype.set = to;
      const no = eo;
      function oo(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t) === false) {
            break;
          }
        }
        return t;
      }
      const io = oo;
      var ro = (function () {
        try {
          var t = fn(Object, 'defineProperty');
          t({}, '', {});
          return t;
        } catch (t) {}
      })();
      const so = ro;
      function ao(t, e, n) {
        if (e == '__proto__' && so) {
          so(t, e, {
            configurable: true,
            enumerable: true,
            value: n,
            writable: true,
          });
        } else {
          t[e] = n;
        }
      }
      const co = ao;
      var lo = Object.prototype;
      var ho = lo.hasOwnProperty;
      function uo(t, e, n) {
        var o = t[e];
        if (!(ho.call(t, e) && me(o, n)) || (n === undefined && !(e in t))) {
          co(t, e, n);
        }
      }
      const fo = uo;
      function po(t, e, n, o) {
        var i = !n;
        n || (n = {});
        var r = -1,
          s = e.length;
        while (++r < s) {
          var a = e[r];
          var c = o ? o(n[a], t[a], a, n, t) : undefined;
          if (c === undefined) {
            c = t[a];
          }
          if (i) {
            co(n, a, c);
          } else {
            fo(n, a, c);
          }
        }
        return n;
      }
      const go = po;
      function mo(t, e) {
        var n = -1,
          o = Array(t);
        while (++n < t) {
          o[n] = e(n);
        }
        return o;
      }
      const ko = mo;
      var bo = '[object Arguments]';
      function wo(t) {
        return Jt(t) && Gt(t) == bo;
      }
      const _o = wo;
      var vo = Object.prototype;
      var Ao = vo.hasOwnProperty;
      var Co = vo.propertyIsEnumerable;
      var yo = _o(
        (function () {
          return arguments;
        })(),
      )
        ? _o
        : function (t) {
            return Jt(t) && Ao.call(t, 'callee') && !Co.call(t, 'callee');
          };
      const xo = yo;
      function Eo() {
        return false;
      }
      const Do = Eo;
      var To =
        typeof exports == 'object' && exports && !exports.nodeType && exports;
      var So =
        To && typeof module == 'object' && module && !module.nodeType && module;
      var Po = So && So.exports === To;
      var Bo = Po ? St.Buffer : undefined;
      var Ro = Bo ? Bo.isBuffer : undefined;
      var Oo = Ro || Do;
      const Io = Oo;
      var Mo = 9007199254740991;
      var Vo = /^(?:0|[1-9]\d*)$/;
      function zo(t, e) {
        var n = typeof t;
        e = e == null ? Mo : e;
        return (
          !!e &&
          (n == 'number' || (n != 'symbol' && Vo.test(t))) &&
          t > -1 &&
          t % 1 == 0 &&
          t < e
        );
      }
      const Fo = zo;
      var No = 9007199254740991;
      function Lo(t) {
        return typeof t == 'number' && t > -1 && t % 1 == 0 && t <= No;
      }
      const Ho = Lo;
      var jo = '[object Arguments]',
        qo = '[object Array]',
        $o = '[object Boolean]',
        Wo = '[object Date]',
        Go = '[object Error]',
        Ko = '[object Function]',
        Uo = '[object Map]',
        Zo = '[object Number]',
        Jo = '[object Object]',
        Yo = '[object RegExp]',
        Qo = '[object Set]',
        Xo = '[object String]',
        ti = '[object WeakMap]';
      var ei = '[object ArrayBuffer]',
        ni = '[object DataView]',
        oi = '[object Float32Array]',
        ii = '[object Float64Array]',
        ri = '[object Int8Array]',
        si = '[object Int16Array]',
        ai = '[object Int32Array]',
        ci = '[object Uint8Array]',
        li = '[object Uint8ClampedArray]',
        di = '[object Uint16Array]',
        hi = '[object Uint32Array]';
      var ui = {};
      ui[oi] =
        ui[ii] =
        ui[ri] =
        ui[si] =
        ui[ai] =
        ui[ci] =
        ui[li] =
        ui[di] =
        ui[hi] =
          true;
      ui[jo] =
        ui[qo] =
        ui[ei] =
        ui[$o] =
        ui[ni] =
        ui[Wo] =
        ui[Go] =
        ui[Ko] =
        ui[Uo] =
        ui[Zo] =
        ui[Jo] =
        ui[Yo] =
        ui[Qo] =
        ui[Xo] =
        ui[ti] =
          false;
      function fi(t) {
        return Jt(t) && Ho(t.length) && !!ui[Gt(t)];
      }
      const pi = fi;
      function gi(t) {
        return function (e) {
          return t(e);
        };
      }
      const mi = gi;
      var ki =
        typeof exports == 'object' && exports && !exports.nodeType && exports;
      var bi =
        ki && typeof module == 'object' && module && !module.nodeType && module;
      var wi = bi && bi.exports === ki;
      var _i = wi && Et.process;
      var vi = (function () {
        try {
          var t = bi && bi.require && bi.require('util').types;
          if (t) {
            return t;
          }
          return _i && _i.binding && _i.binding('util');
        } catch (t) {}
      })();
      const Ai = vi;
      var Ci = Ai && Ai.isTypedArray;
      var yi = Ci ? mi(Ci) : pi;
      const xi = yi;
      var Ei = Object.prototype;
      var Di = Ei.hasOwnProperty;
      function Ti(t, e) {
        var n = Ut(t),
          o = !n && xo(t),
          i = !n && !o && Io(t),
          r = !n && !o && !i && xi(t),
          s = n || o || i || r,
          a = s ? ko(t.length, String) : [],
          c = a.length;
        for (var l in t) {
          if (
            (e || Di.call(t, l)) &&
            !(
              s &&
              (l == 'length' ||
                (i && (l == 'offset' || l == 'parent')) ||
                (r &&
                  (l == 'buffer' || l == 'byteLength' || l == 'byteOffset')) ||
                Fo(l, c))
            )
          ) {
            a.push(l);
          }
        }
        return a;
      }
      const Si = Ti;
      var Pi = Object.prototype;
      function Bi(t) {
        var e = t && t.constructor,
          n = (typeof e == 'function' && e.prototype) || Pi;
        return t === n;
      }
      const Ri = Bi;
      var Oi = ne(Object.keys, Object);
      const Ii = Oi;
      var Mi = Object.prototype;
      var Vi = Mi.hasOwnProperty;
      function zi(t) {
        if (!Ri(t)) {
          return Ii(t);
        }
        var e = [];
        for (var n in Object(t)) {
          if (Vi.call(t, n) && n != 'constructor') {
            e.push(n);
          }
        }
        return e;
      }
      const Fi = zi;
      function Ni(t) {
        return t != null && Ho(t.length) && !$e(t);
      }
      const Li = Ni;
      function Hi(t) {
        return Li(t) ? Si(t) : Fi(t);
      }
      const ji = Hi;
      function qi(t, e) {
        return t && go(e, ji(e), t);
      }
      const $i = qi;
      function Wi(t) {
        var e = [];
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n);
          }
        }
        return e;
      }
      const Gi = Wi;
      var Ki = Object.prototype;
      var Ui = Ki.hasOwnProperty;
      function Zi(t) {
        if (!ot(t)) {
          return Gi(t);
        }
        var e = Ri(t),
          n = [];
        for (var o in t) {
          if (!(o == 'constructor' && (e || !Ui.call(t, o)))) {
            n.push(o);
          }
        }
        return n;
      }
      const Ji = Zi;
      function Yi(t) {
        return Li(t) ? Si(t, true) : Ji(t);
      }
      const Qi = Yi;
      function Xi(t, e) {
        return t && go(e, Qi(e), t);
      }
      const tr = Xi;
      var er =
        typeof exports == 'object' && exports && !exports.nodeType && exports;
      var nr =
        er && typeof module == 'object' && module && !module.nodeType && module;
      var or = nr && nr.exports === er;
      var ir = or ? St.Buffer : undefined,
        rr = ir ? ir.allocUnsafe : undefined;
      function sr(t, e) {
        if (e) {
          return t.slice();
        }
        var n = t.length,
          o = rr ? rr(n) : new t.constructor(n);
        t.copy(o);
        return o;
      }
      const ar = sr;
      function cr(t, e) {
        var n = -1,
          o = t.length;
        e || (e = Array(o));
        while (++n < o) {
          e[n] = t[n];
        }
        return e;
      }
      const lr = cr;
      function dr(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = 0,
          r = [];
        while (++n < o) {
          var s = t[n];
          if (e(s, n, t)) {
            r[i++] = s;
          }
        }
        return r;
      }
      const hr = dr;
      function ur() {
        return [];
      }
      const fr = ur;
      var pr = Object.prototype;
      var gr = pr.propertyIsEnumerable;
      var mr = Object.getOwnPropertySymbols;
      var kr = !mr
        ? fr
        : function (t) {
            if (t == null) {
              return [];
            }
            t = Object(t);
            return hr(mr(t), function (e) {
              return gr.call(t, e);
            });
          };
      const br = kr;
      function wr(t, e) {
        return go(t, br(t), e);
      }
      const _r = wr;
      function vr(t, e) {
        var n = -1,
          o = e.length,
          i = t.length;
        while (++n < o) {
          t[i + n] = e[n];
        }
        return t;
      }
      const Ar = vr;
      var Cr = Object.getOwnPropertySymbols;
      var yr = !Cr
        ? fr
        : function (t) {
            var e = [];
            while (t) {
              Ar(e, br(t));
              t = ie(t);
            }
            return e;
          };
      const xr = yr;
      function Er(t, e) {
        return go(t, xr(t), e);
      }
      const Dr = Er;
      function Tr(t, e, n) {
        var o = e(t);
        return Ut(t) ? o : Ar(o, n(t));
      }
      const Sr = Tr;
      function Pr(t) {
        return Sr(t, ji, br);
      }
      const Br = Pr;
      function Rr(t) {
        return Sr(t, Qi, xr);
      }
      const Or = Rr;
      var Ir = fn(St, 'DataView');
      const Mr = Ir;
      var Vr = fn(St, 'Promise');
      const zr = Vr;
      var Fr = fn(St, 'Set');
      const Nr = Fr;
      var Lr = fn(St, 'WeakMap');
      const Hr = Lr;
      var jr = '[object Map]',
        qr = '[object Object]',
        $r = '[object Promise]',
        Wr = '[object Set]',
        Gr = '[object WeakMap]';
      var Kr = '[object DataView]';
      var Ur = Xe(Mr),
        Zr = Xe(gn),
        Jr = Xe(zr),
        Yr = Xe(Nr),
        Qr = Xe(Hr);
      var Xr = Gt;
      if (
        (Mr && Xr(new Mr(new ArrayBuffer(1))) != Kr) ||
        (gn && Xr(new gn()) != jr) ||
        (zr && Xr(zr.resolve()) != $r) ||
        (Nr && Xr(new Nr()) != Wr) ||
        (Hr && Xr(new Hr()) != Gr)
      ) {
        Xr = function (t) {
          var e = Gt(t),
            n = e == qr ? t.constructor : undefined,
            o = n ? Xe(n) : '';
          if (o) {
            switch (o) {
              case Ur:
                return Kr;
              case Zr:
                return jr;
              case Jr:
                return $r;
              case Yr:
                return Wr;
              case Qr:
                return Gr;
            }
          }
          return e;
        };
      }
      const ts = Xr;
      var es = Object.prototype;
      var ns = es.hasOwnProperty;
      function os(t) {
        var e = t.length,
          n = new t.constructor(e);
        if (e && typeof t[0] == 'string' && ns.call(t, 'index')) {
          n.index = t.index;
          n.input = t.input;
        }
        return n;
      }
      const is = os;
      var rs = St.Uint8Array;
      const ss = rs;
      function as(t) {
        var e = new t.constructor(t.byteLength);
        new ss(e).set(new ss(t));
        return e;
      }
      const cs = as;
      function ls(t, e) {
        var n = e ? cs(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      }
      const ds = ls;
      var hs = /\w*$/;
      function us(t) {
        var e = new t.constructor(t.source, hs.exec(t));
        e.lastIndex = t.lastIndex;
        return e;
      }
      const fs = us;
      var ps = Bt ? Bt.prototype : undefined,
        gs = ps ? ps.valueOf : undefined;
      function ms(t) {
        return gs ? Object(gs.call(t)) : {};
      }
      const ks = ms;
      function bs(t, e) {
        var n = e ? cs(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length);
      }
      const ws = bs;
      var _s = '[object Boolean]',
        vs = '[object Date]',
        As = '[object Map]',
        Cs = '[object Number]',
        ys = '[object RegExp]',
        xs = '[object Set]',
        Es = '[object String]',
        Ds = '[object Symbol]';
      var Ts = '[object ArrayBuffer]',
        Ss = '[object DataView]',
        Ps = '[object Float32Array]',
        Bs = '[object Float64Array]',
        Rs = '[object Int8Array]',
        Os = '[object Int16Array]',
        Is = '[object Int32Array]',
        Ms = '[object Uint8Array]',
        Vs = '[object Uint8ClampedArray]',
        zs = '[object Uint16Array]',
        Fs = '[object Uint32Array]';
      function Ns(t, e, n) {
        var o = t.constructor;
        switch (e) {
          case Ts:
            return cs(t);
          case _s:
          case vs:
            return new o(+t);
          case Ss:
            return ds(t, n);
          case Ps:
          case Bs:
          case Rs:
          case Os:
          case Is:
          case Ms:
          case Vs:
          case zs:
          case Fs:
            return ws(t, n);
          case As:
            return new o();
          case Cs:
          case Es:
            return new o(t);
          case ys:
            return fs(t);
          case xs:
            return new o();
          case Ds:
            return ks(t);
        }
      }
      const Ls = Ns;
      var Hs = Object.create;
      var js = (function () {
        function t() {}
        return function (e) {
          if (!ot(e)) {
            return {};
          }
          if (Hs) {
            return Hs(e);
          }
          t.prototype = e;
          var n = new t();
          t.prototype = undefined;
          return n;
        };
      })();
      const qs = js;
      function $s(t) {
        return typeof t.constructor == 'function' && !Ri(t) ? qs(ie(t)) : {};
      }
      const Ws = $s;
      var Gs = '[object Map]';
      function Ks(t) {
        return Jt(t) && ts(t) == Gs;
      }
      const Us = Ks;
      var Zs = Ai && Ai.isMap;
      var Js = Zs ? mi(Zs) : Us;
      const Ys = Js;
      var Qs = '[object Set]';
      function Xs(t) {
        return Jt(t) && ts(t) == Qs;
      }
      const ta = Xs;
      var ea = Ai && Ai.isSet;
      var na = ea ? mi(ea) : ta;
      const oa = na;
      var ia = 1,
        ra = 2,
        sa = 4;
      var aa = '[object Arguments]',
        ca = '[object Array]',
        la = '[object Boolean]',
        da = '[object Date]',
        ha = '[object Error]',
        ua = '[object Function]',
        fa = '[object GeneratorFunction]',
        pa = '[object Map]',
        ga = '[object Number]',
        ma = '[object Object]',
        ka = '[object RegExp]',
        ba = '[object Set]',
        wa = '[object String]',
        _a = '[object Symbol]',
        va = '[object WeakMap]';
      var Aa = '[object ArrayBuffer]',
        Ca = '[object DataView]',
        ya = '[object Float32Array]',
        xa = '[object Float64Array]',
        Ea = '[object Int8Array]',
        Da = '[object Int16Array]',
        Ta = '[object Int32Array]',
        Sa = '[object Uint8Array]',
        Pa = '[object Uint8ClampedArray]',
        Ba = '[object Uint16Array]',
        Ra = '[object Uint32Array]';
      var Oa = {};
      Oa[aa] =
        Oa[ca] =
        Oa[Aa] =
        Oa[Ca] =
        Oa[la] =
        Oa[da] =
        Oa[ya] =
        Oa[xa] =
        Oa[Ea] =
        Oa[Da] =
        Oa[Ta] =
        Oa[pa] =
        Oa[ga] =
        Oa[ma] =
        Oa[ka] =
        Oa[ba] =
        Oa[wa] =
        Oa[_a] =
        Oa[Sa] =
        Oa[Pa] =
        Oa[Ba] =
        Oa[Ra] =
          true;
      Oa[ha] = Oa[ua] = Oa[va] = false;
      function Ia(t, e, n, o, i, r) {
        var s,
          a = e & ia,
          c = e & ra,
          l = e & sa;
        if (n) {
          s = i ? n(t, o, i, r) : n(t);
        }
        if (s !== undefined) {
          return s;
        }
        if (!ot(t)) {
          return t;
        }
        var d = Ut(t);
        if (d) {
          s = is(t);
          if (!a) {
            return lr(t, s);
          }
        } else {
          var h = ts(t),
            u = h == ua || h == fa;
          if (Io(t)) {
            return ar(t, a);
          }
          if (h == ma || h == aa || (u && !i)) {
            s = c || u ? {} : Ws(t);
            if (!a) {
              return c ? Dr(t, tr(s, t)) : _r(t, $i(s, t));
            }
          } else {
            if (!Oa[h]) {
              return i ? t : {};
            }
            s = Ls(t, h, a);
          }
        }
        r || (r = new no());
        var f = r.get(t);
        if (f) {
          return f;
        }
        r.set(t, s);
        if (oa(t)) {
          t.forEach(function (o) {
            s.add(Ia(o, e, n, o, t, r));
          });
        } else if (Ys(t)) {
          t.forEach(function (o, i) {
            s.set(i, Ia(o, e, n, i, t, r));
          });
        }
        var p = l ? (c ? Or : Br) : c ? Qi : ji;
        var g = d ? undefined : p(t);
        io(g || t, function (o, i) {
          if (g) {
            i = o;
            o = t[i];
          }
          fo(s, i, Ia(o, e, n, i, t, r));
        });
        return s;
      }
      const Ma = Ia;
      var Va = 1,
        za = 4;
      function Fa(t, e) {
        e = typeof e == 'function' ? e : undefined;
        return Ma(t, Va | za, e);
      }
      const Na = Fa;
      function La(t) {
        return Jt(t) && t.nodeType === 1 && !ue(t);
      }
      const Ha = La;
      class ja {
        constructor(t, e) {
          this._config = {};
          if (e) {
            this.define(qa(e));
          }
          if (t) {
            this._setObjectToTarget(this._config, t);
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e);
        }
        define(t, e) {
          const n = true;
          this._setToTarget(this._config, t, e, n);
        }
        get(t) {
          return this._getFromSource(this._config, t);
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t;
          }
        }
        _setToTarget(t, e, n, o = false) {
          if (ue(e)) {
            this._setObjectToTarget(t, e, o);
            return;
          }
          const i = e.split('.');
          e = i.pop();
          for (const e of i) {
            if (!ue(t[e])) {
              t[e] = {};
            }
            t = t[e];
          }
          if (ue(n)) {
            if (!ue(t[e])) {
              t[e] = {};
            }
            t = t[e];
            this._setObjectToTarget(t, n, o);
            return;
          }
          if (o && typeof t[e] != 'undefined') {
            return;
          }
          t[e] = n;
        }
        _getFromSource(t, e) {
          const n = e.split('.');
          e = n.pop();
          for (const e of n) {
            if (!ue(t[e])) {
              t = null;
              break;
            }
            t = t[e];
          }
          return t ? qa(t[e]) : undefined;
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach(o => {
            this._setToTarget(t, o, e[o], n);
          });
        }
      }
      function qa(t) {
        return Na(t, $a);
      }
      function $a(t) {
        return Ha(t) || typeof t === 'function' ? t : undefined;
      }
      function Wa(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document;
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node;
          }
        }
        return false;
      }
      function Ga(t) {
        const e = Object.prototype.toString.apply(t);
        if (e == '[object Window]') {
          return true;
        }
        if (e == '[object global]') {
          return true;
        }
        return false;
      }
      const Ka = Ua($());
      function Ua(t) {
        if (!t) {
          return Ka;
        }
        class e extends t {
          listenTo(t, e, n, o = {}) {
            if (Wa(t) || Ga(t)) {
              const i = { capture: !!o.useCapture, passive: !!o.usePassive };
              const r = this._getProxyEmitter(t, i) || new Za(t, i);
              this.listenTo(r, e, n, o);
            } else {
              super.listenTo(t, e, n, o);
            }
          }
          stopListening(t, e, n) {
            if (Wa(t) || Ga(t)) {
              const o = this._getAllProxyEmitters(t);
              for (const t of o) {
                this.stopListening(t, e, n);
              }
            } else {
              super.stopListening(t, e, n);
            }
          }
          _getProxyEmitter(t, e) {
            return W(this, Ya(t, e));
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map(e => this._getProxyEmitter(t, e))
              .filter(t => !!t);
          }
        }
        return e;
      }
      [
        '_getProxyEmitter',
        '_getAllProxyEmitters',
        'on',
        'once',
        'off',
        'listenTo',
        'stopListening',
        'fire',
        'delegate',
        'stopDelegating',
        '_addEventListener',
        '_removeEventListener',
      ].forEach(t => {
        Ua[t] = Ka.prototype[t];
      });
      class Za extends $() {
        constructor(t, e) {
          super();
          G(this, Ya(t, e));
          this._domNode = t;
          this._options = e;
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return;
          }
          const e = this._createDomListener(t);
          this._domNode.addEventListener(t, e, this._options);
          if (!this._domListeners) {
            this._domListeners = {};
          }
          this._domListeners[t] = e;
        }
        detach(t) {
          let e;
          if (
            this._domListeners[t] &&
            (!(e = this._events[t]) || !e.callbacks.length)
          ) {
            this._domListeners[t].removeListener();
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t);
          $().prototype._addEventListener.call(this, t, e, n);
        }
        _removeEventListener(t, e) {
          $().prototype._removeEventListener.call(this, t, e);
          this.detach(t);
        }
        _createDomListener(t) {
          const e = e => {
            this.fire(t, e);
          };
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options);
            delete this._domListeners[t];
          };
          return e;
        }
      }
      function Ja(t) {
        return t['data-ck-expando'] || (t['data-ck-expando'] = E());
      }
      function Ya(t, e) {
        let n = Ja(t);
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += '-' + t;
          }
        }
        return n;
      }
      let Qa;
      try {
        Qa = { window, document };
      } catch (t) {
        Qa = { window: {}, document: {} };
      }
      const Xa = Qa;
      function tc(t) {
        let e = t.parentElement;
        if (!e) {
          return null;
        }
        while (e.tagName != 'BODY') {
          const t =
            e.style.overflowY || global.window.getComputedStyle(e).overflowY;
          if (t === 'auto' || t === 'scroll') {
            break;
          }
          e = e.parentElement;
          if (!e) {
            return null;
          }
        }
        return e;
      }
      function ec(t) {
        const e = [];
        let n = t;
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n);
          n = n.parentNode;
        }
        return e;
      }
      function nc(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value;
        }
        return t.innerHTML;
      }
      function oc(t) {
        return Object.prototype.toString.call(t) == '[object Text]';
      }
      function ic(t) {
        return Object.prototype.toString.apply(t) == '[object Range]';
      }
      function rc(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t);
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        };
      }
      function sc(t) {
        if (!t || !t.parentNode) {
          return null;
        }
        if (t.offsetParent === Xa.document.body) {
          return null;
        }
        return t.offsetParent;
      }
      const ac = ['top', 'right', 'bottom', 'left', 'width', 'height'];
      class cc {
        constructor(t) {
          const e = ic(t);
          Object.defineProperty(this, '_source', {
            value: t._source || t,
            writable: true,
            enumerable: false,
          });
          if (hc(t) || e) {
            if (e) {
              const e = cc.getDomRangeRects(t);
              lc(this, cc.getBoundingRect(e));
            } else {
              lc(this, t.getBoundingClientRect());
            }
          } else if (Ga(t)) {
            const { innerWidth: e, innerHeight: n } = t;
            lc(this, {
              top: 0,
              right: e,
              bottom: n,
              left: 0,
              width: e,
              height: n,
            });
          } else {
            lc(this, t);
          }
        }
        clone() {
          return new cc(this);
        }
        moveTo(t, e) {
          this.top = e;
          this.right = t + this.width;
          this.bottom = e + this.height;
          this.left = t;
          return this;
        }
        moveBy(t, e) {
          this.top += e;
          this.right += t;
          this.left += t;
          this.bottom += e;
          return this;
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          };
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          if (e.width < 0 || e.height < 0) {
            return null;
          } else {
            const t = new cc(e);
            t._source = this._source;
            return t;
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t);
          if (e) {
            return e.getArea();
          } else {
            return 0;
          }
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t = this._source;
          let e = this.clone();
          if (dc(t)) {
            return e;
          }
          let n = t;
          let o = t.parentNode || t.commonAncestorContainer;
          let i;
          while (o && !dc(o)) {
            const t = fc(o) === 'visible';
            if (n instanceof HTMLElement && uc(n) === 'absolute') {
              i = n;
            }
            const r = uc(o);
            if (t || (i && ((r === 'relative' && t) || r !== 'relative'))) {
              n = o;
              o = o.parentNode;
              continue;
            }
            const s = new cc(o);
            const a = e.getIntersection(s);
            if (a) {
              if (a.getArea() < e.getArea()) {
                e = a;
              }
            } else {
              return null;
            }
            n = o;
            o = o.parentNode;
          }
          return e;
        }
        isEqual(t) {
          for (const e of ac) {
            if (this[e] !== t[e]) {
              return false;
            }
          }
          return true;
        }
        contains(t) {
          const e = this.getIntersection(t);
          return !!(e && e.isEqual(t));
        }
        toAbsoluteRect() {
          const { scrollX: t, scrollY: e } = Xa.window;
          const n = this.clone().moveBy(t, e);
          if (hc(n._source)) {
            const t = sc(n._source);
            if (t) {
              pc(n, t);
            }
          }
          return n;
        }
        excludeScrollbarsAndBorders() {
          const t = this._source;
          let e, n, o;
          if (Ga(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth;
            n = t.innerHeight - t.document.documentElement.clientHeight;
            o = t.getComputedStyle(t.document.documentElement).direction;
          } else {
            const i = rc(t);
            e = t.offsetWidth - t.clientWidth - i.left - i.right;
            n = t.offsetHeight - t.clientHeight - i.top - i.bottom;
            o = t.ownerDocument.defaultView.getComputedStyle(t).direction;
            this.left += i.left;
            this.top += i.top;
            this.right -= i.right;
            this.bottom -= i.bottom;
            this.width = this.right - this.left;
            this.height = this.bottom - this.top;
          }
          this.width -= e;
          if (o === 'ltr') {
            this.right -= e;
          } else {
            this.left += e;
          }
          this.height -= n;
          this.bottom -= n;
          return this;
        }
        static getDomRangeRects(t) {
          const e = [];
          const n = Array.from(t.getClientRects());
          if (n.length) {
            for (const t of n) {
              e.push(new cc(t));
            }
          } else {
            let n = t.startContainer;
            if (oc(n)) {
              n = n.parentNode;
            }
            const o = new cc(n.getBoundingClientRect());
            o.right = o.left;
            o.width = 0;
            e.push(o);
          }
          return e;
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          };
          let n = 0;
          for (const o of t) {
            n++;
            e.left = Math.min(e.left, o.left);
            e.top = Math.min(e.top, o.top);
            e.right = Math.max(e.right, o.right);
            e.bottom = Math.max(e.bottom, o.bottom);
          }
          if (n == 0) {
            return null;
          }
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          return new cc(e);
        }
      }
      function lc(t, e) {
        for (const n of ac) {
          t[n] = e[n];
        }
      }
      function dc(t) {
        if (!hc(t)) {
          return false;
        }
        return t === t.ownerDocument.body;
      }
      function hc(t) {
        return (
          t !== null &&
          typeof t === 'object' &&
          t.nodeType === 1 &&
          typeof t.getBoundingClientRect === 'function'
        );
      }
      function uc(t) {
        return t instanceof HTMLElement
          ? t.ownerDocument.defaultView.getComputedStyle(t).position
          : 'static';
      }
      function fc(t) {
        return t instanceof HTMLElement
          ? t.ownerDocument.defaultView.getComputedStyle(t).overflow
          : 'visible';
      }
      function pc(t, e) {
        const n = new cc(e);
        const o = rc(e);
        let i = 0;
        let r = 0;
        i -= n.left;
        r -= n.top;
        i += e.scrollLeft;
        r += e.scrollTop;
        i -= o.left;
        r -= o.top;
        t.moveBy(i, r);
      }
      class gc {
        constructor(t, e) {
          if (!gc._observerInstance) {
            gc._createObserver();
          }
          this._element = t;
          this._callback = e;
          gc._addElementCallback(t, e);
          gc._observerInstance.observe(t);
        }
        get element() {
          return this._element;
        }
        destroy() {
          gc._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t, e) {
          if (!gc._elementCallbacks) {
            gc._elementCallbacks = new Map();
          }
          let n = gc._elementCallbacks.get(t);
          if (!n) {
            n = new Set();
            gc._elementCallbacks.set(t, n);
          }
          n.add(e);
        }
        static _deleteElementCallback(t, e) {
          const n = gc._getElementCallbacks(t);
          if (n) {
            n.delete(e);
            if (!n.size) {
              gc._elementCallbacks.delete(t);
              gc._observerInstance.unobserve(t);
            }
          }
          if (gc._elementCallbacks && !gc._elementCallbacks.size) {
            gc._observerInstance = null;
            gc._elementCallbacks = null;
          }
        }
        static _getElementCallbacks(t) {
          if (!gc._elementCallbacks) {
            return null;
          }
          return gc._elementCallbacks.get(t);
        }
        static _createObserver() {
          gc._observerInstance = new Xa.window.ResizeObserver(t => {
            for (const e of t) {
              const t = gc._getElementCallbacks(e.target);
              if (t) {
                for (const n of t) {
                  n(e);
                }
              }
            }
          });
        }
      }
      gc._observerInstance = null;
      gc._elementCallbacks = null;
      function mc(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e;
        }
        t.innerHTML = e;
      }
      function kc(t) {
        return e => e + t;
      }
      function bc(t) {
        let e = 0;
        while (t.previousSibling) {
          t = t.previousSibling;
          e++;
        }
        return e;
      }
      function wc(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null);
      }
      function _c(t) {
        return t && t.nodeType === Node.COMMENT_NODE;
      }
      function vc(t) {
        try {
          Xa.document.createAttribute(t);
        } catch (t) {
          return false;
        }
        return true;
      }
      function Ac(t) {
        return !!(t && t.getClientRects && t.getClientRects().length);
      }
      function Cc({
        element: t,
        target: e,
        positions: n,
        limiter: o,
        fitInViewport: i,
        viewportOffsetConfig: r,
      }) {
        if ($e(e)) {
          e = e();
        }
        if ($e(o)) {
          o = o();
        }
        const s = sc(t);
        const a = xc(r);
        const c = new cc(t);
        const l = yc(e, a);
        let d;
        if (!l || !a.getIntersection(l)) {
          return null;
        }
        const h = {
          targetRect: l,
          elementRect: c,
          positionedElementAncestor: s,
          viewportRect: a,
        };
        if (!o && !i) {
          d = new Dc(n[0], h);
        } else {
          if (o) {
            const t = yc(o, a);
            if (t) {
              h.limiterRect = t;
            }
          }
          d = Ec(n, h);
        }
        return d;
      }
      function yc(t, e) {
        const n = new cc(t).getVisible();
        if (!n) {
          return null;
        }
        return n.getIntersection(e);
      }
      function xc(t) {
        t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t);
        const e = new cc(Xa.window);
        e.top += t.top;
        e.height -= t.top;
        e.bottom -= t.bottom;
        e.height -= t.bottom;
        return e;
      }
      function Ec(t, e) {
        const { elementRect: n } = e;
        const o = n.getArea();
        const i = t.map(t => new Dc(t, e)).filter(t => !!t.name);
        let r = 0;
        let s = null;
        for (const t of i) {
          const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t;
          if (e === o) {
            return t;
          }
          const i = n ** 2 + e ** 2;
          if (i > r) {
            r = i;
            s = t;
          }
        }
        return s;
      }
      class Dc {
        constructor(t, e) {
          const n = t(
            e.targetRect,
            e.elementRect,
            e.viewportRect,
            e.limiterRect,
          );
          if (!n) {
            return;
          }
          const { left: o, top: i, name: r, config: s } = n;
          this.name = r;
          this.config = s;
          this._positioningFunctionCoordinates = { left: o, top: i };
          this._options = e;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect;
          if (t) {
            return t.getIntersectionArea(this._rect);
          }
          return 0;
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect;
          return t.getIntersectionArea(this._rect);
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect;
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(
              this._positioningFunctionCoordinates.left,
              this._positioningFunctionCoordinates.top,
            );
          return this._cachedRect;
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect;
          }
          this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
          return this._cachedAbsoluteRect;
        }
      }
      function Tc(t) {
        const e = t.parentNode;
        if (e) {
          e.removeChild(t);
        }
      }
      function Sc({
        target: t,
        viewportOffset: e = 0,
        ancestorOffset: n = 0,
        alignToTop: o,
        forceScroll: i,
      }) {
        const r = zc(t);
        let s = r;
        let a = null;
        e = Lc(e);
        while (s) {
          let c;
          if (s == r) {
            c = Fc(t);
          } else {
            c = Fc(a);
          }
          Rc({
            parent: c,
            getRect: () => Nc(t, s),
            alignToTop: o,
            ancestorOffset: n,
            forceScroll: i,
          });
          const l = Nc(t, s);
          Bc({
            window: s,
            rect: l,
            viewportOffset: e,
            alignToTop: o,
            forceScroll: i,
          });
          if (s.parent != s) {
            a = s.frameElement;
            s = s.parent;
            if (!a) {
              return;
            }
          } else {
            s = null;
          }
        }
      }
      function Pc(t, e, n) {
        const o = Fc(t);
        Rc({
          parent: o,
          getRect: () => new Rect(t),
          ancestorOffset: e,
          limiterElement: n,
        });
      }
      function Bc({
        window: t,
        rect: e,
        alignToTop: n,
        forceScroll: o,
        viewportOffset: i,
      }) {
        const r = e.clone().moveBy(0, i.bottom);
        const s = e.clone().moveBy(0, -i.top);
        const a = new cc(t).excludeScrollbarsAndBorders();
        const c = [s, r];
        const l = n && o;
        const d = c.every(t => a.contains(t));
        let { scrollX: h, scrollY: u } = t;
        const f = h;
        const p = u;
        if (l) {
          u -= a.top - e.top + i.top;
        } else if (!d) {
          if (Ic(s, a)) {
            u -= a.top - e.top + i.top;
          } else if (Oc(r, a)) {
            if (n) {
              u += e.top - a.top - i.top;
            } else {
              u += e.bottom - a.bottom + i.bottom;
            }
          }
        }
        if (!d) {
          if (Mc(e, a)) {
            h -= a.left - e.left + i.left;
          } else if (Vc(e, a)) {
            h += e.right - a.right + i.right;
          }
        }
        if (h != f || u !== p) {
          t.scrollTo(h, u);
        }
      }
      function Rc({
        parent: t,
        getRect: e,
        alignToTop: n,
        forceScroll: o,
        ancestorOffset: i = 0,
        limiterElement: r,
      }) {
        const s = zc(t);
        const a = n && o;
        let c, l, d;
        const h = r || s.document.body;
        while (t != h) {
          l = e();
          c = new cc(t).excludeScrollbarsAndBorders();
          d = c.contains(l);
          if (a) {
            t.scrollTop -= c.top - l.top + i;
          } else if (!d) {
            if (Ic(l, c)) {
              t.scrollTop -= c.top - l.top + i;
            } else if (Oc(l, c)) {
              if (n) {
                t.scrollTop += l.top - c.top - i;
              } else {
                t.scrollTop += l.bottom - c.bottom + i;
              }
            }
          }
          if (!d) {
            if (Mc(l, c)) {
              t.scrollLeft -= c.left - l.left + i;
            } else if (Vc(l, c)) {
              t.scrollLeft += l.right - c.right + i;
            }
          }
          t = t.parentNode;
        }
      }
      function Oc(t, e) {
        return t.bottom > e.bottom;
      }
      function Ic(t, e) {
        return t.top < e.top;
      }
      function Mc(t, e) {
        return t.left < e.left;
      }
      function Vc(t, e) {
        return t.right > e.right;
      }
      function zc(t) {
        if (ic(t)) {
          return t.startContainer.ownerDocument.defaultView;
        } else {
          return t.ownerDocument.defaultView;
        }
      }
      function Fc(t) {
        if (ic(t)) {
          let e = t.commonAncestorContainer;
          if (oc(e)) {
            e = e.parentNode;
          }
          return e;
        } else {
          return t.parentNode;
        }
      }
      function Nc(t, e) {
        const n = zc(t);
        const o = new cc(t);
        if (n === e) {
          return o;
        } else {
          let t = n;
          while (t != e) {
            const e = t.frameElement;
            const n = new cc(e).excludeScrollbarsAndBorders();
            o.moveBy(n.left, n.top);
            t = t.parent;
          }
        }
        return o;
      }
      function Lc(t) {
        if (typeof t === 'number') {
          return { top: t, bottom: t, left: t, right: t };
        }
        return t;
      }
      const Hc = { ctrl: '', cmd: '', alt: '', shift: '' };
      const jc = { ctrl: 'Ctrl+', alt: 'Alt+', shift: 'Shift+' };
      const qc = Qc();
      const $c = Object.fromEntries(
        Object.entries(qc).map(([t, e]) => [
          e,
          t.charAt(0).toUpperCase() + t.slice(1),
        ]),
      );
      function Wc(t) {
        let e;
        if (typeof t == 'string') {
          e = qc[t.toLowerCase()];
          if (!e) {
            throw new B('keyboard-unknown-key', null, { key: t });
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? qc.alt : 0) +
            (t.ctrlKey ? qc.ctrl : 0) +
            (t.shiftKey ? qc.shift : 0) +
            (t.metaKey ? qc.cmd : 0);
        }
        return e;
      }
      function Gc(t) {
        if (typeof t == 'string') {
          t = Xc(t);
        }
        return t
          .map(t => (typeof t == 'string' ? Jc(t) : t))
          .reduce((t, e) => e + t, 0);
      }
      function Kc(t) {
        let e = Gc(t);
        const n = Object.entries(s.isMac || s.isiOS ? Hc : jc);
        const o = n.reduce((t, [n, o]) => {
          if ((e & qc[n]) != 0) {
            e &= ~qc[n];
            t += o;
          }
          return t;
        }, '');
        return o + (e ? $c[e] : '');
      }
      function Uc(t) {
        return (
          t == qc.arrowright ||
          t == qc.arrowleft ||
          t == qc.arrowup ||
          t == qc.arrowdown
        );
      }
      function Zc(t, e) {
        const n = e === 'ltr';
        switch (t) {
          case qc.arrowleft:
            return n ? 'left' : 'right';
          case qc.arrowright:
            return n ? 'right' : 'left';
          case qc.arrowup:
            return 'up';
          case qc.arrowdown:
            return 'down';
        }
      }
      function Jc(t) {
        if (t.endsWith('!')) {
          return Wc(t.slice(0, -1));
        }
        const e = Wc(t);
        return (s.isMac || s.isiOS) && e == qc.ctrl ? qc.cmd : e;
      }
      function Yc(t, e) {
        const n = Zc(t, e);
        return n === 'down' || n === 'right';
      }
      function Qc() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e;
        }
        for (let e = 112; e <= 123; e++) {
          t['f' + (e - 111)] = e;
        }
        for (const e of "`-=[];',./\\") {
          t[e] = e.charCodeAt(0);
        }
        return t;
      }
      function Xc(t) {
        return t.split('+').map(t => t.trim());
      }
      function tl(t) {
        return Array.isArray(t) ? t : [t];
      }
      if (!Xa.window.CKEDITOR_TRANSLATIONS) {
        Xa.window.CKEDITOR_TRANSLATIONS = {};
      }
      function el(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {};
        }
        const o = global.window.CKEDITOR_TRANSLATIONS[t];
        o.dictionary = o.dictionary || {};
        o.getPluralForm = n || o.getPluralForm;
        Object.assign(o.dictionary, e);
      }
      function nl(t, e, n = 1) {
        if (typeof n !== 'number') {
          throw new B('translation-service-quantity-not-a-number', null, {
            quantity: n,
          });
        }
        const o = rl();
        if (o === 1) {
          t = Object.keys(Xa.window.CKEDITOR_TRANSLATIONS)[0];
        }
        const i = e.id || e.string;
        if (o === 0 || !il(t, i)) {
          if (n !== 1) {
            return e.plural;
          }
          return e.string;
        }
        const r = Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary;
        const s =
          Xa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
          (t => (t === 1 ? 0 : 1));
        const a = r[i];
        if (typeof a === 'string') {
          return a;
        }
        const c = Number(s(n));
        return a[c];
      }
      function ol() {
        global.window.CKEDITOR_TRANSLATIONS = {};
      }
      function il(t, e) {
        return (
          !!Xa.window.CKEDITOR_TRANSLATIONS[t] &&
          !!Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        );
      }
      function rl() {
        return Object.keys(Xa.window.CKEDITOR_TRANSLATIONS).length;
      }
      const sl = [
        'ar',
        'ara',
        'fa',
        'per',
        'fas',
        'he',
        'heb',
        'ku',
        'kur',
        'ug',
        'uig',
      ];
      function al(t) {
        return sl.includes(t) ? 'rtl' : 'ltr';
      }
      class cl {
        constructor({ uiLanguage: t = 'en', contentLanguage: e } = {}) {
          this.uiLanguage = t;
          this.contentLanguage = e || this.uiLanguage;
          this.uiLanguageDirection = al(this.uiLanguage);
          this.contentLanguageDirection = al(this.contentLanguage);
          this.t = (t, e) => this._t(t, e);
        }
        get language() {
          console.warn(
            'locale-deprecated-language-property: ' +
              'The Locale#language property has been deprecated and will be removed in the near future. ' +
              'Please use #uiLanguage and #contentLanguage properties instead.',
          );
          return this.uiLanguage;
        }
        _t(t, e = []) {
          e = tl(e);
          if (typeof t === 'string') {
            t = { string: t };
          }
          const n = !!t.plural;
          const o = n ? e[0] : 1;
          const i = nl(this.uiLanguage, t, o);
          return ll(i, e);
        }
      }
      function ll(t, e) {
        return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
      }
      class dl extends $() {
        constructor(t = {}, e = {}) {
          super();
          const n = yt(t);
          if (!n) {
            e = t;
          }
          this._items = [];
          this._itemMap = new Map();
          this._idProperty = e.idProperty || 'id';
          this._bindToExternalToInternalMap = new WeakMap();
          this._bindToInternalToExternalMap = new WeakMap();
          this._skippedIndexesFromExternal = [];
          if (n) {
            for (const e of t) {
              this._items.push(e);
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
          }
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t, e) {
          return this.addMany([t], e);
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length;
          } else if (e > this._items.length || e < 0) {
            throw new B('collection-add-item-invalid-index', this);
          }
          let n = 0;
          for (const o of t) {
            const t = this._getItemIdBeforeAdding(o);
            const i = e + n;
            this._items.splice(i, 0, o);
            this._itemMap.set(t, o);
            this.fire('add', o, i);
            n++;
          }
          this.fire('change', { added: t, removed: [], index: e });
          return this;
        }
        get(t) {
          let e;
          if (typeof t == 'string') {
            e = this._itemMap.get(t);
          } else if (typeof t == 'number') {
            e = this._items[t];
          } else {
            throw new B('collection-get-invalid-arg', this);
          }
          return e || null;
        }
        has(t) {
          if (typeof t == 'string') {
            return this._itemMap.has(t);
          } else {
            const e = this._idProperty;
            const n = t[e];
            return n && this._itemMap.has(n);
          }
        }
        getIndex(t) {
          let e;
          if (typeof t == 'string') {
            e = this._itemMap.get(t);
          } else {
            e = t;
          }
          return e ? this._items.indexOf(e) : -1;
        }
        remove(t) {
          const [e, n] = this._remove(t);
          this.fire('change', { added: [], removed: [e], index: n });
          return e;
        }
        map(t, e) {
          return this._items.map(t, e);
        }
        forEach(t, e) {
          this._items.forEach(t, e);
        }
        find(t, e) {
          return this._items.find(t, e);
        }
        filter(t, e) {
          return this._items.filter(t, e);
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection);
            this._bindToCollection = null;
          }
          const t = Array.from(this._items);
          while (this.length) {
            this._remove(0);
          }
          this.fire('change', { added: [], removed: t, index: 0 });
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new B('collection-bind-to-rebind', this);
          }
          this._bindToCollection = t;
          return {
            as: t => {
              this._setUpBindToBinding(e => new t(e));
            },
            using: t => {
              if (typeof t == 'function') {
                this._setUpBindToBinding(t);
              } else {
                this._setUpBindToBinding(e => e[t]);
              }
            },
          };
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection;
          const n = (n, o, i) => {
            const r = e._bindToCollection == this;
            const s = e._bindToInternalToExternalMap.get(o);
            if (r && s) {
              this._bindToExternalToInternalMap.set(o, s);
              this._bindToInternalToExternalMap.set(s, o);
            } else {
              const n = t(o);
              if (!n) {
                this._skippedIndexesFromExternal.push(i);
                return;
              }
              let r = i;
              for (const t of this._skippedIndexesFromExternal) {
                if (i > t) {
                  r--;
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++;
                }
              }
              this._bindToExternalToInternalMap.set(o, n);
              this._bindToInternalToExternalMap.set(n, o);
              this.add(n, r);
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++;
                }
              }
            }
          };
          for (const t of e) {
            n(null, t, e.getIndex(t));
          }
          this.listenTo(e, 'add', n);
          this.listenTo(e, 'remove', (t, e, n) => {
            const o = this._bindToExternalToInternalMap.get(e);
            if (o) {
              this.remove(o);
            }
            this._skippedIndexesFromExternal =
              this._skippedIndexesFromExternal.reduce((t, e) => {
                if (n < e) {
                  t.push(e - 1);
                }
                if (n > e) {
                  t.push(e);
                }
                return t;
              }, []);
          });
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty;
          let n;
          if (e in t) {
            n = t[e];
            if (typeof n != 'string') {
              throw new B('collection-add-invalid-id', this);
            }
            if (this.get(n)) {
              throw new B('collection-add-item-already-exists', this);
            }
          } else {
            t[e] = n = E();
          }
          return n;
        }
        _remove(t) {
          let e, n, o;
          let i = false;
          const r = this._idProperty;
          if (typeof t == 'string') {
            n = t;
            o = this._itemMap.get(n);
            i = !o;
            if (o) {
              e = this._items.indexOf(o);
            }
          } else if (typeof t == 'number') {
            e = t;
            o = this._items[e];
            i = !o;
            if (o) {
              n = o[r];
            }
          } else {
            o = t;
            n = o[r];
            e = this._items.indexOf(o);
            i = e == -1 || !this._itemMap.get(n);
          }
          if (i) {
            throw new B('collection-remove-404', this);
          }
          this._items.splice(e, 1);
          this._itemMap.delete(n);
          const s = this._bindToInternalToExternalMap.get(o);
          this._bindToInternalToExternalMap.delete(o);
          this._bindToExternalToInternalMap.delete(s);
          this.fire('remove', o, e);
          return [o, e];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function hl(t) {
        const e = t.next();
        if (e.done) {
          return null;
        }
        return e.value;
      }
      class ul extends Ua(dt()) {
        constructor() {
          super();
          this._elements = new Set();
          this._nextEventLoopTimeout = null;
          this.set('isFocused', false);
          this.set('focusedElement', null);
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new B('focustracker-add-element-already-exist', this);
          }
          this.listenTo(t, 'focus', () => this._focus(t), { useCapture: true });
          this.listenTo(t, 'blur', () => this._blur(), { useCapture: true });
          this._elements.add(t);
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur();
          }
          if (this._elements.has(t)) {
            this.stopListening(t);
            this._elements.delete(t);
          }
        }
        destroy() {
          this.stopListening();
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout);
          this.focusedElement = t;
          this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout);
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null;
            this.isFocused = false;
          }, 0);
        }
      }
      class fl {
        constructor() {
          this._listener = new (Ua())();
        }
        listenTo(t) {
          this._listener.listenTo(t, 'keydown', (t, e) => {
            this._listener.fire('_keydown:' + Wc(e), e);
          });
        }
        set(t, e, n = {}) {
          const o = Gc(t);
          const i = n.priority;
          this._listener.listenTo(
            this._listener,
            '_keydown:' + o,
            (t, n) => {
              e(n, () => {
                n.preventDefault();
                n.stopPropagation();
                t.stop();
              });
              t.return = true;
            },
            { priority: i },
          );
        }
        press(t) {
          return !!this._listener.fire('_keydown:' + Wc(t), t);
        }
        stopListening(t) {
          this._listener.stopListening(t);
        }
        destroy() {
          this.stopListening();
        }
      }
      function pl(t) {
        const e = new Map();
        for (const n in t) {
          e.set(n, t[n]);
        }
        return e;
      }
      function gl(t) {
        if (yt(t)) {
          return new Map(t);
        } else {
          return pl(t);
        }
      }
      const ml = 1e4;
      function kl(t, e, n, o) {
        if (Math.max(e.length, t.length) > ml) {
          return t
            .slice(0, n)
            .concat(e)
            .concat(t.slice(n + o, t.length));
        } else {
          const i = Array.from(t);
          i.splice(n, o, ...e);
          return i;
        }
      }
      function bl(t, e) {
        let n;
        function o(...i) {
          o.cancel();
          n = setTimeout(() => t(...i), e);
        }
        o.cancel = () => {
          clearTimeout(n);
        };
        return o;
      }
      function wl(t) {
        function e(t) {
          if (t.length >= 40 && t.length <= 255) {
            return 'VALID';
          } else {
            return 'INVALID';
          }
        }
        if (!t) {
          return 'INVALID';
        }
        let n = '';
        try {
          n = atob(t);
        } catch (t) {
          return 'INVALID';
        }
        const o = n.split('-');
        const i = o[0];
        const r = o[1];
        if (!r) {
          return e(t);
        }
        try {
          atob(r);
        } catch (n) {
          try {
            atob(i);
            if (!atob(i).length) {
              return e(t);
            }
          } catch (n) {
            return e(t);
          }
        }
        if (i.length < 40 || i.length > 255) {
          return 'INVALID';
        }
        let s = '';
        try {
          atob(i);
          s = atob(r);
        } catch (t) {
          return 'INVALID';
        }
        if (s.length !== 8) {
          return 'INVALID';
        }
        const a = Number(s.substring(0, 4));
        const c = Number(s.substring(4, 6)) - 1;
        const l = Number(s.substring(6, 8));
        const d = new Date(a, c, l);
        if (d < N || isNaN(Number(d))) {
          return 'INVALID';
        }
        return 'VALID';
      }
      function _l(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
            t,
          )
        );
      }
      function vl(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t);
      }
      function Al(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t);
      }
      function Cl(t, e) {
        return vl(t.charAt(e - 1)) && Al(t.charAt(e));
      }
      function yl(t, e) {
        return _l(t.charAt(e));
      }
      const xl = Dl();
      function El(t, e) {
        const n = String(t).matchAll(xl);
        return Array.from(n).some(
          t => t.index < e && e < t.index + t[0].length,
        );
      }
      function Dl() {
        const t = [
          /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
          /\p{Emoji}\u{FE0F}?\u{20E3}/u,
          /\p{Emoji}\u{FE0F}/u,
          /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
        ];
        const e = /\p{Regional_Indicator}{2}/u.source;
        const n = '(?:' + t.map(t => t.source).join('|') + ')';
        const o = `${e}|${n}(?:${n})*`;
        return new RegExp(o, 'ug');
      }
      class Tl extends dl {
        constructor(t = []) {
          super(t, { idProperty: 'viewUid' });
          this.on('add', (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          });
          this.on('remove', (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove();
            }
          });
          this._parentElement = null;
        }
        destroy() {
          this.map(t => t.destroy());
        }
        setParent(t) {
          this._parentElement = t;
          for (const t of this) {
            this._renderViewIntoCollectionParent(t);
          }
        }
        delegate(...t) {
          if (!t.length || !Sl(t)) {
            throw new B('ui-viewcollection-delegate-wrong-events', this);
          }
          return {
            to: e => {
              for (const n of this) {
                for (const o of t) {
                  n.delegate(o).to(e);
                }
              }
              this.on('add', (n, o) => {
                for (const n of t) {
                  o.delegate(n).to(e);
                }
              });
              this.on('remove', (n, o) => {
                for (const n of t) {
                  o.stopDelegating(n, e);
                }
              });
            },
          };
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render();
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(
              t.element,
              this._parentElement.children[e],
            );
          }
        }
        remove(t) {
          return super.remove(t);
        }
      }
      function Sl(t) {
        return t.every(t => typeof t == 'string');
      }
      var Pl = n(379);
      var Bl = n.n(Pl);
      var Rl = n(167);
      var Ol = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Ol.insert = 'head';
      Ol.singleton = true;
      var Il = Bl()(Rl.Z, Ol);
      const Ml = Rl.Z.locals || {};
      class Vl extends Ua(dt()) {
        constructor(t) {
          super();
          this.element = null;
          this.isRendered = false;
          this.locale = t;
          this.t = t && t.t;
          this._viewCollections = new dl();
          this._unboundChildren = this.createCollection();
          this._viewCollections.on('add', (e, n) => {
            n.locale = t;
            n.t = t && t.t;
          });
          this.decorate('render');
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate;
          }
          return (this._bindTemplate = Fl.bind(this, this));
        }
        createCollection(t) {
          const e = new Tl(t);
          this._viewCollections.add(e);
          return e;
        }
        registerChild(t) {
          if (!yt(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.add(e);
          }
        }
        deregisterChild(t) {
          if (!yt(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.remove(e);
          }
        }
        setTemplate(t) {
          this.template = new Fl(t);
        }
        extendTemplate(t) {
          Fl.extend(this.template, t);
        }
        render() {
          if (this.isRendered) {
            throw new B('ui-view-render-already-rendered', this);
          }
          if (this.template) {
            this.element = this.template.render();
            this.registerChild(this.template.getViews());
          }
          this.isRendered = true;
        }
        destroy() {
          this.stopListening();
          this._viewCollections.map(t => t.destroy());
          if (this.template && this.template._revertData) {
            this.template.revert(this.element);
          }
        }
      }
      const zl = 'http://www.w3.org/1999/xhtml';
      class Fl extends $() {
        constructor(t) {
          super();
          Object.assign(this, Zl(Ul(t)));
          this._isRendered = false;
          this._revertData = null;
        }
        render() {
          const t = this._renderNode({ intoFragment: true });
          this._isRendered = true;
          return t;
        }
        apply(t) {
          this._revertData = ld();
          this._renderNode({
            node: t,
            intoFragment: false,
            isApplying: true,
            revertData: this._revertData,
          });
          return t;
        }
        revert(t) {
          if (!this._revertData) {
            throw new B('ui-template-revert-not-applied', [this, t]);
          }
          this._revertTemplateFromNode(t, this._revertData);
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (rd(n)) {
                  yield n;
                } else if (sd(n)) {
                  yield* t(n);
                }
              }
            }
          }
          yield* t(this);
        }
        static bind(t, e) {
          return {
            to(n, o) {
              return new Ll({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: o,
              });
            },
            if(n, o, i) {
              return new Hl({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: o,
                callback: i,
              });
            },
          };
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new B('template-extend-render', [this, t]);
          }
          od(t, Zl(Ul(e)));
        }
        _renderNode(t) {
          let e;
          if (t.node) {
            e = this.tag && this.text;
          } else {
            e = this.tag ? this.text : !this.text;
          }
          if (e) {
            throw new B('ui-template-wrong-syntax', this);
          }
          if (this.text) {
            return this._renderText(t);
          } else {
            return this._renderElement(t);
          }
        }
        _renderElement(t) {
          let e = t.node;
          if (!e) {
            e = t.node = document.createElementNS(this.ns || zl, this.tag);
          }
          this._renderAttributes(t);
          this._renderElementChildren(t);
          this._setUpListeners(t);
          return e;
        }
        _renderText(t) {
          let e = t.node;
          if (e) {
            t.revertData.text = e.textContent;
          } else {
            e = t.node = document.createTextNode('');
          }
          if (jl(this.text)) {
            this._bindToObservable({
              schema: this.text,
              updater: Wl(e),
              data: t,
            });
          } else {
            e.textContent = this.text.join('');
          }
          return e;
        }
        _renderAttributes(t) {
          if (!this.attributes) {
            return;
          }
          const e = t.node;
          const n = t.revertData;
          for (const o in this.attributes) {
            const i = e.getAttribute(o);
            const r = this.attributes[o];
            if (n) {
              n.attributes[o] = i;
            }
            const s = cd(r) ? r[0].ns : null;
            if (jl(r)) {
              const a = cd(r) ? r[0].value : r;
              if (n && dd(o)) {
                a.unshift(i);
              }
              this._bindToObservable({
                schema: a,
                updater: Gl(e, o, s),
                data: t,
              });
            } else if (o == 'style' && typeof r[0] !== 'string') {
              this._renderStyleAttribute(r[0], t);
            } else {
              if (n && i && dd(o)) {
                r.unshift(i);
              }
              const t = r
                .map(t => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(ed, '');
              if (!id(t)) {
                e.setAttributeNS(s, o, t);
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node;
          for (const o in t) {
            const i = t[o];
            if (jl(i)) {
              this._bindToObservable({
                schema: [i],
                updater: Kl(n, o),
                data: e,
              });
            } else {
              n.style[o] = i;
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node;
          const n = t.intoFragment ? document.createDocumentFragment() : e;
          const o = t.isApplying;
          let i = 0;
          for (const r of this.children) {
            if (ad(r)) {
              if (!o) {
                r.setParent(e);
                for (const t of r) {
                  n.appendChild(t.element);
                }
              }
            } else if (rd(r)) {
              if (!o) {
                if (!r.isRendered) {
                  r.render();
                }
                n.appendChild(r.element);
              }
            } else if (Wa(r)) {
              n.appendChild(r);
            } else {
              if (o) {
                const e = t.revertData;
                const o = ld();
                e.children.push(o);
                r._renderNode({
                  intoFragment: false,
                  node: n.childNodes[i++],
                  isApplying: true,
                  revertData: o,
                });
              } else {
                n.appendChild(r.render());
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n);
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return;
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map(n => {
              const [o, i] = e.split('@');
              return n.activateDomEventListener(o, i, t);
            });
            if (t.revertData) {
              t.revertData.bindings.push(n);
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const o = n.revertData;
          $l(t, e, n);
          const i = t
            .filter(t => !id(t))
            .filter(t => t.observable)
            .map(o => o.activateAttributeListener(t, e, n));
          if (o) {
            o.bindings.push(i);
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e();
            }
          }
          if (e.text) {
            t.textContent = e.text;
            return;
          }
          const n = t;
          for (const t in e.attributes) {
            const o = e.attributes[t];
            if (o === null) {
              n.removeAttribute(t);
            } else {
              n.setAttribute(t, o);
            }
          }
          for (let t = 0; t < e.children.length; ++t) {
            this._revertTemplateFromNode(n.childNodes[t], e.children[t]);
          }
        }
      }
      class Nl {
        constructor(t) {
          this.attribute = t.attribute;
          this.observable = t.observable;
          this.emitter = t.emitter;
          this.callback = t.callback;
        }
        getValue(t) {
          const e = this.observable[this.attribute];
          return this.callback ? this.callback(e, t) : e;
        }
        activateAttributeListener(t, e, n) {
          const o = () => $l(t, e, n);
          this.emitter.listenTo(this.observable, `change:${this.attribute}`, o);
          return () => {
            this.emitter.stopListening(
              this.observable,
              `change:${this.attribute}`,
              o,
            );
          };
        }
      }
      class Ll extends Nl {
        constructor(t) {
          super(t);
          this.eventNameOrFunction = t.eventNameOrFunction;
        }
        activateDomEventListener(t, e, n) {
          const o = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == 'function') {
                this.eventNameOrFunction(n);
              } else {
                this.observable.fire(this.eventNameOrFunction, n);
              }
            }
          };
          this.emitter.listenTo(n.node, t, o);
          return () => {
            this.emitter.stopListening(n.node, t, o);
          };
        }
      }
      class Hl extends Nl {
        constructor(t) {
          super(t);
          this.valueIfTrue = t.valueIfTrue;
        }
        getValue(t) {
          const e = super.getValue(t);
          return id(e) ? false : this.valueIfTrue || true;
        }
      }
      function jl(t) {
        if (!t) {
          return false;
        }
        if (t.value) {
          t = t.value;
        }
        if (Array.isArray(t)) {
          return t.some(jl);
        } else if (t instanceof Nl) {
          return true;
        }
        return false;
      }
      function ql(t, e) {
        return t.map(t => {
          if (t instanceof Nl) {
            return t.getValue(e);
          }
          return t;
        });
      }
      function $l(t, e, { node: n }) {
        const o = ql(t, n);
        let i;
        if (t.length == 1 && t[0] instanceof Hl) {
          i = o[0];
        } else {
          i = o.reduce(ed, '');
        }
        if (id(i)) {
          e.remove();
        } else {
          e.set(i);
        }
      }
      function Wl(t) {
        return {
          set(e) {
            t.textContent = e;
          },
          remove() {
            t.textContent = '';
          },
        };
      }
      function Gl(t, e, n) {
        return {
          set(o) {
            t.setAttributeNS(n, e, o);
          },
          remove() {
            t.removeAttributeNS(n, e);
          },
        };
      }
      function Kl(t, e) {
        return {
          set(n) {
            t.style[e] = n;
          },
          remove() {
            t.style[e] = null;
          },
        };
      }
      function Ul(t) {
        const e = Na(t, t => {
          if (t && (t instanceof Nl || sd(t) || rd(t) || ad(t))) {
            return t;
          }
        });
        return e;
      }
      function Zl(t) {
        if (typeof t == 'string') {
          t = Ql(t);
        } else if (t.text) {
          Xl(t);
        }
        if (t.on) {
          t.eventListeners = Yl(t.on);
          delete t.on;
        }
        if (!t.text) {
          if (t.attributes) {
            Jl(t.attributes);
          }
          const e = [];
          if (t.children) {
            if (ad(t.children)) {
              e.push(t.children);
            } else {
              for (const n of t.children) {
                if (sd(n) || rd(n) || Wa(n)) {
                  e.push(n);
                } else {
                  e.push(new Fl(n));
                }
              }
            }
          }
          t.children = e;
        }
        return t;
      }
      function Jl(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = tl(t[e].value);
          }
          td(t, e);
        }
      }
      function Yl(t) {
        for (const e in t) {
          td(t, e);
        }
        return t;
      }
      function Ql(t) {
        return { text: [t] };
      }
      function Xl(t) {
        t.text = tl(t.text);
      }
      function td(t, e) {
        t[e] = tl(t[e]);
      }
      function ed(t, e) {
        if (id(e)) {
          return t;
        } else if (id(t)) {
          return e;
        } else {
          return `${t} ${e}`;
        }
      }
      function nd(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n]);
          } else {
            t[n] = e[n];
          }
        }
      }
      function od(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {};
          }
          nd(t.attributes, e.attributes);
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {};
          }
          nd(t.eventListeners, e.eventListeners);
        }
        if (e.text) {
          t.text.push(...e.text);
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new B('ui-template-extend-children-mismatch', t);
          }
          let n = 0;
          for (const o of e.children) {
            od(t.children[n++], o);
          }
        }
      }
      function id(t) {
        return !t && t !== 0;
      }
      function rd(t) {
        return t instanceof Vl;
      }
      function sd(t) {
        return t instanceof Fl;
      }
      function ad(t) {
        return t instanceof Tl;
      }
      function cd(t) {
        return ot(t[0]) && t[0].ns;
      }
      function ld() {
        return { children: [], bindings: [], attributes: {} };
      }
      function dd(t) {
        return t == 'class' || t == 'style';
      }
      class hd extends Tl {
        constructor(t, e = []) {
          super(e);
          this.locale = t;
        }
        get bodyCollectionContainer() {
          return this._bodyCollectionContainer;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Fl({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners'],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render();
          let t = document.querySelector('.ck-body-wrapper');
          if (!t) {
            t = te(document, 'div', { class: 'ck-body-wrapper' });
            document.body.appendChild(t);
          }
          t.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy();
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove();
          }
          const t = document.querySelector('.ck-body-wrapper');
          if (t && t.childElementCount == 0) {
            t.remove();
          }
        }
      }
      var ud = n(977);
      var fd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      fd.insert = 'head';
      fd.singleton = true;
      var pd = Bl()(ud.Z, fd);
      const gd = ud.Z.locals || {};
      class md extends Vl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set('content', '');
          this.set('viewBox', '0 0 20 20');
          this.set('fillColor', '');
          this.set('isColorInherited', true);
          this.set('isVisible', true);
          this.setTemplate({
            tag: 'svg',
            ns: 'http://www.w3.org/2000/svg',
            attributes: {
              class: [
                'ck',
                'ck-icon',
                t.if('isVisible', 'ck-hidden', t => !t),
                'ck-reset_all-excluded',
                t.if('isColorInherited', 'ck-icon_inherit-color'),
              ],
              viewBox: t.to('viewBox'),
            },
          });
        }
        render() {
          super.render();
          this._updateXMLContent();
          this._colorFillPaths();
          this.on('change:content', () => {
            this._updateXMLContent();
            this._colorFillPaths();
          });
          this.on('change:fillColor', () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(
              this.content.trim(),
              'image/svg+xml',
            );
            const e = t.querySelector('svg');
            const n = e.getAttribute('viewBox');
            if (n) {
              this.viewBox = n;
            }
            for (const { name: t, value: n } of Array.from(e.attributes)) {
              if (md.presentationalAttributeNames.includes(t)) {
                this.element.setAttribute(t, n);
              }
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild);
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0]);
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll('.ck-icon__fill').forEach(t => {
              t.style.fill = this.fillColor;
            });
          }
        }
      }
      md.presentationalAttributeNames = [
        'alignment-baseline',
        'baseline-shift',
        'clip-path',
        'clip-rule',
        'color',
        'color-interpolation',
        'color-interpolation-filters',
        'color-rendering',
        'cursor',
        'direction',
        'display',
        'dominant-baseline',
        'fill',
        'fill-opacity',
        'fill-rule',
        'filter',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'mask',
        'opacity',
        'overflow',
        'paint-order',
        'pointer-events',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'stroke',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-overflow',
        'text-rendering',
        'transform',
        'unicode-bidi',
        'vector-effect',
        'visibility',
        'white-space',
        'word-spacing',
        'writing-mode',
      ];
      class kd extends Vl {
        constructor() {
          super();
          this.set({ style: undefined, text: undefined, id: undefined });
          const t = this.bindTemplate;
          this.setTemplate({
            tag: 'span',
            attributes: {
              class: ['ck', 'ck-button__label'],
              style: t.to('style'),
              id: t.to('id'),
            },
            children: [{ text: t.to('text') }],
          });
        }
      }
      var bd = n(971);
      var wd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      wd.insert = 'head';
      wd.singleton = true;
      var _d = Bl()(bd.Z, wd);
      const vd = bd.Z.locals || {};
      class Ad extends Vl {
        constructor(t, e = new kd()) {
          super(t);
          this._focusDelayed = null;
          const n = this.bindTemplate;
          const o = E();
          this.set('ariaLabel', undefined);
          this.set('ariaLabelledBy', `ck-editor__aria-label_${o}`);
          this.set('class', undefined);
          this.set('labelStyle', undefined);
          this.set('icon', undefined);
          this.set('isEnabled', true);
          this.set('isOn', false);
          this.set('isVisible', true);
          this.set('isToggleable', false);
          this.set('keystroke', undefined);
          this.set('label', undefined);
          this.set('role', undefined);
          this.set('tabindex', -1);
          this.set('tooltip', false);
          this.set('tooltipPosition', 's');
          this.set('type', 'button');
          this.set('withText', false);
          this.set('withKeystroke', false);
          this.children = this.createCollection();
          this.labelView = this._setupLabelView(e);
          this.iconView = new md();
          this.iconView.extendTemplate({
            attributes: { class: 'ck-button__icon' },
          });
          this.keystrokeView = this._createKeystrokeView();
          this.bind('_tooltipString').to(
            this,
            'tooltip',
            this,
            'label',
            this,
            'keystroke',
            this._getTooltipString.bind(this),
          );
          const i = {
            tag: 'button',
            attributes: {
              class: [
                'ck',
                'ck-button',
                n.to('class'),
                n.if('isEnabled', 'ck-disabled', t => !t),
                n.if('isVisible', 'ck-hidden', t => !t),
                n.to('isOn', t => (t ? 'ck-on' : 'ck-off')),
                n.if('withText', 'ck-button_with-text'),
                n.if('withKeystroke', 'ck-button_with-keystroke'),
              ],
              role: n.to('role'),
              type: n.to('type', t => (t ? t : 'button')),
              tabindex: n.to('tabindex'),
              'aria-label': n.to('ariaLabel'),
              'aria-labelledby': n.to('ariaLabelledBy'),
              'aria-disabled': n.if('isEnabled', true, t => !t),
              'aria-pressed': n.to('isOn', t =>
                this.isToggleable ? String(!!t) : false,
              ),
              'data-cke-tooltip-text': n.to('_tooltipString'),
              'data-cke-tooltip-position': n.to('tooltipPosition'),
            },
            children: this.children,
            on: {
              click: n.to(t => {
                if (this.isEnabled) {
                  this.fire('execute');
                } else {
                  t.preventDefault();
                }
              }),
            },
          };
          if (s.isSafari) {
            if (!this._focusDelayed) {
              this._focusDelayed = bl(() => this.focus(), 0);
            }
            i.on.mousedown = n.to(() => {
              this._focusDelayed();
            });
            i.on.mouseup = n.to(() => {
              this._focusDelayed.cancel();
            });
          }
          this.setTemplate(i);
        }
        render() {
          super.render();
          if (this.icon) {
            this.iconView.bind('content').to(this, 'icon');
            this.children.add(this.iconView);
          }
          this.children.add(this.labelView);
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView);
          }
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          if (this._focusDelayed) {
            this._focusDelayed.cancel();
          }
          super.destroy();
        }
        _setupLabelView(t) {
          t.bind('text', 'style', 'id').to(
            this,
            'label',
            'labelStyle',
            'ariaLabelledBy',
          );
          return t;
        }
        _createKeystrokeView() {
          const t = new Vl();
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__keystroke'] },
            children: [{ text: this.bindTemplate.to('keystroke', t => Kc(t)) }],
          });
          return t;
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == 'string') {
              return t;
            } else {
              if (n) {
                n = Kc(n);
              }
              if (t instanceof Function) {
                return t(e, n);
              } else {
                return `${e}${n ? ` (${n})` : ''}`;
              }
            }
          }
          return '';
        }
      }
      var Cd = n(258);
      var yd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      yd.insert = 'head';
      yd.singleton = true;
      var xd = Bl()(Cd.Z, yd);
      const Ed = Cd.Z.locals || {};
      class Dd extends Ad {
        constructor(t) {
          super(t);
          this.isToggleable = true;
          this.toggleSwitchView = this._createToggleView();
          this.extendTemplate({ attributes: { class: 'ck-switchbutton' } });
        }
        render() {
          super.render();
          this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t = new Vl();
          t.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-button__toggle'] },
            children: [
              {
                tag: 'span',
                attributes: { class: ['ck', 'ck-button__toggle__inner'] },
              },
            ],
          });
          return t;
        }
      }
      class Td extends (null && ButtonView) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('color', undefined);
          this.set('hasBorder', false);
          this.icon = checkIcon;
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to('color') },
              class: [
                'ck',
                'ck-color-grid__tile',
                e.if('hasBorder', 'ck-color-selector__color-tile_bordered'),
              ],
            },
          });
        }
        render() {
          super.render();
          this.iconView.fillColor = 'hsl(0, 0%, 100%)';
        }
      }
      var Sd = n(923);
      var Pd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Pd.insert = 'head';
      Pd.singleton = true;
      var Bd = Bl()(Sd.Z, Pd);
      const Rd = Sd.Z.locals || {};
      class Od extends (null && View) {
        constructor(t, e) {
          super(t);
          const n = e && e.colorDefinitions ? e.colorDefinitions : [];
          this.columns = e && e.columns ? e.columns : 5;
          const o = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` };
          this.set('selectedColor', undefined);
          this.items = this.createCollection();
          this.focusTracker = new FocusTracker();
          this.keystrokes = new KeystrokeHandler();
          this.items.on('add', (t, e) => {
            e.isOn = e.color === this.selectedColor;
          });
          n.forEach(t => {
            const e = new ColorTileView();
            e.set({
              color: t.color,
              label: t.label,
              tooltip: true,
              hasBorder: t.options.hasBorder,
            });
            e.on('execute', () => {
              this.fire('execute', {
                value: t.color,
                hasBorder: t.options.hasBorder,
                label: t.label,
              });
            });
            this.items.add(e);
          });
          this.setTemplate({
            tag: 'div',
            children: this.items,
            attributes: { class: ['ck', 'ck-color-grid'], style: o },
          });
          this.on('change:selectedColor', (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n;
            }
          });
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus();
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus();
          }
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          addKeyboardHandlingForGrid({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
      }
      var Id = n(874);
      const Md = null && zd;
      var Vd = {
        red: 0,
        orange: 60,
        yellow: 120,
        green: 180,
        blue: 240,
        purple: 300,
      };
      function zd(t) {
        var e,
          n = [],
          o = 1,
          i;
        if (typeof t === 'string') {
          if (names[t]) {
            n = names[t].slice();
            i = 'rgb';
          } else if (t === 'transparent') {
            o = 0;
            i = 'rgb';
            n = [0, 0, 0];
          } else if (/^#[A-Fa-f0-9]+$/.test(t)) {
            var r = t.slice(1);
            var s = r.length;
            var a = s <= 4;
            o = 1;
            if (a) {
              n = [
                parseInt(r[0] + r[0], 16),
                parseInt(r[1] + r[1], 16),
                parseInt(r[2] + r[2], 16),
              ];
              if (s === 4) {
                o = parseInt(r[3] + r[3], 16) / 255;
              }
            } else {
              n = [
                parseInt(r[0] + r[1], 16),
                parseInt(r[2] + r[3], 16),
                parseInt(r[4] + r[5], 16),
              ];
              if (s === 8) {
                o = parseInt(r[6] + r[7], 16) / 255;
              }
            }
            if (!n[0]) n[0] = 0;
            if (!n[1]) n[1] = 0;
            if (!n[2]) n[2] = 0;
            i = 'rgb';
          } else if (
            (e =
              /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(
                t,
              ))
          ) {
            var c = e[1];
            var l = c === 'rgb';
            var r = c.replace(/a$/, '');
            i = r;
            var s = r === 'cmyk' ? 4 : r === 'gray' ? 1 : 3;
            n = e[2]
              .trim()
              .split(/\s*[,\/]\s*|\s+/)
              .map(function (t, e) {
                if (/%$/.test(t)) {
                  if (e === s) return parseFloat(t) / 100;
                  if (r === 'rgb') return (parseFloat(t) * 255) / 100;
                  return parseFloat(t);
                } else if (r[e] === 'h') {
                  if (/deg$/.test(t)) {
                    return parseFloat(t);
                  } else if (Vd[t] !== undefined) {
                    return Vd[t];
                  }
                }
                return parseFloat(t);
              });
            if (c === r) n.push(1);
            o = l ? 1 : n[s] === undefined ? 1 : n[s];
            n = n.slice(0, s);
          } else if (t.length > 10 && /[0-9](?:\s|\/)/.test(t)) {
            n = t.match(/([0-9]+)/g).map(function (t) {
              return parseFloat(t);
            });
            i = t
              .match(/([a-z])/gi)
              .join('')
              .toLowerCase();
          }
        } else if (!isNaN(t)) {
          i = 'rgb';
          n = [t >>> 16, (t & 65280) >>> 8, t & 255];
        } else if (Array.isArray(t) || t.length) {
          n = [t[0], t[1], t[2]];
          i = 'rgb';
          o = t.length === 4 ? t[3] : 1;
        } else if (t instanceof Object) {
          if (t.r != null || t.red != null || t.R != null) {
            i = 'rgb';
            n = [
              t.r || t.red || t.R || 0,
              t.g || t.green || t.G || 0,
              t.b || t.blue || t.B || 0,
            ];
          } else {
            i = 'hsl';
            n = [
              t.h || t.hue || t.H || 0,
              t.s || t.saturation || t.S || 0,
              t.l || t.lightness || t.L || t.b || t.brightness,
            ];
          }
          o = t.a || t.alpha || t.opacity || 1;
          if (t.opacity != null) o /= 100;
        }
        return { space: i, values: n, alpha: o };
      }
      var Fd = n(85);
      function Nd(t, e) {
        if (!t) {
          return '';
        }
        const n = jd(t);
        if (!n) {
          return '';
        }
        if (n.space === e) {
          return t;
        }
        if (!qd(n)) {
          return '';
        }
        const o = convert[n.space];
        const i = o[e];
        if (!i) {
          return '';
        }
        const r = i(n.space === 'hex' ? n.hexValue : n.values);
        return Hd(r, e);
      }
      function Ld(t) {
        if (!t) {
          return '';
        }
        const e = jd(t);
        if (!e) {
          return '#000';
        }
        if (e.space === 'hex') {
          return e.hexValue;
        }
        return Nd(t, 'hex');
      }
      function Hd(t, e) {
        switch (e) {
          case 'hex':
            return `#${t}`;
          case 'rgb':
            return `rgb( ${t[0]}, ${t[1]}, ${t[2]} )`;
          case 'hsl':
            return `hsl( ${t[0]}, ${t[1]}%, ${t[2]}% )`;
          case 'hwb':
            return `hwb( ${t[0]}, ${t[1]}, ${t[2]} )`;
          case 'lab':
            return `lab( ${t[0]}% ${t[1]} ${t[2]} )`;
          case 'lch':
            return `lch( ${t[0]}% ${t[1]} ${t[2]} )`;
          default:
            return '';
        }
      }
      function jd(t) {
        if (t.startsWith('#')) {
          const e = parse(t);
          return {
            space: 'hex',
            values: e.values,
            hexValue: t,
            alpha: e.alpha,
          };
        }
        const e = parse(t);
        if (!e.space) {
          return null;
        }
        return e;
      }
      function qd(t) {
        return Object.keys(convert).includes(t.space);
      }
      var $d = n(525);
      var Wd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Wd.insert = 'head';
      Wd.singleton = true;
      var Gd = Bl()($d.Z, Wd);
      const Kd = $d.Z.locals || {};
      class Ud extends Vl {
        constructor(t) {
          super(t);
          this.set('text', undefined);
          this.set('for', undefined);
          this.id = `ck-editor__label_${E()}`;
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'label',
            attributes: {
              class: ['ck', 'ck-label'],
              id: this.id,
              for: e.to('for'),
            },
            children: [{ text: e.to('text') }],
          });
        }
      }
      var Zd = n(933);
      var Jd = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Jd.insert = 'head';
      Jd.singleton = true;
      var Yd = Bl()(Zd.Z, Jd);
      const Qd = Zd.Z.locals || {};
      class Xd extends Vl {
        constructor(t, e) {
          super(t);
          const n = `ck-labeled-field-view-${E()}`;
          const o = `ck-labeled-field-view-status-${E()}`;
          this.fieldView = e(this, n, o);
          this.set('label', undefined);
          this.set('isEnabled', true);
          this.set('isEmpty', true);
          this.set('isFocused', false);
          this.set('errorText', null);
          this.set('infoText', null);
          this.set('class', undefined);
          this.set('placeholder', undefined);
          this.labelView = this._createLabelView(n);
          this.statusView = this._createStatusView(o);
          this.fieldWrapperChildren = this.createCollection([
            this.fieldView,
            this.labelView,
          ]);
          this.bind('_statusText').to(
            this,
            'errorText',
            this,
            'infoText',
            (t, e) => t || e,
          );
          const i = this.bindTemplate;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view',
                i.to('class'),
                i.if('isEnabled', 'ck-disabled', t => !t),
                i.if('isEmpty', 'ck-labeled-field-view_empty'),
                i.if('isFocused', 'ck-labeled-field-view_focused'),
                i.if('placeholder', 'ck-labeled-field-view_placeholder'),
                i.if('errorText', 'ck-error'),
              ],
            },
            children: [
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-labeled-field-view__input-wrapper'],
                },
                children: this.fieldWrapperChildren,
              },
              this.statusView,
            ],
          });
        }
        _createLabelView(t) {
          const e = new Ud(this.locale);
          e.for = t;
          e.bind('text').to(this, 'label');
          return e;
        }
        _createStatusView(t) {
          const e = new Vl(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-labeled-field-view__status',
                n.if('errorText', 'ck-labeled-field-view__status_error'),
                n.if('_statusText', 'ck-hidden', t => !t),
              ],
              id: t,
              role: n.if('errorText', 'alert'),
            },
            children: [{ text: n.to('_statusText') }],
          });
          return e;
        }
        focus(t) {
          this.fieldView.focus(t);
        }
      }
      class th extends Vl {
        constructor(t) {
          super(t);
          this.set('value', undefined);
          this.set('id', undefined);
          this.set('placeholder', undefined);
          this.set('isReadOnly', false);
          this.set('hasError', false);
          this.set('ariaDescribedById', undefined);
          this.focusTracker = new ul();
          this.bind('isFocused').to(this.focusTracker);
          this.set('isEmpty', true);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'input',
            attributes: {
              class: [
                'ck',
                'ck-input',
                e.if('isFocused', 'ck-input_focused'),
                e.if('isEmpty', 'ck-input-text_empty'),
                e.if('hasError', 'ck-error'),
              ],
              id: e.to('id'),
              placeholder: e.to('placeholder'),
              readonly: e.to('isReadOnly'),
              'aria-invalid': e.if('hasError', true),
              'aria-describedby': e.to('ariaDescribedById'),
            },
            on: {
              input: e.to((...t) => {
                this.fire('input', ...t);
                this._updateIsEmpty();
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          this._setDomElementValue(this.value);
          this._updateIsEmpty();
          this.on('change:value', (t, e, n) => {
            this._setDomElementValue(n);
            this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        reset() {
          this.value = this.element.value = '';
          this._updateIsEmpty();
        }
        _updateIsEmpty() {
          this.isEmpty = eh(this.element);
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? '' : t;
        }
      }
      function eh(t) {
        return !t.value;
      }
      var nh = n(470);
      var oh = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      oh.insert = 'head';
      oh.singleton = true;
      var ih = Bl()(nh.Z, oh);
      const rh = nh.Z.locals || {};
      class sh extends th {
        constructor(t) {
          super(t);
          this.set('inputMode', 'text');
          const e = this.bindTemplate;
          this.extendTemplate({ attributes: { inputmode: e.to('inputMode') } });
        }
      }
      class ah extends sh {
        constructor(t) {
          super(t);
          this.extendTemplate({
            attributes: { type: 'text', class: ['ck-input-text'] },
          });
        }
      }
      class ch extends (null && InputView) {
        constructor(t, { min: e, max: n, step: o } = {}) {
          super(t);
          const i = this.bindTemplate;
          this.set('min', e);
          this.set('max', n);
          this.set('step', o);
          this.extendTemplate({
            attributes: {
              type: 'number',
              class: ['ck-input-number'],
              min: i.to('min'),
              max: i.to('max'),
              step: i.to('step'),
            },
          });
        }
      }
      var lh = n(224);
      var dh = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      dh.insert = 'head';
      dh.singleton = true;
      var hh = Bl()(lh.Z, dh);
      const uh = lh.Z.locals || {};
      class fh extends (null && InputBase) {
        constructor(t) {
          super(t);
          const e = toUnit('px');
          this.set('minRows', 2);
          this.set('maxRows', 5);
          this.set('_height', null);
          this.set('resize', 'none');
          this.on('change:minRows', this._validateMinMaxRows.bind(this));
          this.on('change:maxRows', this._validateMinMaxRows.bind(this));
          const n = this.bindTemplate;
          this.template.tag = 'textarea';
          this.extendTemplate({
            attributes: {
              class: ['ck-textarea'],
              style: {
                height: n.to('_height', t => (t ? e(t) : null)),
                resize: n.to('resize'),
              },
              rows: n.to('minRows'),
            },
          });
        }
        render() {
          super.render();
          this.on('input', () => {
            this._updateAutoGrowHeight(true);
            this.fire('update');
          });
          this.on('change:value', () => {
            global.window.requestAnimationFrame(() => {
              if (isVisible(this.element)) {
                this._updateAutoGrowHeight();
                this.fire('update');
              }
            });
          });
        }
        reset() {
          super.reset();
          this._updateAutoGrowHeight();
          this.fire('update');
        }
        _updateAutoGrowHeight(t) {
          const e = this.element;
          const n = ph(e, '1');
          const o = ph(e, e.value);
          const i = n.ownerDocument.defaultView.getComputedStyle(n);
          const r = parseFloat(i.paddingTop) + parseFloat(i.paddingBottom);
          const s = getBorderWidths(n);
          const a = parseFloat(i.lineHeight);
          const c = s.top + s.bottom;
          const l = new Rect(n).height;
          const d = Math.round((o.scrollHeight - r) / a);
          const h = this.maxRows * a + r + c;
          const u = d === 1 ? l : this.minRows * a + r + c;
          this._height = Math.min(
            Math.max(Math.max(d, this.minRows) * a + r + c, u),
            h,
          );
          if (t) {
            e.scrollTop = e.scrollHeight;
          }
          n.remove();
          o.remove();
        }
        _validateMinMaxRows() {
          if (this.minRows > this.maxRows) {
            throw new CKEditorError(
              'ui-textarea-view-min-rows-greater-than-max-rows',
              {
                textareaView: this,
                minRows: this.minRows,
                maxRows: this.maxRows,
              },
            );
          }
        }
      }
      function ph(t, e) {
        const n = t.cloneNode();
        n.style.position = 'absolute';
        n.style.top = '-99999px';
        n.style.left = '-99999px';
        n.style.height = 'auto';
        n.style.overflow = 'hidden';
        n.style.width = t.ownerDocument.defaultView.getComputedStyle(t).width;
        n.tabIndex = -1;
        n.rows = 1;
        n.value = e;
        t.parentNode.insertBefore(n, t);
        return n;
      }
      class gh extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isVisible', false);
          this.set('position', 'se');
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-reset',
                'ck-dropdown__panel',
                e.to('position', t => `ck-dropdown__panel_${t}`),
                e.if('isVisible', 'ck-dropdown__panel-visible'),
              ],
              tabindex: '-1',
            },
            children: this.children,
            on: {
              selectstart: e.to(t => {
                if (t.target.tagName.toLocaleLowerCase() === 'input') {
                  return;
                }
                t.preventDefault();
              }),
            },
          });
        }
        focus() {
          if (this.children.length) {
            const t = this.children.first;
            if (typeof t.focus === 'function') {
              t.focus();
            } else {
              R('ui-dropdown-panel-focus-child-missing-focus', {
                childView: this.children.first,
                dropdownPanel: this,
              });
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last;
            if (typeof t.focusLast === 'function') {
              t.focusLast();
            } else {
              t.focus();
            }
          }
        }
      }
      var mh = n(62);
      var kh = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      kh.insert = 'head';
      kh.singleton = true;
      var bh = Bl()(mh.Z, kh);
      const wh = mh.Z.locals || {};
      class _h extends Vl {
        constructor(t, e, n) {
          super(t);
          const o = this.bindTemplate;
          this.buttonView = e;
          this.panelView = n;
          this.set('isOpen', false);
          this.set('isEnabled', true);
          this.set('class', undefined);
          this.set('id', undefined);
          this.set('panelPosition', 'auto');
          this.panelView.bind('isVisible').to(this, 'isOpen');
          this.keystrokes = new fl();
          this.focusTracker = new ul();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-dropdown',
                o.to('class'),
                o.if('isEnabled', 'ck-disabled', t => !t),
              ],
              id: o.to('id'),
              'aria-describedby': o.to('ariaDescribedById'),
            },
            children: [e, n],
          });
          e.extendTemplate({
            attributes: {
              class: ['ck-dropdown__button'],
              'data-cke-tooltip-disabled': o.to('isOpen'),
            },
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.buttonView.element);
          this.focusTracker.add(this.panelView.element);
          this.listenTo(this.buttonView, 'open', () => {
            this.isOpen = !this.isOpen;
          });
          this.on('change:isOpen', (t, e, n) => {
            if (!n) {
              return;
            }
            if (this.panelPosition === 'auto') {
              const t = _h._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              });
              this.panelView.position = t
                ? t.name
                : this._panelPositions[0].name;
            } else {
              this.panelView.position = this.panelPosition;
            }
          });
          this.keystrokes.listenTo(this.element);
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false;
              e();
            }
          };
          this.keystrokes.set('arrowdown', (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true;
              e();
            }
          });
          this.keystrokes.set('arrowright', (t, e) => {
            if (this.isOpen) {
              e();
            }
          });
          this.keystrokes.set('arrowleft', t);
          this.keystrokes.set('esc', t);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: o,
            northEast: i,
            northWest: r,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = _h.defaultPanelPositions;
          if (this.locale.uiLanguageDirection !== 'rtl') {
            return [n, o, s, a, t, i, r, c, l, e];
          } else {
            return [o, n, a, s, t, r, i, l, c, e];
          }
        }
      }
      _h.defaultPanelPositions = {
        south: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 2,
          name: 's',
        }),
        southEast: t => ({ top: t.bottom, left: t.left, name: 'se' }),
        southWest: (t, e) => ({
          top: t.bottom,
          left: t.left - e.width + t.width,
          name: 'sw',
        }),
        southMiddleEast: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 4,
          name: 'sme',
        }),
        southMiddleWest: (t, e) => ({
          top: t.bottom,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: 'smw',
        }),
        north: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 2,
          name: 'n',
        }),
        northEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left,
          name: 'ne',
        }),
        northWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - e.width + t.width,
          name: 'nw',
        }),
        northMiddleEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 4,
          name: 'nme',
        }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: 'nmw',
        }),
      };
      _h._getOptimalPosition = Cc;
      const vh =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class Ah extends Ad {
        constructor(t) {
          super(t);
          this.arrowView = this._createArrowView();
          this.extendTemplate({
            attributes: {
              'aria-haspopup': true,
              'aria-expanded': this.bindTemplate.to('isOn', t => String(t)),
            },
          });
          this.delegate('execute').to(this, 'open');
        }
        render() {
          super.render();
          this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t = new md();
          t.content = vh;
          t.extendTemplate({ attributes: { class: 'ck-dropdown__arrow' } });
          return t;
        }
      }
      class Ch extends $() {
        constructor(t) {
          super();
          this.focusables = t.focusables;
          this.focusTracker = t.focusTracker;
          this.keystrokeHandler = t.keystrokeHandler;
          this.actions = t.actions;
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e];
              if (typeof n == 'string') {
                n = [n];
              }
              for (const o of n) {
                t.keystrokeHandler.set(o, (t, n) => {
                  this[e]();
                  n();
                });
              }
            }
          }
          this.on('forwardCycle', () => this.focusFirst(), { priority: 'low' });
          this.on('backwardCycle', () => this.focusLast(), { priority: 'low' });
        }
        get first() {
          return this.focusables.find(yh) || null;
        }
        get last() {
          return this.focusables.filter(yh).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t = null;
          if (this.focusTracker.focusedElement === null) {
            return null;
          }
          this.focusables.find((e, n) => {
            const o = e.element === this.focusTracker.focusedElement;
            if (o) {
              t = n;
            }
            return o;
          });
          return t;
        }
        focusFirst() {
          this._focus(this.first, 1);
        }
        focusLast() {
          this._focus(this.last, -1);
        }
        focusNext() {
          const t = this.next;
          if (t && this.focusables.getIndex(t) === this.current) {
            return;
          }
          if (t === this.first) {
            this.fire('forwardCycle');
          } else {
            this._focus(t, 1);
          }
        }
        focusPrevious() {
          const t = this.previous;
          if (t && this.focusables.getIndex(t) === this.current) {
            return;
          }
          if (t === this.last) {
            this.fire('backwardCycle');
          } else {
            this._focus(t, -1);
          }
        }
        _focus(t, e) {
          if (t) {
            t.focus(e);
          }
        }
        _getFocusableItem(t) {
          const e = this.current;
          const n = this.focusables.length;
          if (!n) {
            return null;
          }
          if (e === null) {
            return this[t === 1 ? 'first' : 'last'];
          }
          let o = (e + n + t) % n;
          do {
            const e = this.focusables.get(o);
            if (yh(e)) {
              return e;
            }
            o = (o + n + t) % n;
          } while (o !== e);
          return null;
        }
      }
      function yh(t) {
        return !!('focus' in t && Ac(t.element));
      }
      class xh extends Vl {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-toolbar__separator'] },
          });
        }
      }
      class Eh extends Vl {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-toolbar__line-break'] },
          });
        }
      }
      function Dh(t) {
        return t.bindTemplate.to(e => {
          if (e.target === t.element) {
            e.preventDefault();
          }
        });
      }
      function Th(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] };
        }
        const e = { items: [], removeItems: [] };
        if (!t) {
          return e;
        }
        return { ...e, ...t };
      }
      class Sh extends dt() {
        constructor(t) {
          super();
          this._disableStack = new Set();
          this.editor = t;
          this.set('isEnabled', true);
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', Ph, { priority: 'highest' });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', Ph);
            this.isEnabled = true;
          }
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      function Ph(t) {
        t.return = false;
        t.stop();
      }
      class Bh extends dt() {
        constructor(t) {
          super();
          this.editor = t;
          this.set('value', undefined);
          this.set('isEnabled', false);
          this._affectsData = true;
          this._isEnabledBasedOnSelection = true;
          this._disableStack = new Set();
          this.decorate('execute');
          this.listenTo(this.editor.model.document, 'change', () => {
            this.refresh();
          });
          this.listenTo(t, 'change:isReadOnly', () => {
            this.refresh();
          });
          this.on(
            'set:isEnabled',
            e => {
              if (!this.affectsData) {
                return;
              }
              const n = t.model.document.selection;
              const o = n.getFirstPosition().root.rootName == '$graveyard';
              const i = !o && t.model.canEditAt(n);
              if (t.isReadOnly || (this._isEnabledBasedOnSelection && !i)) {
                e.return = false;
                e.stop();
              }
            },
            { priority: 'highest' },
          );
          this.on(
            'execute',
            t => {
              if (!this.isEnabled) {
                t.stop();
              }
            },
            { priority: 'high' },
          );
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(t) {
          this._affectsData = t;
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on('set:isEnabled', Rh, { priority: 'highest' });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off('set:isEnabled', Rh);
            this.refresh();
          }
        }
        execute(...t) {
          return undefined;
        }
        destroy() {
          this.stopListening();
        }
      }
      function Rh(t) {
        t.return = false;
        t.stop();
      }
      class Oh extends (null && Command) {
        constructor() {
          super(...arguments);
          this._childCommandsDefinitions = [];
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand();
          return !!e && e.execute(t);
        }
        registerChildCommand(t, e = {}) {
          insertToPriorityArray(this._childCommandsDefinitions, {
            command: t,
            priority: e.priority || 'normal',
          });
          t.on('change:isEnabled', () => this._checkEnabled());
          this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(
            ({ command: t }) => t.isEnabled,
          );
          return t && t.command;
        }
      }
      class Ih extends $() {
        constructor(t, e = [], n = []) {
          super();
          this._plugins = new Map();
          this._context = t;
          this._availablePlugins = new Map();
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
          this._contextPlugins = new Map();
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e);
            this._contextPlugins.set(e, t);
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == 'function') {
              yield t;
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t);
          if (!e) {
            let e = t;
            if (typeof t == 'function') {
              e = t.pluginName || t.name;
            }
            throw new B('plugincollection-plugin-not-loaded', this._context, {
              plugin: e,
            });
          }
          return e;
        }
        has(t) {
          return this._plugins.has(t);
        }
        init(t, e = [], n = []) {
          const o = this;
          const i = this._context;
          u(t);
          p(t);
          const r = t.filter(t => !d(t, e));
          const s = [...f(r)];
          _(s, n);
          const a = b(s);
          return w(a, 'init')
            .then(() => w(a, 'afterInit'))
            .then(() => a);
          function c(t) {
            return typeof t === 'function';
          }
          function l(t) {
            return c(t) && !!t.isContextPlugin;
          }
          function d(t, e) {
            return e.some(e => {
              if (e === t) {
                return true;
              }
              if (h(t) === e) {
                return true;
              }
              if (h(e) === t) {
                return true;
              }
              return false;
            });
          }
          function h(t) {
            return c(t) ? t.pluginName || t.name : t;
          }
          function u(t, e = new Set()) {
            t.forEach(t => {
              if (!c(t)) {
                return;
              }
              if (e.has(t)) {
                return;
              }
              e.add(t);
              if (t.pluginName && !o._availablePlugins.has(t.pluginName)) {
                o._availablePlugins.set(t.pluginName, t);
              }
              if (t.requires) {
                u(t.requires, e);
              }
            });
          }
          function f(t, e = new Set()) {
            return t
              .map(t => (c(t) ? t : o._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t;
                }
                e.add(n);
                if (n.requires) {
                  p(n.requires, n);
                  f(n.requires, e).forEach(e => t.add(e));
                }
                return t.add(n);
              }, new Set());
          }
          function p(t, e = null) {
            t.map(t => (c(t) ? t : o._availablePlugins.get(t) || t)).forEach(
              t => {
                g(t, e);
                m(t, e);
                k(t, e);
              },
            );
          }
          function g(t, e) {
            if (c(t)) {
              return;
            }
            if (e) {
              throw new B('plugincollection-soft-required', i, {
                missingPlugin: t,
                requiredBy: h(e),
              });
            }
            throw new B('plugincollection-plugin-not-found', i, { plugin: t });
          }
          function m(t, e) {
            if (!l(e)) {
              return;
            }
            if (l(t)) {
              return;
            }
            throw new B('plugincollection-context-required', i, {
              plugin: h(t),
              requiredBy: h(e),
            });
          }
          function k(t, n) {
            if (!n) {
              return;
            }
            if (!d(t, e)) {
              return;
            }
            throw new B('plugincollection-required', i, {
              plugin: h(t),
              requiredBy: h(n),
            });
          }
          function b(t) {
            return t.map(t => {
              let e = o._contextPlugins.get(t);
              e = e || new t(i);
              o._add(t, e);
              return e;
            });
          }
          function w(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t;
              }
              if (o._contextPlugins.has(n)) {
                return t;
              }
              return t.then(n[e].bind(n));
            }, Promise.resolve());
          }
          function _(t, e) {
            for (const n of e) {
              if (typeof n != 'function') {
                throw new B(
                  'plugincollection-replace-plugin-invalid-type',
                  null,
                  { pluginItem: n },
                );
              }
              const e = n.pluginName;
              if (!e) {
                throw new B(
                  'plugincollection-replace-plugin-missing-name',
                  null,
                  { pluginItem: n },
                );
              }
              if (n.requires && n.requires.length) {
                throw new B(
                  'plugincollection-plugin-for-replacing-cannot-have-dependencies',
                  null,
                  { pluginName: e },
                );
              }
              const i = o._availablePlugins.get(e);
              if (!i) {
                throw new B(
                  'plugincollection-plugin-for-replacing-not-exist',
                  null,
                  { pluginName: e },
                );
              }
              const r = t.indexOf(i);
              if (r === -1) {
                if (o._contextPlugins.has(i)) {
                  return;
                }
                throw new B(
                  'plugincollection-plugin-for-replacing-not-loaded',
                  null,
                  { pluginName: e },
                );
              }
              if (i.requires && i.requires.length) {
                throw new B(
                  'plugincollection-replaced-plugin-cannot-have-dependencies',
                  null,
                  { pluginName: e },
                );
              }
              t.splice(r, 1, n);
              o._availablePlugins.set(e, n);
            }
          }
        }
        destroy() {
          const t = [];
          for (const [, e] of this) {
            if (
              typeof e.destroy == 'function' &&
              !this._contextPlugins.has(e)
            ) {
              t.push(e.destroy());
            }
          }
          return Promise.all(t);
        }
        _add(t, e) {
          this._plugins.set(t, e);
          const n = t.pluginName;
          if (!n) {
            return;
          }
          if (this._plugins.has(n)) {
            throw new B('plugincollection-plugin-name-conflict', null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            });
          }
          this._plugins.set(n, e);
        }
      }
      class Mh {
        constructor(t) {
          this._contextOwner = null;
          this.config = new ja(t, this.constructor.defaultConfig);
          const e = this.constructor.builtinPlugins;
          this.config.define('plugins', e);
          this.plugins = new Ih(this, e);
          const n = this.config.get('language') || {};
          this.locale = new cl({
            uiLanguage: typeof n === 'string' ? n : n.ui,
            contentLanguage: this.config.get('language.content'),
          });
          this.t = this.locale.t;
          this.editors = new dl();
        }
        initPlugins() {
          const t = this.config.get('plugins') || [];
          const e = this.config.get('substitutePlugins') || [];
          for (const n of t.concat(e)) {
            if (typeof n != 'function') {
              throw new B('context-initplugins-constructor-only', null, {
                Plugin: n,
              });
            }
            if (n.isContextPlugin !== true) {
              throw new B('context-initplugins-invalid-plugin', null, {
                Plugin: n,
              });
            }
          }
          return this.plugins.init(t, [], e);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, t => t.destroy())).then(
            () => this.plugins.destroy(),
          );
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new B('context-addeditor-private-context');
          }
          this.editors.add(t);
          if (e) {
            this._contextOwner = t;
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t);
          }
          if (this._contextOwner === t) {
            return this.destroy();
          }
          return Promise.resolve();
        }
        _getEditorConfig() {
          const t = {};
          for (const e of this.config.names()) {
            if (!['plugins', 'removePlugins', 'extraPlugins'].includes(e)) {
              t[e] = this.config.get(e);
            }
          }
          return t;
        }
        static create(t) {
          return new Promise(e => {
            const n = new this(t);
            e(n.initPlugins().then(() => n));
          });
        }
      }
      class Vh extends dt() {
        constructor(t) {
          super();
          this.context = t;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      var zh = n(372);
      var Fh = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Fh.insert = 'head';
      Fh.singleton = true;
      var Nh = Bl()(zh.Z, Fh);
      const Lh = zh.Z.locals || {};
      const Hh = new WeakMap();
      let jh = false;
      function qh({
        view: t,
        element: e,
        text: n,
        isDirectHost: o = true,
        keepOnFocus: i = false,
      }) {
        const r = t.document;
        if (!Hh.has(r)) {
          Hh.set(r, new Map());
          r.registerPostFixer(t => Uh(r, t));
          r.on(
            'change:isComposing',
            () => {
              t.change(t => Uh(r, t));
            },
            { priority: 'high' },
          );
        }
        if (e.is('editableElement')) {
          e.on('change:placeholder', (t, e, n) => {
            s(n);
          });
        }
        if (e.placeholder) {
          s(e.placeholder);
        } else if (n) {
          s(n);
        }
        if (n) {
          Yh();
        }
        function s(n) {
          Hh.get(r).set(e, {
            text: n,
            isDirectHost: o,
            keepOnFocus: i,
            hostElement: o ? e : null,
          });
          t.change(t => Uh(r, t));
        }
      }
      function $h(t, e) {
        const n = e.document;
        if (!Hh.has(n)) {
          return;
        }
        t.change(t => {
          const o = Hh.get(n);
          const i = o.get(e);
          t.removeAttribute('data-placeholder', i.hostElement);
          Gh(t, i.hostElement);
          o.delete(e);
        });
      }
      function Wh(t, e) {
        if (!e.hasClass('ck-placeholder')) {
          t.addClass('ck-placeholder', e);
          return true;
        }
        return false;
      }
      function Gh(t, e) {
        if (e.hasClass('ck-placeholder')) {
          t.removeClass('ck-placeholder', e);
          return true;
        }
        return false;
      }
      function Kh(t, e) {
        if (!t.isAttached()) {
          return false;
        }
        const n = Array.from(t.getChildren()).some(t => !t.is('uiElement'));
        if (n) {
          return false;
        }
        const o = t.document;
        const i = o.selection;
        const r = i.anchor;
        if (o.isComposing && r && r.parent === t) {
          return false;
        }
        if (e) {
          return true;
        }
        if (!o.isFocused) {
          return true;
        }
        return !!r && r.parent !== t;
      }
      function Uh(t, e) {
        const n = Hh.get(t);
        const o = [];
        let i = false;
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            o.push(t);
            if (Zh(e, t, r)) {
              i = true;
            }
          }
        }
        for (const [t, r] of n) {
          if (r.isDirectHost) {
            continue;
          }
          const n = Jh(t);
          if (!n) {
            continue;
          }
          if (o.includes(n)) {
            continue;
          }
          r.hostElement = n;
          if (Zh(e, t, r)) {
            i = true;
          }
        }
        return i;
      }
      function Zh(t, e, n) {
        const { text: o, isDirectHost: i, hostElement: r } = n;
        let s = false;
        if (r.getAttribute('data-placeholder') !== o) {
          t.setAttribute('data-placeholder', o, r);
          s = true;
        }
        const a = i || e.childCount == 1;
        if (a && Kh(r, n.keepOnFocus)) {
          if (Wh(t, r)) {
            s = true;
          }
        } else if (Gh(t, r)) {
          s = true;
        }
        return s;
      }
      function Jh(t) {
        if (t.childCount) {
          const e = t.getChild(0);
          if (
            e.is('element') &&
            !e.is('uiElement') &&
            !e.is('attributeElement')
          ) {
            return e;
          }
        }
        return null;
      }
      function Yh() {
        if (!jh) {
          R('enableplaceholder-deprecated-text-option');
        }
        jh = true;
      }
      class Qh {
        is() {
          throw new Error('is() method is abstract');
        }
      }
      var Xh = 4;
      function tu(t) {
        return Ma(t, Xh);
      }
      const eu = tu;
      class nu extends $(Qh) {
        constructor(t) {
          super();
          this.document = t;
          this.parent = null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new B('view-node-not-found-in-parent', this);
          }
          return t;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is('rootElement');
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.index);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = Ct(e, n);
          switch (o) {
            case 'prefix':
              return true;
            case 'extension':
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t, e) {
          this.fire(`change:${t}`, e);
          if (this.parent) {
            this.parent._fireChange(t, e);
          }
        }
        toJSON() {
          const t = eu(this);
          delete t.parent;
          return t;
        }
      }
      nu.prototype.is = function (t) {
        return t === 'node' || t === 'view:node';
      };
      class ou extends nu {
        constructor(t, e) {
          super(t);
          this._textData = e;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t) {
          this._fireChange('text', this);
          this._textData = t;
        }
        isSimilar(t) {
          if (!(t instanceof ou)) {
            return false;
          }
          return this === t || this.data === t.data;
        }
        _clone() {
          return new ou(this.document, this.data);
        }
      }
      ou.prototype.is = function (t) {
        return (
          t === '$text' ||
          t === 'view:$text' ||
          t === 'text' ||
          t === 'view:text' ||
          t === 'node' ||
          t === 'view:node'
        );
      };
      class iu extends Qh {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.data.length) {
            throw new B('view-textproxy-wrong-offsetintext', this);
          }
          if (n < 0 || e + n > t.data.length) {
            throw new B('view-textproxy-wrong-length', this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this.textNode : this.parent;
          while (n !== null) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
      }
      iu.prototype.is = function (t) {
        return (
          t === '$textProxy' ||
          t === 'view:$textProxy' ||
          t === 'textProxy' ||
          t === 'view:textProxy'
        );
      };
      class ru {
        constructor(...t) {
          this._patterns = [];
          this.add(...t);
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == 'string' || e instanceof RegExp) {
              e = { name: e };
            }
            this._patterns.push(e);
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = su(e, t);
              if (n) {
                return { element: e, pattern: t, match: n };
              }
            }
          }
          return null;
        }
        matchAll(...t) {
          const e = [];
          for (const n of t) {
            for (const t of this._patterns) {
              const o = su(n, t);
              if (o) {
                e.push({ element: n, pattern: t, match: o });
              }
            }
          }
          return e.length > 0 ? e : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null;
          }
          const t = this._patterns[0];
          const e = t.name;
          return typeof t != 'function' && e && !(e instanceof RegExp)
            ? e
            : null;
        }
      }
      function su(t, e) {
        if (typeof e == 'function') {
          return e(t);
        }
        const n = {};
        if (e.name) {
          n.name = au(e.name, t.name);
          if (!n.name) {
            return null;
          }
        }
        if (e.attributes) {
          n.attributes = uu(e.attributes, t);
          if (!n.attributes) {
            return null;
          }
        }
        if (e.classes) {
          n.classes = fu(e.classes, t);
          if (!n.classes) {
            return null;
          }
        }
        if (e.styles) {
          n.styles = pu(e.styles, t);
          if (!n.styles) {
            return null;
          }
        }
        return n;
      }
      function au(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t);
        }
        return t === e;
      }
      function cu(t, e, n) {
        const o = lu(t);
        const i = Array.from(e);
        const r = [];
        o.forEach(([t, e]) => {
          i.forEach(o => {
            if (du(t, o) && hu(e, o, n)) {
              r.push(o);
            }
          });
        });
        if (!o.length || r.length < o.length) {
          return undefined;
        }
        return r;
      }
      function lu(t) {
        if (Array.isArray(t)) {
          return t.map(t => {
            if (ue(t)) {
              if (t.key === undefined || t.value === undefined) {
                R('matcher-pattern-missing-key-or-value', t);
              }
              return [t.key, t.value];
            }
            return [t, true];
          });
        }
        if (ue(t)) {
          return Object.entries(t);
        }
        return [[t, true]];
      }
      function du(t, e) {
        return t === true || t === e || (t instanceof RegExp && e.match(t));
      }
      function hu(t, e, n) {
        if (t === true) {
          return true;
        }
        const o = n(e);
        return t === o || (t instanceof RegExp && !!String(o).match(t));
      }
      function uu(t, e) {
        const n = new Set(e.getAttributeKeys());
        if (ue(t)) {
          if (t.style !== undefined) {
            R('matcher-pattern-deprecated-attributes-style-key', t);
          }
          if (t.class !== undefined) {
            R('matcher-pattern-deprecated-attributes-class-key', t);
          }
        } else {
          n.delete('style');
          n.delete('class');
        }
        return cu(t, n, t => e.getAttribute(t));
      }
      function fu(t, e) {
        return cu(t, e.getClassNames(), () => {});
      }
      function pu(t, e) {
        return cu(t, e.getStyleNames(true), t => e.getStyle(t));
      }
      var gu = '[object Symbol]';
      function mu(t) {
        return typeof t == 'symbol' || (Jt(t) && Gt(t) == gu);
      }
      const ku = mu;
      var bu = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        wu = /^\w*$/;
      function _u(t, e) {
        if (Ut(t)) {
          return false;
        }
        var n = typeof t;
        if (
          n == 'number' ||
          n == 'symbol' ||
          n == 'boolean' ||
          t == null ||
          ku(t)
        ) {
          return true;
        }
        return wu.test(t) || !bu.test(t) || (e != null && t in Object(e));
      }
      const vu = _u;
      var Au = 'Expected a function';
      function Cu(t, e) {
        if (typeof t != 'function' || (e != null && typeof e != 'function')) {
          throw new TypeError(Au);
        }
        var n = function () {
          var o = arguments,
            i = e ? e.apply(this, o) : o[0],
            r = n.cache;
          if (r.has(i)) {
            return r.get(i);
          }
          var s = t.apply(this, o);
          n.cache = r.set(i, s) || r;
          return s;
        };
        n.cache = new (Cu.Cache || Yn)();
        return n;
      }
      Cu.Cache = Yn;
      const yu = Cu;
      var xu = 500;
      function Eu(t) {
        var e = yu(t, function (t) {
          if (n.size === xu) {
            n.clear();
          }
          return t;
        });
        var n = e.cache;
        return e;
      }
      const Du = Eu;
      var Tu =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var Su = /\\(\\)?/g;
      var Pu = Du(function (t) {
        var e = [];
        if (t.charCodeAt(0) === 46) {
          e.push('');
        }
        t.replace(Tu, function (t, n, o, i) {
          e.push(o ? i.replace(Su, '$1') : n || t);
        });
        return e;
      });
      const Bu = Pu;
      function Ru(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = Array(o);
        while (++n < o) {
          i[n] = e(t[n], n, t);
        }
        return i;
      }
      const Ou = Ru;
      var Iu = 1 / 0;
      var Mu = Bt ? Bt.prototype : undefined,
        Vu = Mu ? Mu.toString : undefined;
      function zu(t) {
        if (typeof t == 'string') {
          return t;
        }
        if (Ut(t)) {
          return Ou(t, zu) + '';
        }
        if (ku(t)) {
          return Vu ? Vu.call(t) : '';
        }
        var e = t + '';
        return e == '0' && 1 / t == -Iu ? '-0' : e;
      }
      const Fu = zu;
      function Nu(t) {
        return t == null ? '' : Fu(t);
      }
      const Lu = Nu;
      function Hu(t, e) {
        if (Ut(t)) {
          return t;
        }
        return vu(t, e) ? [t] : Bu(Lu(t));
      }
      const ju = Hu;
      function qu(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : undefined;
      }
      const $u = qu;
      var Wu = 1 / 0;
      function Gu(t) {
        if (typeof t == 'string' || ku(t)) {
          return t;
        }
        var e = t + '';
        return e == '0' && 1 / t == -Wu ? '-0' : e;
      }
      const Ku = Gu;
      function Uu(t, e) {
        e = ju(e, t);
        var n = 0,
          o = e.length;
        while (t != null && n < o) {
          t = t[Ku(e[n++])];
        }
        return n && n == o ? t : undefined;
      }
      const Zu = Uu;
      function Ju(t, e, n) {
        var o = -1,
          i = t.length;
        if (e < 0) {
          e = -e > i ? 0 : i + e;
        }
        n = n > i ? i : n;
        if (n < 0) {
          n += i;
        }
        i = e > n ? 0 : (n - e) >>> 0;
        e >>>= 0;
        var r = Array(i);
        while (++o < i) {
          r[o] = t[o + e];
        }
        return r;
      }
      const Yu = Ju;
      function Qu(t, e) {
        return e.length < 2 ? t : Zu(t, Yu(e, 0, -1));
      }
      const Xu = Qu;
      function tf(t, e) {
        e = ju(e, t);
        t = Xu(t, e);
        return t == null || delete t[Ku($u(e))];
      }
      const ef = tf;
      function nf(t, e) {
        return t == null ? true : ef(t, e);
      }
      const of = nf;
      function rf(t, e, n) {
        var o = t == null ? undefined : Zu(t, e);
        return o === undefined ? n : o;
      }
      const sf = rf;
      function af(t, e, n) {
        if (
          (n !== undefined && !me(t[e], n)) ||
          (n === undefined && !(e in t))
        ) {
          co(t, e, n);
        }
      }
      const cf = af;
      function lf(t) {
        return function (e, n, o) {
          var i = -1,
            r = Object(e),
            s = o(e),
            a = s.length;
          while (a--) {
            var c = s[t ? a : ++i];
            if (n(r[c], c, r) === false) {
              break;
            }
          }
          return e;
        };
      }
      const df = lf;
      var hf = df();
      const uf = hf;
      function ff(t) {
        return Jt(t) && Li(t);
      }
      const pf = ff;
      function gf(t, e) {
        if (e === 'constructor' && typeof t[e] === 'function') {
          return;
        }
        if (e == '__proto__') {
          return;
        }
        return t[e];
      }
      const mf = gf;
      function kf(t) {
        return go(t, Qi(t));
      }
      const bf = kf;
      function wf(t, e, n, o, i, r, s) {
        var a = mf(t, n),
          c = mf(e, n),
          l = s.get(c);
        if (l) {
          cf(t, n, l);
          return;
        }
        var d = r ? r(a, c, n + '', t, e, s) : undefined;
        var h = d === undefined;
        if (h) {
          var u = Ut(c),
            f = !u && Io(c),
            p = !u && !f && xi(c);
          d = c;
          if (u || f || p) {
            if (Ut(a)) {
              d = a;
            } else if (pf(a)) {
              d = lr(a);
            } else if (f) {
              h = false;
              d = ar(c, true);
            } else if (p) {
              h = false;
              d = ws(c, true);
            } else {
              d = [];
            }
          } else if (ue(c) || xo(c)) {
            d = a;
            if (xo(a)) {
              d = bf(a);
            } else if (!ot(a) || $e(a)) {
              d = Ws(c);
            }
          } else {
            h = false;
          }
        }
        if (h) {
          s.set(c, d);
          i(d, c, o, r, s);
          s['delete'](c);
        }
        cf(t, n, d);
      }
      const _f = wf;
      function vf(t, e, n, o, i) {
        if (t === e) {
          return;
        }
        uf(
          e,
          function (r, s) {
            i || (i = new no());
            if (ot(r)) {
              _f(t, e, s, n, vf, o, i);
            } else {
              var a = o ? o(mf(t, s), r, s + '', t, e, i) : undefined;
              if (a === undefined) {
                a = r;
              }
              cf(t, s, a);
            }
          },
          Qi,
        );
      }
      const Af = vf;
      function Cf(t) {
        return t;
      }
      const yf = Cf;
      function xf(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      }
      const Ef = xf;
      var Df = Math.max;
      function Tf(t, e, n) {
        e = Df(e === undefined ? t.length - 1 : e, 0);
        return function () {
          var o = arguments,
            i = -1,
            r = Df(o.length - e, 0),
            s = Array(r);
          while (++i < r) {
            s[i] = o[e + i];
          }
          i = -1;
          var a = Array(e + 1);
          while (++i < e) {
            a[i] = o[i];
          }
          a[e] = n(s);
          return Ef(t, this, a);
        };
      }
      const Sf = Tf;
      function Pf(t) {
        return function () {
          return t;
        };
      }
      const Bf = Pf;
      var Rf = !so
        ? yf
        : function (t, e) {
            return so(t, 'toString', {
              configurable: true,
              enumerable: false,
              value: Bf(e),
              writable: true,
            });
          };
      const Of = Rf;
      var If = 800,
        Mf = 16;
      var Vf = Date.now;
      function zf(t) {
        var e = 0,
          n = 0;
        return function () {
          var o = Vf(),
            i = Mf - (o - n);
          n = o;
          if (i > 0) {
            if (++e >= If) {
              return arguments[0];
            }
          } else {
            e = 0;
          }
          return t.apply(undefined, arguments);
        };
      }
      const Ff = zf;
      var Nf = Ff(Of);
      const Lf = Nf;
      function Hf(t, e) {
        return Lf(Sf(t, e, yf), t + '');
      }
      const jf = Hf;
      function qf(t, e, n) {
        if (!ot(n)) {
          return false;
        }
        var o = typeof e;
        if (
          o == 'number' ? Li(n) && Fo(e, n.length) : o == 'string' && e in n
        ) {
          return me(n[e], t);
        }
        return false;
      }
      const $f = qf;
      function Wf(t) {
        return jf(function (e, n) {
          var o = -1,
            i = n.length,
            r = i > 1 ? n[i - 1] : undefined,
            s = i > 2 ? n[2] : undefined;
          r = t.length > 3 && typeof r == 'function' ? (i--, r) : undefined;
          if (s && $f(n[0], n[1], s)) {
            r = i < 3 ? undefined : r;
            i = 1;
          }
          e = Object(e);
          while (++o < i) {
            var a = n[o];
            if (a) {
              t(e, a, o, r);
            }
          }
          return e;
        });
      }
      const Gf = Wf;
      var Kf = Gf(function (t, e, n) {
        Af(t, e, n);
      });
      const Uf = Kf;
      function Zf(t, e, n, o) {
        if (!ot(t)) {
          return t;
        }
        e = ju(e, t);
        var i = -1,
          r = e.length,
          s = r - 1,
          a = t;
        while (a != null && ++i < r) {
          var c = Ku(e[i]),
            l = n;
          if (c === '__proto__' || c === 'constructor' || c === 'prototype') {
            return t;
          }
          if (i != s) {
            var d = a[c];
            l = o ? o(d, c, a) : undefined;
            if (l === undefined) {
              l = ot(d) ? d : Fo(e[i + 1]) ? [] : {};
            }
          }
          fo(a, c, l);
          a = a[c];
        }
        return t;
      }
      const Jf = Zf;
      function Yf(t, e, n) {
        return t == null ? t : Jf(t, e, n);
      }
      const Qf = Yf;
      class Xf {
        constructor(t) {
          this._styles = {};
          this._styleProcessor = t;
        }
        get isEmpty() {
          const t = Object.entries(this._styles);
          return !t.length;
        }
        get size() {
          if (this.isEmpty) {
            return 0;
          }
          return this.getStyleNames().length;
        }
        setTo(t) {
          this.clear();
          const e = ep(t);
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false;
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          return Array.isArray(n);
        }
        set(t, e) {
          if (ot(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles);
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
        }
        remove(t) {
          const e = np(t);
          of(this._styles, e);
          delete this._styles[t];
          this._cleanEmptyObjectsOnPath(e);
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles);
        }
        toString() {
          if (this.isEmpty) {
            return '';
          }
          return (
            this._getStylesEntries()
              .map(t => t.join(':'))
              .sort()
              .join(';') + ';'
          );
        }
        getAsString(t) {
          if (this.isEmpty) {
            return;
          }
          if (this._styles[t] && !ot(this._styles[t])) {
            return this._styles[t];
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          if (Array.isArray(n)) {
            return n[1];
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return [];
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles);
          }
          const e = this._getStylesEntries();
          return e.map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t = [];
          const e = Object.keys(this._styles);
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles));
          }
          return t;
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split('.');
          const n = e.length > 1;
          if (!n) {
            return;
          }
          const o = e.splice(0, e.length - 1).join('.');
          const i = sf(this._styles, o);
          if (!i) {
            return;
          }
          const r = !Object.keys(i).length;
          if (r) {
            this.remove(o);
          }
        }
      }
      class tp {
        constructor() {
          this._normalizers = new Map();
          this._extractors = new Map();
          this._reducers = new Map();
          this._consumables = new Map();
        }
        toNormalizedForm(t, e, n) {
          if (ot(e)) {
            op(n, np(t), e);
            return;
          }
          if (this._normalizers.has(t)) {
            const o = this._normalizers.get(t);
            const { path: i, value: r } = o(e);
            op(n, i, r);
          } else {
            op(n, t, e);
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return Uf({}, e);
          }
          if (e[t] !== undefined) {
            return e[t];
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t);
            if (typeof n === 'string') {
              return sf(e, n);
            }
            const o = n(t, e);
            if (o) {
              return o;
            }
          }
          return sf(e, np(t));
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e);
          if (n === undefined) {
            return [];
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t);
            return e(n);
          }
          return [[t, n]];
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter(e => {
            const n = this.getNormalized(e, t);
            if (n && typeof n == 'object') {
              return Object.keys(n).length;
            }
            return n;
          });
          const n = new Set([...e, ...Object.keys(t)]);
          return Array.from(n);
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || [];
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e);
        }
        setExtractor(t, e) {
          this._extractors.set(t, e);
        }
        setReducer(t, e) {
          this._reducers.set(t, e);
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e);
          for (const n of e) {
            this._mapStyleNames(n, [t]);
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, []);
          }
          this._consumables.get(t).push(...e);
        }
      }
      function ep(t) {
        let e = null;
        let n = 0;
        let o = 0;
        let i = null;
        const r = new Map();
        if (t === '') {
          return r;
        }
        if (t.charAt(t.length - 1) != ';') {
          t = t + ';';
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s);
          if (e === null) {
            switch (a) {
              case ':':
                if (!i) {
                  i = t.substr(n, s - n);
                  o = s + 1;
                }
                break;
              case '"':
              case "'":
                e = a;
                break;
              case ';': {
                const e = t.substr(o, s - o);
                if (i) {
                  r.set(i.trim(), e.trim());
                }
                i = null;
                n = s + 1;
                break;
              }
            }
          } else if (a === e) {
            e = null;
          }
        }
        return r;
      }
      function np(t) {
        return t.replace('-', '.');
      }
      function op(t, e, n) {
        let o = n;
        if (ot(n)) {
          o = Uf({}, sf(t, e), n);
        }
        Qf(t, e, o);
      }
      class ip extends nu {
        constructor(t, e, n, o) {
          super(t);
          this._unsafeAttributesToRender = [];
          this._customProperties = new Map();
          this.name = e;
          this._attrs = rp(n);
          this._children = [];
          if (o) {
            this._insertChild(0, o);
          }
          this._classes = new Set();
          if (this._attrs.has('class')) {
            const t = this._attrs.get('class');
            sp(this._classes, t);
            this._attrs.delete('class');
          }
          this._styles = new Xf(this.document.stylesProcessor);
          if (this._attrs.has('style')) {
            this._styles.setTo(this._attrs.get('style'));
            this._attrs.delete('style');
          }
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield 'class';
          }
          if (!this._styles.isEmpty) {
            yield 'style';
          }
          yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries();
          if (this._classes.size > 0) {
            yield ['class', this.getAttribute('class')];
          }
          if (!this._styles.isEmpty) {
            yield ['style', this.getAttribute('style')];
          }
        }
        getAttribute(t) {
          if (t == 'class') {
            if (this._classes.size > 0) {
              return [...this._classes].join(' ');
            }
            return undefined;
          }
          if (t == 'style') {
            const t = this._styles.toString();
            return t == '' ? undefined : t;
          }
          return this._attrs.get(t);
        }
        hasAttribute(t) {
          if (t == 'class') {
            return this._classes.size > 0;
          }
          if (t == 'style') {
            return !this._styles.isEmpty;
          }
          return this._attrs.has(t);
        }
        isSimilar(t) {
          if (!(t instanceof ip)) {
            return false;
          }
          if (this === t) {
            return true;
          }
          if (this.name != t.name) {
            return false;
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false;
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false;
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false;
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (
              !t._styles.has(e) ||
              t._styles.getAsString(e) !== this._styles.getAsString(e)
            ) {
              return false;
            }
          }
          return true;
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false;
            }
          }
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t) {
          return this._styles.getAsString(t);
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t);
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t);
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false;
            }
          }
          return true;
        }
        findAncestor(...t) {
          const e = new ru(...t);
          let n = this.parent;
          while (n && !n.is('documentFragment')) {
            if (e.match(n)) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(',');
          const e = this._styles.toString();
          const n = Array.from(this._attrs)
            .map(t => `${t[0]}="${t[1]}"`)
            .sort()
            .join(' ');
          return (
            this.name +
            (t == '' ? '' : ` class="${t}"`) +
            (!e ? '' : ` style="${e}"`) +
            (n == '' ? '' : ` ${n}`)
          );
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t);
        }
        _clone(t = false) {
          const e = [];
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t));
            }
          }
          const n = new this.constructor(
            this.document,
            this.name,
            this._attrs,
            e,
          );
          n._classes = new Set(this._classes);
          n._styles.set(this._styles.getNormalized());
          n._customProperties = new Map(this._customProperties);
          n.getFillerOffset = this.getFillerOffset;
          n._unsafeAttributesToRender = this._unsafeAttributesToRender;
          return n;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          this._fireChange('children', this);
          let n = 0;
          const o = ap(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            e.document = this.document;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _setAttribute(t, e) {
          const n = String(e);
          this._fireChange('attributes', this);
          if (t == 'class') {
            sp(this._classes, n);
          } else if (t == 'style') {
            this._styles.setTo(n);
          } else {
            this._attrs.set(t, n);
          }
        }
        _removeAttribute(t) {
          this._fireChange('attributes', this);
          if (t == 'class') {
            if (this._classes.size > 0) {
              this._classes.clear();
              return true;
            }
            return false;
          }
          if (t == 'style') {
            if (!this._styles.isEmpty) {
              this._styles.clear();
              return true;
            }
            return false;
          }
          return this._attrs.delete(t);
        }
        _addClass(t) {
          this._fireChange('attributes', this);
          for (const e of tl(t)) {
            this._classes.add(e);
          }
        }
        _removeClass(t) {
          this._fireChange('attributes', this);
          for (const e of tl(t)) {
            this._classes.delete(e);
          }
        }
        _setStyle(t, e) {
          this._fireChange('attributes', this);
          if (typeof t != 'string') {
            this._styles.set(t);
          } else {
            this._styles.set(t, e);
          }
        }
        _removeStyle(t) {
          this._fireChange('attributes', this);
          for (const e of tl(t)) {
            this._styles.remove(e);
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      ip.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return e === this.name && (t === 'element' || t === 'view:element');
        }
      };
      function rp(t) {
        const e = gl(t);
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t);
          } else if (typeof n != 'string') {
            e.set(t, String(n));
          }
        }
        return e;
      }
      function sp(t, e) {
        const n = e.split(/\s+/);
        t.clear();
        n.forEach(e => t.add(e));
      }
      function ap(t, e) {
        if (typeof e == 'string') {
          return [new ou(t, e)];
        }
        if (!yt(e)) {
          e = [e];
        }
        return Array.from(e).map(e => {
          if (typeof e == 'string') {
            return new ou(t, e);
          }
          if (e instanceof iu) {
            return new ou(t, e.data);
          }
          return e;
        });
      }
      class cp extends ip {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = lp;
        }
      }
      cp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function lp() {
        const t = [...this.getChildren()];
        const e = t[this.childCount - 1];
        if (e && e.is('element', 'br')) {
          return this.childCount;
        }
        for (const e of t) {
          if (!e.is('uiElement')) {
            return null;
          }
        }
        return this.childCount;
      }
      class dp extends dt(cp) {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.set('isReadOnly', false);
          this.set('isFocused', false);
          this.set('placeholder', undefined);
          this.bind('isReadOnly').to(t);
          this.bind('isFocused').to(
            t,
            'isFocused',
            e => e && t.selection.editableElement == this,
          );
          this.listenTo(t.selection, 'change', () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      dp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      const hp = Symbol('rootName');
      class up extends dp {
        constructor(t, e) {
          super(t, e);
          this.rootName = 'main';
        }
        get rootName() {
          return this.getCustomProperty(hp);
        }
        set rootName(t) {
          this._setCustomProperty(hp, t);
        }
        set _name(t) {
          this.name = t;
        }
      }
      up.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'view:rootElement' ||
            t === 'editableElement' ||
            t === 'view:editableElement' ||
            t === 'containerElement' ||
            t === 'view:containerElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'rootElement' ||
              t === 'view:rootElement' ||
              t === 'editableElement' ||
              t === 'view:editableElement' ||
              t === 'containerElement' ||
              t === 'view:containerElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      class fp {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new B('view-tree-walker-no-start-position', null);
          }
          if (
            t.direction &&
            t.direction != 'forward' &&
            t.direction != 'backward'
          ) {
            throw new B('view-tree-walker-unknown-direction', t.startPosition, {
              direction: t.direction,
            });
          }
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this._position = pp._createAt(t.startPosition);
          } else {
            this._position = pp._createAt(
              t.boundaries[t.direction == 'backward' ? 'end' : 'start'],
            );
          }
          this.direction = t.direction || 'forward';
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t) {
          let e;
          let n;
          do {
            n = this.position;
            e = this.next();
          } while (!e.done && t(e.value));
          if (!e.done) {
            this._position = n;
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            t.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          let o;
          if (n instanceof ou) {
            if (t.isAtEnd) {
              this._position = pp._createAfter(n);
              return this._next();
            }
            o = n.data[t.offset];
          } else {
            o = n.getChild(t.offset);
          }
          if (o instanceof ip) {
            if (!this.shallow) {
              t = new pp(o, 0);
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(t)) {
                return { done: true, value: undefined };
              }
              t.offset++;
            }
            this._position = t;
            return this._formatReturnValue('elementStart', o, e, t, 1);
          }
          if (o instanceof ou) {
            if (this.singleCharacters) {
              t = new pp(o, 0);
              this._position = t;
              return this._next();
            }
            let n = o.data.length;
            let i;
            if (o == this._boundaryEndParent) {
              n = this.boundaries.end.offset;
              i = new iu(o, 0, n);
              t = pp._createAfter(i);
            } else {
              i = new iu(o, 0, o.data.length);
              t.offset++;
            }
            this._position = t;
            return this._formatReturnValue('text', i, e, t, n);
          }
          if (typeof o == 'string') {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              const e =
                n === this._boundaryEndParent
                  ? this.boundaries.end.offset
                  : n.data.length;
              o = e - t.offset;
            }
            const i = new iu(n, t.offset, o);
            t.offset += o;
            this._position = t;
            return this._formatReturnValue('text', i, e, t, o);
          }
          t = pp._createAfter(n);
          this._position = t;
          if (this.ignoreElementEnd) {
            return this._next();
          }
          return this._formatReturnValue('elementEnd', n, e, t);
        }
        _previous() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            t.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          let o;
          if (n instanceof ou) {
            if (t.isAtStart) {
              this._position = pp._createBefore(n);
              return this._previous();
            }
            o = n.data[t.offset - 1];
          } else {
            o = n.getChild(t.offset - 1);
          }
          if (o instanceof ip) {
            if (this.shallow) {
              t.offset--;
              this._position = t;
              return this._formatReturnValue('elementStart', o, e, t, 1);
            }
            t = new pp(o, o.childCount);
            this._position = t;
            if (this.ignoreElementEnd) {
              return this._previous();
            }
            return this._formatReturnValue('elementEnd', o, e, t);
          }
          if (o instanceof ou) {
            if (this.singleCharacters) {
              t = new pp(o, o.data.length);
              this._position = t;
              return this._previous();
            }
            let n = o.data.length;
            let i;
            if (o == this._boundaryStartParent) {
              const e = this.boundaries.start.offset;
              i = new iu(o, e, o.data.length - e);
              n = i.data.length;
              t = pp._createBefore(i);
            } else {
              i = new iu(o, 0, o.data.length);
              t.offset--;
            }
            this._position = t;
            return this._formatReturnValue('text', i, e, t, n);
          }
          if (typeof o == 'string') {
            let o;
            if (!this.singleCharacters) {
              const e =
                n === this._boundaryStartParent
                  ? this.boundaries.start.offset
                  : 0;
              o = t.offset - e;
            } else {
              o = 1;
            }
            t.offset -= o;
            const i = new iu(n, t.offset, o);
            this._position = t;
            return this._formatReturnValue('text', i, e, t, o);
          }
          t = pp._createBefore(n);
          this._position = t;
          return this._formatReturnValue('elementStart', n, e, t, 1);
        }
        _formatReturnValue(t, e, n, o, i) {
          if (e instanceof iu) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (
                this.direction == 'forward' &&
                !(this.boundaries && this.boundaries.end.isEqual(this.position))
              ) {
                o = pp._createAfter(e.textNode);
                this._position = o;
              } else {
                n = pp._createAfter(e.textNode);
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == 'backward' &&
                !(
                  this.boundaries &&
                  this.boundaries.start.isEqual(this.position)
                )
              ) {
                o = pp._createBefore(e.textNode);
                this._position = o;
              } else {
                n = pp._createBefore(e.textNode);
              }
            }
          }
          return {
            done: false,
            value: {
              type: t,
              item: e,
              previousPosition: n,
              nextPosition: o,
              length: i,
            },
          };
        }
      }
      class pp extends Qh {
        constructor(t, e) {
          super();
          this.parent = t;
          this.offset = e;
        }
        get nodeAfter() {
          if (this.parent.is('$text')) {
            return null;
          }
          return this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          if (this.parent.is('$text')) {
            return null;
          }
          return this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const t = this.parent.is('$text')
            ? this.parent.data.length
            : this.parent.childCount;
          return this.offset === t;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t = this.parent;
          while (!(t instanceof dp)) {
            if (t.parent) {
              t = t.parent;
            } else {
              return null;
            }
          }
          return t;
        }
        getShiftedBy(t) {
          const e = pp._createAt(this);
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new fp(e);
          n.skip(t);
          return n.position;
        }
        getAncestors() {
          if (this.parent.is('documentFragment')) {
            return [this.parent];
          } else {
            return this.parent.getAncestors({ includeSelf: true });
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset;
        }
        isBefore(t) {
          return this.compareWith(t) == 'before';
        }
        isAfter(t) {
          return this.compareWith(t) == 'after';
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return 'different';
          }
          if (this.isEqual(t)) {
            return 'same';
          }
          const e = this.parent.is('node') ? this.parent.getPath() : [];
          const n = t.parent.is('node') ? t.parent.getPath() : [];
          e.push(this.offset);
          n.push(t.offset);
          const o = Ct(e, n);
          switch (o) {
            case 'prefix':
              return 'before';
            case 'extension':
              return 'after';
            default:
              return e[o] < n[o] ? 'before' : 'after';
          }
        }
        getWalker(t = {}) {
          t.startPosition = this;
          return new fp(t);
        }
        clone() {
          return new pp(this.parent, this.offset);
        }
        static _createAt(t, e) {
          if (t instanceof pp) {
            return new this(t.parent, t.offset);
          } else {
            const n = t;
            if (e == 'end') {
              e = n.is('$text') ? n.data.length : n.childCount;
            } else if (e == 'before') {
              return this._createBefore(n);
            } else if (e == 'after') {
              return this._createAfter(n);
            } else if (e !== 0 && !e) {
              throw new B('view-createpositionat-offset-required', n);
            }
            return new pp(n, e);
          }
        }
        static _createAfter(t) {
          if (t.is('$textProxy')) {
            return new pp(t.textNode, t.offsetInText + t.data.length);
          }
          if (!t.parent) {
            throw new B('view-position-after-root', t, { root: t });
          }
          return new pp(t.parent, t.index + 1);
        }
        static _createBefore(t) {
          if (t.is('$textProxy')) {
            return new pp(t.textNode, t.offsetInText);
          }
          if (!t.parent) {
            throw new B('view-position-before-root', t, { root: t });
          }
          return new pp(t.parent, t.index);
        }
      }
      pp.prototype.is = function (t) {
        return t === 'position' || t === 'view:position';
      };
      class gp extends Qh {
        constructor(t, e = null) {
          super();
          this.start = t.clone();
          this.end = e ? e.clone() : t.clone();
        }
        *[Symbol.iterator]() {
          yield* new fp({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(mp, {
            direction: 'backward',
          });
          let e = this.end.getLastMatchingPosition(mp);
          if (t.parent.is('$text') && t.isAtStart) {
            t = pp._createBefore(t.parent);
          }
          if (e.parent.is('$text') && e.isAtEnd) {
            e = pp._createAfter(e.parent);
          }
          return new gp(t, e);
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(mp);
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new gp(t, t);
          }
          let e = this.end.getLastMatchingPosition(mp, {
            direction: 'backward',
          });
          const n = t.nodeAfter;
          const o = e.nodeBefore;
          if (n && n.is('$text')) {
            t = new pp(n, 0);
          }
          if (o && o.is('$text')) {
            e = new pp(o, o.data.length);
          }
          return new gp(t, e);
        }
        isEqual(t) {
          return (
            this == t ||
            (this.start.isEqual(t.start) && this.end.isEqual(t.end))
          );
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const o =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new gp(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new gp(t.end, this.end));
            }
          } else {
            e.push(this.clone());
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new gp(e, n);
          }
          return null;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new fp(t);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          let t = this.start.nodeAfter;
          let e = this.end.nodeBefore;
          if (
            this.start.parent.is('$text') &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling;
          }
          if (
            this.end.parent.is('$text') &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling;
          }
          if (t && t.is('element') && t === e) {
            return t;
          }
          return null;
        }
        clone() {
          return new gp(this.start, this.end);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new fp(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new fp(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        static _createFromParentsAndOffsets(t, e, n, o) {
          return new this(new pp(t, e), new pp(n, o));
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
        }
        static _createOn(t) {
          const e = t.is('$textProxy') ? t.offsetSize : 1;
          return this._createFromPositionAndShift(pp._createBefore(t), e);
        }
      }
      gp.prototype.is = function (t) {
        return t === 'range' || t === 'view:range';
      };
      function mp(t) {
        if (t.item.is('attributeElement') || t.item.is('uiElement')) {
          return true;
        }
        return false;
      }
      class kp extends $(Qh) {
        constructor(...t) {
          super();
          this._ranges = [];
          this._lastRangeBackward = false;
          this._isFake = false;
          this._fakeSelectionLabel = '';
          if (t.length) {
            this.setTo(...t);
          }
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.end : t.start;
          return e.clone();
        }
        get focus() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.start : t.end;
          return e.clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement;
          }
          return null;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone();
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false;
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false;
          }
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false;
          }
          const e = At(this.getRanges());
          const n = At(t.getRanges());
          if (e != n) {
            return false;
          }
          if (e == 0) {
            return true;
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed();
            let n = false;
            for (let o of t.getRanges()) {
              o = o.getTrimmed();
              if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        setTo(...t) {
          let [e, n, o] = t;
          if (typeof n == 'object') {
            o = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
            this._setFakeOptions(o);
          } else if (e instanceof kp || e instanceof bp) {
            this._setRanges(e.getRanges(), e.isBackward);
            this._setFakeOptions({
              fake: e.isFake,
              label: e.fakeSelectionLabel,
            });
          } else if (e instanceof gp) {
            this._setRanges([e], o && o.backward);
            this._setFakeOptions(o);
          } else if (e instanceof pp) {
            this._setRanges([new gp(e)]);
            this._setFakeOptions(o);
          } else if (e instanceof nu) {
            const t = !!o && !!o.backward;
            let i;
            if (n === undefined) {
              throw new B(
                'view-selection-setto-required-second-parameter',
                this,
              );
            } else if (n == 'in') {
              i = gp._createIn(e);
            } else if (n == 'on') {
              i = gp._createOn(e);
            } else {
              i = new gp(pp._createAt(e, n));
            }
            this._setRanges([i], t);
            this._setFakeOptions(o);
          } else if (yt(e)) {
            this._setRanges(e, o && o.backward);
            this._setFakeOptions(o);
          } else {
            throw new B('view-selection-setto-not-selectable', this);
          }
          this.fire('change');
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new B('view-selection-setfocus-no-ranges', this);
          }
          const n = pp._createAt(t, e);
          if (n.compareWith(this.focus) == 'same') {
            return;
          }
          const o = this.anchor;
          this._ranges.pop();
          if (n.compareWith(o) == 'before') {
            this._addRange(new gp(n, o), true);
          } else {
            this._addRange(new gp(o, n));
          }
          this.fire('change');
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          this._ranges = [];
          for (const e of t) {
            this._addRange(e);
          }
          this._lastRangeBackward = !!e;
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake;
          this._fakeSelectionLabel = t.fake ? t.label || '' : '';
        }
        _addRange(t, e = false) {
          if (!(t instanceof gp)) {
            throw new B('view-selection-add-range-not-range', this);
          }
          this._pushRange(t);
          this._lastRangeBackward = !!e;
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new B('view-selection-range-intersects', this, {
                addedRange: t,
                intersectingRange: e,
              });
            }
          }
          this._ranges.push(new gp(t.start, t.end));
        }
      }
      kp.prototype.is = function (t) {
        return t === 'selection' || t === 'view:selection';
      };
      class bp extends $(Qh) {
        constructor(...t) {
          super();
          this._selection = new kp();
          this._selection.delegate('change').to(this);
          if (t.length) {
            this._selection.setTo(...t);
          }
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t) {
          return this._selection.isEqual(t);
        }
        isSimilar(t) {
          return this._selection.isSimilar(t);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
      }
      bp.prototype.is = function (t) {
        return (
          t === 'selection' ||
          t == 'documentSelection' ||
          t == 'view:selection' ||
          t == 'view:documentSelection'
        );
      };
      class wp extends y {
        constructor(t, e, n) {
          super(t, e);
          this.startRange = n;
          this._eventPhase = 'none';
          this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const _p = Symbol('bubbling contexts');
      function vp(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof y ? t : new y(this, t);
              const o = xp(this);
              if (!o.size) {
                return;
              }
              Ap(n, 'capturing', this);
              if (Cp(o, '$capture', n, ...e)) {
                return n.return;
              }
              const i = n.startRange || this.selection.getFirstRange();
              const r = i ? i.getContainedElement() : null;
              const s = r ? Boolean(yp(o, r)) : false;
              let a = r || Ep(i);
              Ap(n, 'atTarget', a);
              if (!s) {
                if (Cp(o, '$text', n, ...e)) {
                  return n.return;
                }
                Ap(n, 'bubbling', a);
              }
              while (a) {
                if (a.is('rootElement')) {
                  if (Cp(o, '$root', n, ...e)) {
                    return n.return;
                  }
                } else if (a.is('element')) {
                  if (Cp(o, a.name, n, ...e)) {
                    return n.return;
                  }
                }
                if (Cp(o, a, n, ...e)) {
                  return n.return;
                }
                a = a.parent;
                Ap(n, 'bubbling', a);
              }
              Ap(n, 'bubbling', this);
              Cp(o, '$document', n, ...e);
              return n.return;
            } catch (t) {
              B.rethrowUnexpectedError(t, this);
            }
          }
          _addEventListener(t, e, n) {
            const o = tl(n.context || '$document');
            const i = xp(this);
            for (const r of o) {
              let o = i.get(r);
              if (!o) {
                o = new ($())();
                i.set(r, o);
              }
              this.listenTo(o, t, e, n);
            }
          }
          _removeEventListener(t, e) {
            const n = xp(this);
            for (const o of n.values()) {
              this.stopListening(o, t, e);
            }
          }
        }
        return e;
      }
      {
        const t = vp(Object);
        ['fire', '_addEventListener', '_removeEventListener'].forEach(e => {
          vp[e] = t.prototype[e];
        });
      }
      function Ap(t, e, n) {
        if (t instanceof wp) {
          t._eventPhase = e;
          t._currentTarget = n;
        }
      }
      function Cp(t, e, n, ...o) {
        const i = typeof e == 'string' ? t.get(e) : yp(t, e);
        if (!i) {
          return false;
        }
        i.fire(n, ...o);
        return n.stop.called;
      }
      function yp(t, e) {
        for (const [n, o] of t) {
          if (typeof n == 'function' && n(e)) {
            return o;
          }
        }
        return null;
      }
      function xp(t) {
        if (!t[_p]) {
          t[_p] = new Map();
        }
        return t[_p];
      }
      function Ep(t) {
        if (!t) {
          return null;
        }
        const e = t.start.parent;
        const n = t.end.parent;
        const o = e.getPath();
        const i = n.getPath();
        return o.length > i.length ? e : n;
      }
      class Dp extends vp(dt()) {
        constructor(t) {
          super();
          this._postFixers = new Set();
          this.selection = new bp();
          this.roots = new dl({ idProperty: 'rootName' });
          this.stylesProcessor = t;
          this.set('isReadOnly', false);
          this.set('isFocused', false);
          this.set('isSelecting', false);
          this.set('isComposing', false);
        }
        getRoot(t = 'main') {
          return this.roots.get(t);
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        destroy() {
          this.roots.forEach(t => t.destroy());
          this.stopListening();
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      const Tp = 10;
      class Sp extends ip {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this._priority = Tp;
          this._id = null;
          this._clonesGroup = null;
          this.getFillerOffset = Pp;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new B(
              'attribute-element-get-elements-with-same-id-no-id',
              this,
            );
          }
          return new Set(this._clonesGroup);
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id;
          }
          return super.isSimilar(t) && this.priority == t.priority;
        }
        _clone(t = false) {
          const e = super._clone(t);
          e._priority = this._priority;
          e._id = this._id;
          return e;
        }
      }
      Sp.DEFAULT_PRIORITY = Tp;
      Sp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'attributeElement' ||
            t === 'view:attributeElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'attributeElement' ||
              t === 'view:attributeElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Pp() {
        if (Bp(this)) {
          return null;
        }
        let t = this.parent;
        while (t && t.is('attributeElement')) {
          if (Bp(t) > 1) {
            return null;
          }
          t = t.parent;
        }
        if (!t || Bp(t) > 1) {
          return null;
        }
        return this.childCount;
      }
      function Bp(t) {
        return Array.from(t.getChildren()).filter(t => !t.is('uiElement'))
          .length;
      }
      class Rp extends ip {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Op;
        }
        _insertChild(t, e) {
          if (e && (e instanceof nu || Array.from(e).length > 0)) {
            throw new B('view-emptyelement-cannot-add', [this, e]);
          }
          return 0;
        }
      }
      Rp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'emptyElement' ||
            t === 'view:emptyElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'emptyElement' ||
              t === 'view:emptyElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Op() {
        return null;
      }
      class Ip extends ip {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Vp;
        }
        _insertChild(t, e) {
          if (e && (e instanceof nu || Array.from(e).length > 0)) {
            throw new B('view-uielement-cannot-add', [this, e]);
          }
          return 0;
        }
        render(t, e) {
          return this.toDomElement(t);
        }
        toDomElement(t) {
          const e = t.createElement(this.name);
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t));
          }
          return e;
        }
      }
      Ip.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'uiElement' ||
            t === 'view:uiElement' ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'uiElement' ||
              t === 'view:uiElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Mp(t) {
        t.document.on('arrowKey', (e, n) => zp(e, n, t.domConverter), {
          priority: 'low',
        });
      }
      function Vp() {
        return null;
      }
      function zp(t, e, n) {
        if (e.keyCode == qc.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
          if (o || e.shiftKey) {
            const e = t.focusNode;
            const i = t.focusOffset;
            const r = n.domPositionToView(e, i);
            if (r === null) {
              return;
            }
            let s = false;
            const a = r.getLastMatchingPosition(t => {
              if (t.item.is('uiElement')) {
                s = true;
              }
              if (t.item.is('uiElement') || t.item.is('attributeElement')) {
                return true;
              }
              return false;
            });
            if (s) {
              const e = n.viewPositionToDom(a);
              if (o) {
                t.collapse(e.parent, e.offset);
              } else {
                t.extend(e.parent, e.offset);
              }
            }
          }
        }
      }
      class Fp extends ip {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Np;
        }
        _insertChild(t, e) {
          if (e && (e instanceof nu || Array.from(e).length > 0)) {
            throw new B('view-rawelement-cannot-add', [this, e]);
          }
          return 0;
        }
        render(t, e) {}
      }
      Fp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rawElement' ||
            t === 'view:rawElement' ||
            t === this.name ||
            t === 'view:' + this.name ||
            t === 'element' ||
            t === 'view:element' ||
            t === 'node' ||
            t === 'view:node'
          );
        } else {
          return (
            e === this.name &&
            (t === 'rawElement' ||
              t === 'view:rawElement' ||
              t === 'element' ||
              t === 'view:element')
          );
        }
      };
      function Np() {
        return null;
      }
      class Lp extends $(Qh) {
        constructor(t, e) {
          super();
          this._children = [];
          this._customProperties = new Map();
          this.document = t;
          if (e) {
            this._insertChild(0, e);
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
          return undefined;
        }
        get getFillerOffset() {
          return undefined;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t, e) {
          this._fireChange('children', this);
          let n = 0;
          const o = Hp(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange('children', this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _fireChange(t, e) {
          this.fire('change:' + t, e);
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      Lp.prototype.is = function (t) {
        return t === 'documentFragment' || t === 'view:documentFragment';
      };
      function Hp(t, e) {
        if (typeof e == 'string') {
          return [new ou(t, e)];
        }
        if (!yt(e)) {
          e = [e];
        }
        return Array.from(e).map(e => {
          if (typeof e == 'string') {
            return new ou(t, e);
          }
          if (e instanceof iu) {
            return new ou(t, e.data);
          }
          return e;
        });
      }
      class jp {
        constructor(t) {
          this._cloneGroups = new Map();
          this._slotFactory = null;
          this.document = t;
        }
        setSelection(...t) {
          this.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this.document.selection._setFocus(t, e);
        }
        createDocumentFragment(t) {
          return new Lp(this.document, t);
        }
        createText(t) {
          return new ou(this.document, t);
        }
        createAttributeElement(t, e, n = {}) {
          const o = new Sp(this.document, t, e);
          if (typeof n.priority === 'number') {
            o._priority = n.priority;
          }
          if (n.id) {
            o._id = n.id;
          }
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createContainerElement(t, e, n = {}, o = {}) {
          let i = null;
          if (ue(n)) {
            o = n;
          } else {
            i = n;
          }
          const r = new cp(this.document, t, e, i);
          if (o.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes);
          }
          return r;
        }
        createEditableElement(t, e, n = {}) {
          const o = new dp(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createEmptyElement(t, e, n = {}) {
          const o = new Rp(this.document, t, e);
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes);
          }
          return o;
        }
        createUIElement(t, e, n) {
          const o = new Ip(this.document, t, e);
          if (n) {
            o.render = n;
          }
          return o;
        }
        createRawElement(t, e, n, o = {}) {
          const i = new Fp(this.document, t, e);
          if (n) {
            i.render = n;
          }
          if (o.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes);
          }
          return i;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (ue(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        breakAttributes(t) {
          if (t instanceof pp) {
            return this._breakAttributes(t);
          } else {
            return this._breakAttributesRange(t);
          }
        }
        breakContainer(t) {
          const e = t.parent;
          if (!e.is('containerElement')) {
            throw new B(
              'view-writer-break-non-container-element',
              this.document,
            );
          }
          if (!e.parent) {
            throw new B('view-writer-break-root', this.document);
          }
          if (t.isAtStart) {
            return pp._createBefore(e);
          } else if (!t.isAtEnd) {
            const n = e._clone(false);
            this.insert(pp._createAfter(e), n);
            const o = new gp(t, pp._createAt(e, 'end'));
            const i = new pp(n, 0);
            this.move(o, i);
          }
          return pp._createAfter(e);
        }
        mergeAttributes(t) {
          const e = t.offset;
          const n = t.parent;
          if (n.is('$text')) {
            return t;
          }
          if (n.is('attributeElement') && n.childCount === 0) {
            const t = n.parent;
            const e = n.index;
            n._remove();
            this._removeFromClonedElementsGroup(n);
            return this.mergeAttributes(new pp(t, e));
          }
          const o = n.getChild(e - 1);
          const i = n.getChild(e);
          if (!o || !i) {
            return t;
          }
          if (o.is('$text') && i.is('$text')) {
            return Up(o, i);
          } else if (
            o.is('attributeElement') &&
            i.is('attributeElement') &&
            o.isSimilar(i)
          ) {
            const t = o.childCount;
            o._appendChild(i.getChildren());
            i._remove();
            this._removeFromClonedElementsGroup(i);
            return this.mergeAttributes(new pp(o, t));
          }
          return t;
        }
        mergeContainers(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (
            !e ||
            !n ||
            !e.is('containerElement') ||
            !n.is('containerElement')
          ) {
            throw new B(
              'view-writer-merge-containers-invalid-position',
              this.document,
            );
          }
          const o = e.getChild(e.childCount - 1);
          const i =
            o instanceof ou ? pp._createAt(o, 'end') : pp._createAt(e, 'end');
          this.move(gp._createIn(n), pp._createAt(e, 'end'));
          this.remove(gp._createOn(n));
          return i;
        }
        insert(t, e) {
          e = yt(e) ? [...e] : [e];
          Jp(e, this.document);
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1];
            const o = !e.is('uiElement');
            if (!n || n.breakAttributes != o) {
              t.push({ breakAttributes: o, nodes: [e] });
            } else {
              n.nodes.push(e);
            }
            return t;
          }, []);
          let o = null;
          let i = t;
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(i, t, e);
            if (!o) {
              o = n.start;
            }
            i = n.end;
          }
          if (!o) {
            return new gp(t);
          }
          return new gp(o, i);
        }
        remove(t) {
          const e = t instanceof gp ? t : gp._createOn(t);
          Qp(e, this.document);
          if (e.isCollapsed) {
            return new Lp(this.document);
          }
          const { start: n, end: o } = this._breakAttributesRange(e, true);
          const i = n.parent;
          const r = o.offset - n.offset;
          const s = i._removeChildren(n.offset, r);
          for (const t of s) {
            this._removeFromClonedElementsGroup(t);
          }
          const a = this.mergeAttributes(n);
          e.start = a;
          e.end = a.clone();
          return new Lp(this.document, s);
        }
        clear(t, e) {
          Qp(t, this.document);
          const n = t.getWalker({
            direction: 'backward',
            ignoreElementEnd: true,
          });
          for (const o of n) {
            const n = o.item;
            let i;
            if (n.is('element') && e.isSimilar(n)) {
              i = gp._createOn(n);
            } else if (!o.nextPosition.isAfter(t.start) && n.is('$textProxy')) {
              const t = n
                .getAncestors()
                .find(t => t.is('element') && e.isSimilar(t));
              if (t) {
                i = gp._createIn(t);
              }
            }
            if (i) {
              if (i.end.isAfter(t.end)) {
                i.end = t.end;
              }
              if (i.start.isBefore(t.start)) {
                i.start = t.start;
              }
              this.remove(i);
            }
          }
        }
        move(t, e) {
          let n;
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true);
            const o = e.parent;
            const i = o.childCount;
            t = this._breakAttributesRange(t, true);
            n = this.remove(t);
            e.offset += o.childCount - i;
          } else {
            n = this.remove(t);
          }
          return this.insert(e, n);
        }
        wrap(t, e) {
          if (!(e instanceof Sp)) {
            throw new B('view-writer-wrap-invalid-attribute', this.document);
          }
          Qp(t, this.document);
          if (!t.isCollapsed) {
            return this._wrapRange(t, e);
          } else {
            let n = t.start;
            if (n.parent.is('element') && !qp(n.parent)) {
              n = n.getLastMatchingPosition(t => t.item.is('uiElement'));
            }
            n = this._wrapPosition(n, e);
            const o = this.document.selection;
            if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n);
            }
            return new gp(n);
          }
        }
        unwrap(t, e) {
          if (!(e instanceof Sp)) {
            throw new B('view-writer-unwrap-invalid-attribute', this.document);
          }
          Qp(t, this.document);
          if (t.isCollapsed) {
            return t;
          }
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._unwrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new gp(s, a);
        }
        rename(t, e) {
          const n = new cp(this.document, t, e.getAttributes());
          this.insert(pp._createAfter(e), n);
          this.move(gp._createIn(e), pp._createAt(n, 0));
          this.remove(gp._createOn(e));
          return n;
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t);
        }
        createPositionAt(t, e) {
          return pp._createAt(t, e);
        }
        createPositionAfter(t) {
          return pp._createAfter(t);
        }
        createPositionBefore(t) {
          return pp._createBefore(t);
        }
        createRange(t, e) {
          return new gp(t, e);
        }
        createRangeOn(t) {
          return gp._createOn(t);
        }
        createRangeIn(t) {
          return gp._createIn(t);
        }
        createSelection(...t) {
          return new kp(...t);
        }
        createSlot(t = 'children') {
          if (!this._slotFactory) {
            throw new B(
              'view-writer-invalid-create-slot-context',
              this.document,
            );
          }
          return this._slotFactory(this, t);
        }
        _registerSlotFactory(t) {
          this._slotFactory = t;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(t, e, n) {
          let o;
          if (n) {
            o = $p(t);
          } else {
            o = t.parent.is('$text') ? t.parent.parent : t.parent;
          }
          if (!o) {
            throw new B(
              'view-writer-invalid-position-container',
              this.document,
            );
          }
          let i;
          if (n) {
            i = this._breakAttributes(t, true);
          } else {
            i = t.parent.is('$text') ? Kp(t) : t;
          }
          const r = o._insertChild(i.offset, e);
          for (const t of e) {
            this._addToClonedElementsGroup(t);
          }
          const s = i.getShiftedBy(r);
          const a = this.mergeAttributes(i);
          if (!a.isEqual(i)) {
            s.offset--;
          }
          const c = this.mergeAttributes(s);
          return new gp(a, c);
        }
        _wrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            const n = e.is('$text');
            const s = e.is('attributeElement');
            if (s && this._wrapAttributeElement(o, e)) {
              r.push(new pp(t, i));
            } else if (n || !s || Wp(o, e)) {
              const n = o._clone();
              e._remove();
              n._appendChild(e);
              t._insertChild(i, n);
              this._addToClonedElementsGroup(n);
              r.push(new pp(t, i));
            } else {
              this._wrapChildren(e, 0, e.childCount, o);
            }
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return gp._createFromParentsAndOffsets(t, e, t, n);
        }
        _unwrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            if (!e.is('attributeElement')) {
              i++;
              continue;
            }
            if (e.isSimilar(o)) {
              const o = e.getChildren();
              const s = e.childCount;
              e._remove();
              t._insertChild(i, o);
              this._removeFromClonedElementsGroup(e);
              r.push(new pp(t, i), new pp(t, i + s));
              i += s;
              n += s - 1;
              continue;
            }
            if (this._unwrapAttributeElement(o, e)) {
              r.push(new pp(t, i), new pp(t, i + 1));
              i++;
              continue;
            }
            this._unwrapChildren(e, 0, e.childCount, o);
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e || t.offset == n) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return gp._createFromParentsAndOffsets(t, e, t, n);
        }
        _wrapRange(t, e) {
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._wrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new gp(s, a);
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return Gp(t.clone());
          }
          if (t.parent.is('$text')) {
            t = Kp(t);
          }
          const n = this.createAttributeElement('_wrapPosition-fake-element');
          n._priority = Number.POSITIVE_INFINITY;
          n.isSimilar = () => false;
          t.parent._insertChild(t.offset, n);
          const o = new gp(t, t.getShiftedBy(1));
          this.wrap(o, e);
          const i = new pp(n.parent, n.index);
          n._remove();
          const r = i.nodeBefore;
          const s = i.nodeAfter;
          if (r instanceof ou && s instanceof ou) {
            return Up(r, s);
          }
          return Gp(i);
        }
        _wrapAttributeElement(t, e) {
          if (!Xp(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e);
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e);
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e);
            }
          }
          return true;
        }
        _unwrapAttributeElement(t, e) {
          if (!Xp(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false;
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === 'class' || n === 'style') {
              continue;
            }
            this.removeAttribute(n, e);
          }
          this.removeClass(Array.from(t.getClassNames()), e);
          this.removeStyle(Array.from(t.getStyleNames()), e);
          return true;
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start;
          const o = t.end;
          Qp(t, this.document);
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e);
            return new gp(n, n);
          }
          const i = this._breakAttributes(o, e);
          const r = i.parent.childCount;
          const s = this._breakAttributes(n, e);
          i.offset += i.parent.childCount - r;
          return new gp(s, i);
        }
        _breakAttributes(t, e = false) {
          const n = t.offset;
          const o = t.parent;
          if (t.parent.is('emptyElement')) {
            throw new B(
              'view-writer-cannot-break-empty-element',
              this.document,
            );
          }
          if (t.parent.is('uiElement')) {
            throw new B('view-writer-cannot-break-ui-element', this.document);
          }
          if (t.parent.is('rawElement')) {
            throw new B('view-writer-cannot-break-raw-element', this.document);
          }
          if (!e && o.is('$text') && Yp(o.parent)) {
            return t.clone();
          }
          if (Yp(o)) {
            return t.clone();
          }
          if (o.is('$text')) {
            return this._breakAttributes(Kp(t), e);
          }
          const i = o.childCount;
          if (n == i) {
            const t = new pp(o.parent, o.index + 1);
            return this._breakAttributes(t, e);
          } else {
            if (n === 0) {
              const t = new pp(o.parent, o.index);
              return this._breakAttributes(t, e);
            } else {
              const t = o.index + 1;
              const i = o._clone();
              o.parent._insertChild(t, i);
              this._addToClonedElementsGroup(i);
              const r = o.childCount - n;
              const s = o._removeChildren(n, r);
              i._appendChild(s);
              const a = new pp(o.parent, t);
              return this._breakAttributes(a, e);
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is('rootElement')) {
            return;
          }
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          let n = this._cloneGroups.get(e);
          if (!n) {
            n = new Set();
            this._cloneGroups.set(e, n);
          }
          n.add(t);
          t._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          const n = this._cloneGroups.get(e);
          if (!n) {
            return;
          }
          n.delete(t);
        }
      }
      function qp(t) {
        return Array.from(t.getChildren()).some(t => !t.is('uiElement'));
      }
      function $p(t) {
        let e = t.parent;
        while (!Yp(e)) {
          if (!e) {
            return undefined;
          }
          e = e.parent;
        }
        return e;
      }
      function Wp(t, e) {
        if (t.priority < e.priority) {
          return true;
        } else if (t.priority > e.priority) {
          return false;
        }
        return t.getIdentity() < e.getIdentity();
      }
      function Gp(t) {
        const e = t.nodeBefore;
        if (e && e.is('$text')) {
          return new pp(e, e.data.length);
        }
        const n = t.nodeAfter;
        if (n && n.is('$text')) {
          return new pp(n, 0);
        }
        return t;
      }
      function Kp(t) {
        if (t.offset == t.parent.data.length) {
          return new pp(t.parent.parent, t.parent.index + 1);
        }
        if (t.offset === 0) {
          return new pp(t.parent.parent, t.parent.index);
        }
        const e = t.parent.data.slice(t.offset);
        t.parent._data = t.parent.data.slice(0, t.offset);
        t.parent.parent._insertChild(
          t.parent.index + 1,
          new ou(t.root.document, e),
        );
        return new pp(t.parent.parent, t.parent.index + 1);
      }
      function Up(t, e) {
        const n = t.data.length;
        t._data += e.data;
        e._remove();
        return new pp(t, n);
      }
      const Zp = [ou, Sp, cp, Rp, Fp, Ip];
      function Jp(t, e) {
        for (const n of t) {
          if (!Zp.some(t => n instanceof t)) {
            throw new B('view-writer-insert-invalid-node-type', e);
          }
          if (!n.is('$text')) {
            Jp(n.getChildren(), e);
          }
        }
      }
      function Yp(t) {
        return t && (t.is('containerElement') || t.is('documentFragment'));
      }
      function Qp(t, e) {
        const n = $p(t.start);
        const o = $p(t.end);
        if (!n || !o || n !== o) {
          throw new B('view-writer-invalid-range-container', e);
        }
      }
      function Xp(t, e) {
        return t.id === null && e.id === null;
      }
      const tg = t => t.createTextNode('');
      const eg = t => {
        const e = t.createElement('span');
        e.dataset.ckeFiller = 'true';
        e.innerText = '';
        return e;
      };
      const ng = t => {
        const e = t.createElement('br');
        e.dataset.ckeFiller = 'true';
        return e;
      };
      const og = 7;
      const ig = ''.repeat(og);
      function rg(t) {
        if (typeof t == 'string') {
          return t.substr(0, og) === ig;
        }
        return oc(t) && t.data.substr(0, og) === ig;
      }
      function sg(t) {
        return t.data.length == og && rg(t);
      }
      function ag(t) {
        const e = typeof t == 'string' ? t : t.data;
        if (rg(t)) {
          return e.slice(og);
        }
        return e;
      }
      function cg(t) {
        t.document.on('arrowKey', lg, { priority: 'low' });
      }
      function lg(t, e) {
        if (e.keyCode == qc.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer;
            const n = t.getRangeAt(0).startOffset;
            if (rg(e) && n <= og) {
              t.collapse(e, 0);
            }
          }
        }
      }
      var dg = n(37);
      var hg = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      hg.insert = 'head';
      hg.singleton = true;
      var ug = Bl()(dg.Z, hg);
      const fg = dg.Z.locals || {};
      class pg extends dt() {
        constructor(t, e) {
          super();
          this.domDocuments = new Set();
          this.markedAttributes = new Set();
          this.markedChildren = new Set();
          this.markedTexts = new Set();
          this._inlineFiller = null;
          this._fakeSelectionContainer = null;
          this.domConverter = t;
          this.selection = e;
          this.set('isFocused', false);
          this.set('isSelecting', false);
          if (s.isBlink && !s.isAndroid) {
            this.on('change:isSelecting', () => {
              if (!this.isSelecting) {
                this.render();
              }
            });
          }
          this.set('isComposing', false);
          this.on('change:isComposing', () => {
            if (!this.isComposing) {
              this.render();
            }
          });
        }
        markToSync(t, e) {
          if (t === 'text') {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e);
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return;
            }
            if (t === 'attributes') {
              this.markedAttributes.add(e);
            } else if (t === 'children') {
              this.markedChildren.add(e);
            } else {
              const e = t;
              throw new B('view-renderer-unknown-type', this);
            }
          }
        }
        render() {
          if (this.isComposing && !s.isAndroid) {
            return;
          }
          let t = null;
          const e = s.isBlink && !s.isAndroid ? !this.isSelecting : true;
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t);
          }
          if (e) {
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller();
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition();
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition();
              this.markedChildren.add(t.parent);
            }
          } else if (this._inlineFiller && this._inlineFiller.parentNode) {
            t = this.domConverter.domPositionToView(this._inlineFiller);
            if (t && t.parent.is('$text')) {
              t = pp._createBefore(t.parent);
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t);
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t });
          }
          for (const e of this.markedTexts) {
            if (
              !this.markedChildren.has(e.parent) &&
              this.domConverter.mapViewToDom(e.parent)
            ) {
              this._updateText(e, { inlineFillerPosition: t });
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t);
              const n = e.parent.ownerDocument;
              if (!rg(e.parent)) {
                this._inlineFiller = mg(n, e.parent, e.offset);
              } else {
                this._inlineFiller = e.parent;
              }
            } else {
              this._inlineFiller = null;
            }
          }
          this._updateFocus();
          this._updateSelection();
          this.domConverter._clearTemporaryCustomProperties();
          this.markedTexts.clear();
          this.markedAttributes.clear();
          this.markedChildren.clear();
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.childNodes);
          const o = Array.from(
            this.domConverter.viewChildrenToDom(t, { withChildren: false }),
          );
          const i = this._diffNodeLists(n, o);
          const r = this._findUpdateActions(i, n, o, kg);
          if (r.indexOf('update') !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 };
            for (const i of r) {
              if (i === 'update') {
                const i = e.equal + e.insert;
                const r = e.equal + e.delete;
                const s = t.getChild(i);
                if (s && !s.is('uiElement') && !s.is('rawElement')) {
                  this._updateElementMappings(s, n[r]);
                }
                Tc(o[i]);
                e.equal++;
              } else {
                e[i]++;
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e);
          this.domConverter.bindElements(e, t);
          this.markedChildren.add(t);
          this.markedAttributes.add(t);
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition();
          if (t.parent.is('$text')) {
            return pp._createBefore(t.parent);
          } else {
            return t;
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = this.domConverter.viewPositionToDom(t);
          if (e && oc(e.parent) && rg(e.parent)) {
            return true;
          }
          return false;
        }
        _removeInlineFiller() {
          const t = this._inlineFiller;
          if (!rg(t)) {
            throw new B('view-renderer-filler-was-lost', this);
          }
          if (sg(t)) {
            t.remove();
          } else {
            t.data = t.data.substr(og);
          }
          this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = t.parent;
          const n = t.offset;
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false;
          }
          if (!e.is('element')) {
            return false;
          }
          if (!gg(e)) {
            return false;
          }
          if (n === e.getFillerOffset()) {
            return false;
          }
          const o = t.nodeBefore;
          const i = t.nodeAfter;
          if (o instanceof ou || i instanceof ou) {
            return false;
          }
          if (s.isAndroid && (o || i)) {
            return false;
          }
          return true;
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t);
          const o = this.domConverter.viewToDom(t);
          let i = o.data;
          const r = e.inlineFillerPosition;
          if (r && r.parent == t.parent && r.offset == t.index) {
            i = ig + i;
          }
          Cg(n, i);
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.attributes).map(t => t.name);
          const o = t.getAttributeKeys();
          for (const n of o) {
            this.domConverter.setDomElementAttribute(
              e,
              n,
              t.getAttribute(n),
              t,
            );
          }
          for (const o of n) {
            if (!t.hasAttribute(o)) {
              this.domConverter.removeDomElementAttribute(e, o);
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t);
          if (!n) {
            return;
          }
          if (s.isAndroid) {
            let t = null;
            for (const e of Array.from(n.childNodes)) {
              if (t && oc(t) && oc(e)) {
                n.normalize();
                break;
              }
              t = e;
            }
          }
          const o = e.inlineFillerPosition;
          const i = n.childNodes;
          const r = Array.from(
            this.domConverter.viewChildrenToDom(t, { bind: true }),
          );
          if (o && o.parent === t) {
            mg(n.ownerDocument, r, o.offset);
          }
          const a = this._diffNodeLists(i, r);
          const c = this._findUpdateActions(a, i, r, bg);
          let l = 0;
          const d = new Set();
          for (const t of c) {
            if (t === 'delete') {
              d.add(i[l]);
              Tc(i[l]);
            } else if (t === 'equal' || t === 'update') {
              l++;
            }
          }
          l = 0;
          for (const t of c) {
            if (t === 'insert') {
              wc(n, l, r[l]);
              l++;
            } else if (t === 'update') {
              Cg(i[l], r[l].data);
              l++;
            } else if (t === 'equal') {
              this._markDescendantTextToSync(this.domConverter.domToView(r[l]));
              l++;
            }
          }
          for (const t of d) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t);
            }
          }
        }
        _diffNodeLists(t, e) {
          t = vg(t, this._fakeSelectionContainer);
          return v(t, e, wg.bind(null, this.domConverter));
        }
        _findUpdateActions(t, e, n, o) {
          if (t.indexOf('insert') === -1 || t.indexOf('delete') === -1) {
            return t;
          }
          let i = [];
          let r = [];
          let s = [];
          const a = { equal: 0, insert: 0, delete: 0 };
          for (const c of t) {
            if (c === 'insert') {
              s.push(n[a.equal + a.insert]);
            } else if (c === 'delete') {
              r.push(e[a.equal + a.delete]);
            } else {
              i = i.concat(v(r, s, o).map(t => (t === 'equal' ? 'update' : t)));
              i.push('equal');
              r = [];
              s = [];
            }
            a[c]++;
          }
          return i.concat(v(r, s, o).map(t => (t === 'equal' ? 'update' : t)));
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return;
          }
          if (t.is('$text')) {
            this.markedTexts.add(t);
          } else if (t.is('element')) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e);
            }
          }
        }
        _updateSelection() {
          if (
            s.isBlink &&
            !s.isAndroid &&
            this.isSelecting &&
            !this.markedChildren.size
          ) {
            return;
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection();
            this._removeFakeSelection();
            return;
          }
          const t = this.domConverter.mapViewToDom(
            this.selection.editableElement,
          );
          if (!this.isFocused || !t) {
            return;
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t);
          } else if (
            this._fakeSelectionContainer &&
            this._fakeSelectionContainer.isConnected
          ) {
            this._removeFakeSelection();
            this._updateDomSelection(t);
          } else if (!(this.isComposing && s.isAndroid)) {
            this._updateDomSelection(t);
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument;
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = Ag(e);
          }
          const n = this._fakeSelectionContainer;
          this.domConverter.bindFakeSelection(n, this.selection);
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return;
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n);
          }
          n.textContent = this.selection.fakeSelectionLabel || '';
          const o = e.getSelection();
          const i = e.createRange();
          o.removeAllRanges();
          i.selectNodeContents(n);
          o.addRange(i);
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e)) {
            return;
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor);
          const o = this.domConverter.viewPositionToDom(this.selection.focus);
          e.setBaseAndExtent(n.parent, n.offset, o.parent, o.offset);
          if (s.isGecko) {
            _g(o, e);
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true;
          }
          const e = t && this.domConverter.domSelectionToView(t);
          if (e && this.selection.isEqual(e)) {
            return false;
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false;
          }
          return true;
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer;
          const n = t.ownerDocument.getSelection();
          if (!e || e.parentElement !== t) {
            return true;
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true;
          }
          return e.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection();
            if (e.rangeCount) {
              const n = t.activeElement;
              const o = this.domConverter.mapDomToView(n);
              if (n && o) {
                e.removeAllRanges();
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer;
          if (t) {
            t.remove();
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
            }
          }
        }
      }
      function gg(t) {
        if (t.getAttribute('contenteditable') == 'false') {
          return false;
        }
        const e = t.findAncestor(t => t.hasAttribute('contenteditable'));
        return !e || e.getAttribute('contenteditable') == 'true';
      }
      function mg(t, e, n) {
        const o = e instanceof Array ? e : e.childNodes;
        const i = o[n];
        if (oc(i)) {
          i.data = ig + i.data;
          return i;
        } else {
          const i = t.createTextNode(ig);
          if (Array.isArray(e)) {
            o.splice(n, 0, i);
          } else {
            wc(e, n, i);
          }
          return i;
        }
      }
      function kg(t, e) {
        return (
          Wa(t) &&
          Wa(e) &&
          !oc(t) &&
          !oc(e) &&
          !_c(t) &&
          !_c(e) &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        );
      }
      function bg(t, e) {
        return Wa(t) && Wa(e) && oc(t) && oc(e);
      }
      function wg(t, e, n) {
        if (e === n) {
          return true;
        } else if (oc(e) && oc(n)) {
          return e.data === n.data;
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true;
        }
        return false;
      }
      function _g(t, e) {
        const n = t.parent;
        if (
          n.nodeType != Node.ELEMENT_NODE ||
          t.offset != n.childNodes.length - 1
        ) {
          return;
        }
        const o = n.childNodes[t.offset];
        if (o && o.tagName == 'BR') {
          e.addRange(e.getRangeAt(0));
        }
      }
      function vg(t, e) {
        const n = Array.from(t);
        if (n.length == 0 || !e) {
          return n;
        }
        const o = n[n.length - 1];
        if (o == e) {
          n.pop();
        }
        return n;
      }
      function Ag(t) {
        const e = t.createElement('div');
        e.className = 'ck-fake-selection-container';
        Object.assign(e.style, {
          position: 'fixed',
          top: 0,
          left: '-9999px',
          width: '42px',
        });
        e.textContent = '';
        return e;
      }
      function Cg(t, e) {
        const n = t.data;
        if (n == e) {
          return;
        }
        const o = g(n, e);
        for (const e of o) {
          if (e.type === 'insert') {
            t.insertData(e.index, e.values.join(''));
          } else {
            t.deleteData(e.index, e.howMany);
          }
        }
      }
      const yg = ng(Xa.document);
      const xg = tg(Xa.document);
      const Eg = eg(Xa.document);
      const Dg = 'data-ck-unsafe-attribute-';
      const Tg = 'data-ck-unsafe-element';
      class Sg {
        constructor(
          t,
          { blockFillerMode: e, renderingMode: n = 'editing' } = {},
        ) {
          this._domToViewMapping = new WeakMap();
          this._viewToDomMapping = new WeakMap();
          this._fakeSelectionMapping = new WeakMap();
          this._rawContentElementMatcher = new ru();
          this._inlineObjectElementMatcher = new ru();
          this._elementsWithTemporaryCustomProperties = new Set();
          this.document = t;
          this.renderingMode = n;
          this.blockFillerMode = e || (n === 'editing' ? 'br' : 'nbsp');
          this.preElements = ['pre'];
          this.blockElements = [
            'address',
            'article',
            'aside',
            'blockquote',
            'caption',
            'center',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'header',
            'hgroup',
            'legend',
            'li',
            'main',
            'menu',
            'nav',
            'ol',
            'p',
            'pre',
            'section',
            'summary',
            'table',
            'tbody',
            'td',
            'tfoot',
            'th',
            'thead',
            'tr',
            'ul',
          ];
          this.inlineObjectElements = [
            'object',
            'iframe',
            'input',
            'button',
            'textarea',
            'select',
            'option',
            'video',
            'embed',
            'audio',
            'img',
            'canvas',
          ];
          this.unsafeElements = ['script', 'style'];
          this._domDocument =
            this.renderingMode === 'editing'
              ? Xa.document
              : Xa.document.implementation.createHTMLDocument('');
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new kp(e));
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t);
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t);
          if (e) {
            this._domToViewMapping.delete(t);
            this._viewToDomMapping.delete(e);
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e);
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === 'data') {
            return true;
          }
          t = t.toLowerCase();
          if (t.startsWith('on')) {
            return false;
          }
          if (
            t === 'srcdoc' &&
            e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)
          ) {
            return false;
          }
          if (n === 'img' && (t === 'src' || t === 'srcset')) {
            return true;
          }
          if (n === 'source' && t === 'srcset') {
            return true;
          }
          if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
            return false;
          }
          return true;
        }
        setContentOf(t, e) {
          if (this.renderingMode === 'data') {
            t.innerHTML = e;
            return;
          }
          const n = new DOMParser().parseFromString(e, 'text/html');
          const o = n.createDocumentFragment();
          const i = n.body.childNodes;
          while (i.length > 0) {
            o.appendChild(i[0]);
          }
          const r = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT);
          const s = [];
          let a;
          while ((a = r.nextNode())) {
            s.push(a);
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e));
            }
            const e = t.tagName.toLowerCase();
            if (this._shouldRenameElement(e)) {
              Ig(e);
              t.replaceWith(this._createReplacementDomElement(e, t));
            }
          }
          while (t.firstChild) {
            t.firstChild.remove();
          }
          t.append(o);
        }
        viewToDom(t, e = {}) {
          if (t.is('$text')) {
            const e = this._processDataFromViewText(t);
            return this._domDocument.createTextNode(e);
          } else {
            const n = t;
            if (this.mapViewToDom(n)) {
              if (n.getCustomProperty('editingPipeline:doNotReuseOnce')) {
                this._elementsWithTemporaryCustomProperties.add(n);
              } else {
                return this.mapViewToDom(n);
              }
            }
            let o;
            if (n.is('documentFragment')) {
              o = this._domDocument.createDocumentFragment();
              if (e.bind) {
                this.bindDocumentFragments(o, n);
              }
            } else if (n.is('uiElement')) {
              if (n.name === '$comment') {
                o = this._domDocument.createComment(
                  n.getCustomProperty('$rawContent'),
                );
              } else {
                o = n.render(this._domDocument, this);
              }
              if (e.bind) {
                this.bindElements(o, n);
              }
              return o;
            } else {
              if (this._shouldRenameElement(n.name)) {
                Ig(n.name);
                o = this._createReplacementDomElement(n.name);
              } else if (n.hasAttribute('xmlns')) {
                o = this._domDocument.createElementNS(
                  n.getAttribute('xmlns'),
                  n.name,
                );
              } else {
                o = this._domDocument.createElement(n.name);
              }
              if (n.is('rawElement')) {
                n.render(o, this);
              }
              if (e.bind) {
                this.bindElements(o, n);
              }
              for (const t of n.getAttributeKeys()) {
                this.setDomElementAttribute(o, t, n.getAttribute(t), n);
              }
            }
            if (e.withChildren !== false) {
              for (const t of this.viewChildrenToDom(n, e)) {
                o.appendChild(t);
              }
            }
            return o;
          }
        }
        setDomElementAttribute(t, e, n, o) {
          const i =
            this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
            (o && o.shouldRenderUnsafeAttribute(e));
          if (!i) {
            R('domconverter-unsafe-attribute-detected', {
              domElement: t,
              key: e,
              value: n,
            });
          }
          if (!vc(e)) {
            R('domconverter-invalid-attribute-detected', {
              domElement: t,
              key: e,
              value: n,
            });
            return;
          }
          if (t.hasAttribute(e) && !i) {
            t.removeAttribute(e);
          } else if (t.hasAttribute(Dg + e) && i) {
            t.removeAttribute(Dg + e);
          }
          t.setAttribute(i ? e : Dg + e, n);
        }
        removeDomElementAttribute(t, e) {
          if (e == Tg) {
            return;
          }
          t.removeAttribute(e);
          t.removeAttribute(Dg + e);
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset();
          let o = 0;
          for (const i of t.getChildren()) {
            if (n === o) {
              yield this._getBlockFiller();
            }
            const t =
              i.is('element') &&
              !!i.getCustomProperty('dataPipeline:transparentRendering') &&
              !hl(i.getAttributes());
            if (t && this.renderingMode == 'data') {
              yield* this.viewChildrenToDom(i, e);
            } else {
              if (t) {
                R(
                  'domconverter-transparent-rendering-unsupported-in-editing-pipeline',
                  { viewElement: i },
                );
              }
              yield this.viewToDom(i, e);
            }
            o++;
          }
          if (n === o) {
            yield this._getBlockFiller();
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start);
          const n = this.viewPositionToDom(t.end);
          const o = this._domDocument.createRange();
          o.setStart(e.parent, e.offset);
          o.setEnd(n.parent, n.offset);
          return o;
        }
        viewPositionToDom(t) {
          const e = t.parent;
          if (e.is('$text')) {
            const n = this.findCorrespondingDomText(e);
            if (!n) {
              return null;
            }
            let o = t.offset;
            if (rg(n)) {
              o += og;
            }
            return { parent: n, offset: o };
          } else {
            let n, o, i;
            if (t.offset === 0) {
              n = this.mapViewToDom(e);
              if (!n) {
                return null;
              }
              i = n.childNodes[0];
            } else {
              const e = t.nodeBefore;
              o = e.is('$text')
                ? this.findCorrespondingDomText(e)
                : this.mapViewToDom(e);
              if (!o) {
                return null;
              }
              n = o.parentNode;
              i = o.nextSibling;
            }
            if (oc(i) && rg(i)) {
              return { parent: i, offset: og };
            }
            const r = o ? bc(o) + 1 : 0;
            return { parent: n, offset: r };
          }
        }
        domToView(t, e = {}) {
          const n = [];
          const o = this._domToView(t, e, n);
          const i = o.next().value;
          if (!i) {
            return null;
          }
          o.next();
          this._processDomInlineNodes(null, n, e);
          if (i.is('$text') && i.data.length == 0) {
            return null;
          }
          return i;
        }
        *domChildrenToView(t, e = {}, n = []) {
          for (let o = 0; o < t.childNodes.length; o++) {
            const i = t.childNodes[o];
            const r = this._domToView(i, e, n);
            const s = r.next().value;
            if (s !== null) {
              if (this._isBlockViewElement(s)) {
                this._processDomInlineNodes(t, n, e);
              }
              yield s;
              r.next();
            }
          }
          this._processDomInlineNodes(t, n, e);
        }
        domSelectionToView(t) {
          if (Mg(t)) {
            return new kp([]);
          }
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer;
            if (oc(e)) {
              e = e.parentNode;
            }
            const n = this.fakeSelectionToView(e);
            if (n) {
              return n;
            }
          }
          const e = this.isDomSelectionBackward(t);
          const n = [];
          for (let e = 0; e < t.rangeCount; e++) {
            const o = t.getRangeAt(e);
            const i = this.domRangeToView(o);
            if (i) {
              n.push(i);
            }
          }
          return new kp(n, { backward: e });
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset);
          const n = this.domPositionToView(t.endContainer, t.endOffset);
          if (e && n) {
            return new gp(e, n);
          }
          return null;
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, bc(t));
          }
          const n = this.mapDomToView(t);
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return pp._createBefore(n);
          }
          if (oc(t)) {
            if (sg(t)) {
              return this.domPositionToView(t.parentNode, bc(t));
            }
            const n = this.findCorrespondingViewText(t);
            let o = e;
            if (!n) {
              return null;
            }
            if (rg(t)) {
              o -= og;
              o = o < 0 ? 0 : o;
            }
            return new pp(n, o);
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t);
              if (e) {
                return new pp(e, 0);
              }
            } else {
              const n = t.childNodes[e - 1];
              if ((oc(n) && sg(n)) || (n && this.isBlockFiller(n))) {
                return this.domPositionToView(n.parentNode, bc(n));
              }
              const o = oc(n)
                ? this.findCorrespondingViewText(n)
                : this.mapDomToView(n);
              if (o && o.parent) {
                return new pp(o.parent, o.index + 1);
              }
            }
            return null;
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t);
          return e || this._domToViewMapping.get(t);
        }
        findCorrespondingViewText(t) {
          if (sg(t)) {
            return null;
          }
          const e = this.getHostViewElement(t);
          if (e) {
            return e;
          }
          const n = t.previousSibling;
          if (n) {
            if (!this.isElement(n)) {
              return null;
            }
            const t = this.mapDomToView(n);
            if (t) {
              const e = t.nextSibling;
              if (e instanceof ou) {
                return e;
              } else {
                return null;
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode);
            if (e) {
              const t = e.getChild(0);
              if (t instanceof ou) {
                return t;
              } else {
                return null;
              }
            }
          }
          return null;
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t);
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling;
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling;
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0];
          }
          return null;
        }
        focus(t) {
          const e = this.mapViewToDom(t);
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Xa.window;
            const o = [];
            Bg(e, t => {
              const { scrollLeft: e, scrollTop: n } = t;
              o.push([e, n]);
            });
            e.focus();
            Bg(e, t => {
              const [e, n] = o.shift();
              t.scrollLeft = e;
              t.scrollTop = n;
            });
            Xa.window.scrollTo(t, n);
          }
        }
        _clearDomSelection() {
          const t = this.mapViewToDom(this.document.selection.editableElement);
          if (!t) {
            return;
          }
          const e = t.ownerDocument.defaultView.getSelection();
          const n = this.domSelectionToView(e);
          const o = n && n.rangeCount > 0;
          if (o) {
            e.removeAllRanges();
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == 'br') {
            return t.isEqualNode(yg);
          }
          if (
            t.tagName === 'BR' &&
            Og(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true;
          }
          return t.isEqualNode(Eg) || Rg(t, this.blockElements);
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false;
          }
          const e = this._domDocument.createRange();
          try {
            e.setStart(t.anchorNode, t.anchorOffset);
            e.setEnd(t.focusNode, t.focusOffset);
          } catch (t) {
            return false;
          }
          const n = e.collapsed;
          e.detach();
          return n;
        }
        getHostViewElement(t) {
          const e = ec(t);
          e.pop();
          while (e.length) {
            const t = e.pop();
            const n = this._domToViewMapping.get(t);
            if (n && (n.is('uiElement') || n.is('rawElement'))) {
              return n;
            }
          }
          return null;
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          );
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t);
        }
        registerInlineObjectMatcher(t) {
          this._inlineObjectElementMatcher.add(t);
        }
        _clearTemporaryCustomProperties() {
          for (const t of this._elementsWithTemporaryCustomProperties) {
            t._removeCustomProperty('editingPipeline:doNotReuseOnce');
          }
          this._elementsWithTemporaryCustomProperties.clear();
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case 'nbsp':
              return tg(this._domDocument);
            case 'markedNbsp':
              return eg(this._domDocument);
            case 'br':
              return ng(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (oc(t) && rg(t) && e < og) {
            return false;
          }
          if (this.isElement(t) && rg(t.childNodes[e])) {
            return false;
          }
          const n = this.mapDomToView(t);
          if (n && (n.is('uiElement') || n.is('rawElement'))) {
            return false;
          }
          return true;
        }
        *_domToView(t, e, n) {
          if (this.isBlockFiller(t)) {
            return null;
          }
          const o = this.getHostViewElement(t);
          if (o) {
            return o;
          }
          if (_c(t) && e.skipComments) {
            return null;
          }
          if (oc(t)) {
            if (sg(t)) {
              return null;
            } else {
              const e = t.data;
              if (e === '') {
                return null;
              }
              const o = new ou(this.document, e);
              n.push(o);
              return o;
            }
          } else {
            let o = this.mapDomToView(t);
            if (o) {
              if (this._isInlineObjectElement(o)) {
                n.push(o);
              }
              return o;
            }
            if (this.isDocumentFragment(t)) {
              o = new Lp(this.document);
              if (e.bind) {
                this.bindDocumentFragments(t, o);
              }
            } else {
              o = this._createViewElement(t, e);
              if (e.bind) {
                this.bindElements(t, o);
              }
              const i = t.attributes;
              if (i) {
                for (let t = i.length, e = 0; e < t; e++) {
                  o._setAttribute(i[e].name, i[e].value);
                }
              }
              if (this._isViewElementWithRawContent(o, e)) {
                o._setCustomProperty('$rawContent', t.innerHTML);
                if (!this._isBlockViewElement(o)) {
                  n.push(o);
                }
                return o;
              }
              if (_c(t)) {
                o._setCustomProperty('$rawContent', t.data);
                return o;
              }
            }
            yield o;
            const i = [];
            if (e.withChildren !== false) {
              for (const n of this.domChildrenToView(t, e, i)) {
                o._appendChild(n);
              }
            }
            if (this._isInlineObjectElement(o)) {
              n.push(o);
            } else {
              for (const t of i) {
                n.push(t);
              }
            }
          }
        }
        _processDomInlineNodes(t, e, n) {
          if (!e.length) {
            return;
          }
          if (t && !this.isDocumentFragment(t) && !this._isBlockDomElement(t)) {
            return;
          }
          let o = false;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            if (!i.is('$text')) {
              o = false;
              continue;
            }
            let r;
            let s = false;
            if (Pg(i, this.preElements)) {
              r = ag(i.data);
            } else {
              r = i.data.replace(/[ \n\t\r]{1,}/g, ' ');
              s = /[^\S\u00A0]/.test(r.charAt(r.length - 1));
              const a = t > 0 ? e[t - 1] : null;
              const c = t + 1 < e.length ? e[t + 1] : null;
              const l = !a || (a.is('element') && a.name == 'br') || o;
              const d = c ? false : !rg(i.data);
              if (n.withChildren !== false) {
                if (l) {
                  r = r.replace(/^ /, '');
                }
                if (d) {
                  r = r.replace(/ $/, '');
                }
              }
              r = ag(r);
              r = r.replace(/ \u00A0/g, '  ');
              const h = c && c.is('element') && c.name != 'br';
              const u = c && c.is('$text') && c.data.charAt(0) == ' ';
              if (/[ \u00A0]\u00A0$/.test(r) || !c || h || u) {
                r = r.replace(/\u00A0$/, ' ');
              }
              if (l || (a && a.is('element') && a.name != 'br')) {
                r = r.replace(/^\u00A0/, ' ');
              }
            }
            if (r.length == 0 && i.parent) {
              i._remove();
              e.splice(t, 1);
              t--;
            } else {
              i._data = r;
              o = s;
            }
          }
          e.length = 0;
        }
        _processDataFromViewText(t) {
          let e = t.data;
          if (t.getAncestors().some(t => this.preElements.includes(t.name))) {
            return e;
          }
          if (e.charAt(0) == ' ') {
            const n = this._getTouchingInlineViewNode(t, false);
            const o = n && n.is('$textProxy') && this._nodeEndsWithSpace(n);
            if (o || !n) {
              e = '' + e.substr(1);
            }
          }
          if (e.charAt(e.length - 1) == ' ') {
            const n = this._getTouchingInlineViewNode(t, true);
            const o = n && n.is('$textProxy') && n.data.charAt(0) == ' ';
            if (e.charAt(e.length - 2) == ' ' || !n || o) {
              e = e.substr(0, e.length - 1) + '';
            }
          }
          return e.replace(/ {2}/g, ' ');
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some(t => this.preElements.includes(t.name))) {
            return false;
          }
          const e = this._processDataFromViewText(t);
          return e.charAt(e.length - 1) == ' ';
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new fp({
            startPosition: e ? pp._createAfter(t) : pp._createBefore(t),
            direction: e ? 'forward' : 'backward',
          });
          for (const t of n) {
            if (t.item.is('element', 'br')) {
              return null;
            } else if (this._isInlineObjectElement(t.item)) {
              return t.item;
            } else if (t.item.is('containerElement')) {
              return null;
            } else if (t.item.is('$textProxy')) {
              return t.item;
            }
          }
          return null;
        }
        _isBlockDomElement(t) {
          return (
            this.isElement(t) &&
            this.blockElements.includes(t.tagName.toLowerCase())
          );
        }
        _isBlockViewElement(t) {
          return t.is('element') && this.blockElements.includes(t.name);
        }
        _isInlineObjectElement(t) {
          if (!t.is('element')) {
            return false;
          }
          return (
            t.name == 'br' ||
            this.inlineObjectElements.includes(t.name) ||
            !!this._inlineObjectElementMatcher.match(t)
          );
        }
        _createViewElement(t, e) {
          if (_c(t)) {
            return new Ip(this.document, '$comment');
          }
          const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
          return new ip(this.document, n);
        }
        _isViewElementWithRawContent(t, e) {
          return (
            e.withChildren !== false &&
            t.is('element') &&
            !!this._rawContentElementMatcher.match(t)
          );
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase();
          return (
            this.renderingMode === 'editing' && this.unsafeElements.includes(e)
          );
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement('span');
          n.setAttribute(Tg, t);
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild);
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t));
            }
          }
          return n;
        }
      }
      function Pg(t, e) {
        return t
          .getAncestors()
          .some(t => t.is('element') && e.includes(t.name));
      }
      function Bg(t, e) {
        let n = t;
        while (n) {
          e(n);
          n = n.parentElement;
        }
      }
      function Rg(t, e) {
        const n = t.isEqualNode(xg);
        return n && Og(t, e) && t.parentNode.childNodes.length === 1;
      }
      function Og(t, e) {
        const n = t.parentNode;
        return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase());
      }
      function Ig(t) {
        if (t === 'script') {
          R('domconverter-unsafe-script-element-detected');
        }
        if (t === 'style') {
          R('domconverter-unsafe-style-element-detected');
        }
      }
      function Mg(t) {
        if (!s.isGecko) {
          return false;
        }
        if (!t.rangeCount) {
          return false;
        }
        const e = t.getRangeAt(0).startContainer;
        try {
          Object.prototype.toString.call(e);
        } catch (t) {
          return true;
        }
        return false;
      }
      class Vg extends Ua() {
        constructor(t) {
          super();
          this._isEnabled = false;
          this.view = t;
          this.document = t.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        destroy() {
          this.disable();
          this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode;
          }
          if (!t || t.nodeType !== 1) {
            return false;
          }
          return t.matches(
            '[data-cke-ignore-events], [data-cke-ignore-events] *',
          );
        }
      }
      var zg = Gf(function (t, e) {
        go(e, Qi(e), t);
      });
      const Fg = zg;
      class Ng {
        constructor(t, e, n) {
          this.view = t;
          this.document = t.document;
          this.domEvent = e;
          this.domTarget = e.target;
          Fg(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Lg extends Vg {
        constructor() {
          super(...arguments);
          this.useCapture = false;
        }
        observe(t) {
          const e =
            typeof this.domEventType == 'string'
              ? [this.domEventType]
              : this.domEventType;
          e.forEach(e => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (
                  this.isEnabled &&
                  !this.checkShouldIgnoreEventFromTarget(e.target)
                ) {
                  this.onDomEvent(e);
                }
              },
              { useCapture: this.useCapture },
            );
          });
        }
        stopObserving(t) {
          this.stopListening(t);
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new Ng(this.view, e, n));
          }
        }
      }
      class Hg extends Lg {
        constructor() {
          super(...arguments);
          this.domEventType = ['keydown', 'keyup'];
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return Wc(this);
            },
          };
          this.fire(t.type, t, e);
        }
      }
      var jg = function () {
        return St.Date.now();
      };
      const qg = jg;
      var $g = /\s/;
      function Wg(t) {
        var e = t.length;
        while (e-- && $g.test(t.charAt(e))) {}
        return e;
      }
      const Gg = Wg;
      var Kg = /^\s+/;
      function Ug(t) {
        return t ? t.slice(0, Gg(t) + 1).replace(Kg, '') : t;
      }
      const Zg = Ug;
      var Jg = 0 / 0;
      var Yg = /^[-+]0x[0-9a-f]+$/i;
      var Qg = /^0b[01]+$/i;
      var Xg = /^0o[0-7]+$/i;
      var tm = parseInt;
      function em(t) {
        if (typeof t == 'number') {
          return t;
        }
        if (ku(t)) {
          return Jg;
        }
        if (ot(t)) {
          var e = typeof t.valueOf == 'function' ? t.valueOf() : t;
          t = ot(e) ? e + '' : e;
        }
        if (typeof t != 'string') {
          return t === 0 ? t : +t;
        }
        t = Zg(t);
        var n = Qg.test(t);
        return n || Xg.test(t)
          ? tm(t.slice(2), n ? 2 : 8)
          : Yg.test(t)
          ? Jg
          : +t;
      }
      const nm = em;
      var om = 'Expected a function';
      var im = Math.max,
        rm = Math.min;
      function sm(t, e, n) {
        var o,
          i,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          h = false,
          u = true;
        if (typeof t != 'function') {
          throw new TypeError(om);
        }
        e = nm(e) || 0;
        if (ot(n)) {
          d = !!n.leading;
          h = 'maxWait' in n;
          r = h ? im(nm(n.maxWait) || 0, e) : r;
          u = 'trailing' in n ? !!n.trailing : u;
        }
        function f(e) {
          var n = o,
            r = i;
          o = i = undefined;
          l = e;
          s = t.apply(r, n);
          return s;
        }
        function p(t) {
          l = t;
          a = setTimeout(k, e);
          return d ? f(t) : s;
        }
        function g(t) {
          var n = t - c,
            o = t - l,
            i = e - n;
          return h ? rm(i, r - o) : i;
        }
        function m(t) {
          var n = t - c,
            o = t - l;
          return c === undefined || n >= e || n < 0 || (h && o >= r);
        }
        function k() {
          var t = qg();
          if (m(t)) {
            return b(t);
          }
          a = setTimeout(k, g(t));
        }
        function b(t) {
          a = undefined;
          if (u && o) {
            return f(t);
          }
          o = i = undefined;
          return s;
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a);
          }
          l = 0;
          o = c = i = a = undefined;
        }
        function _() {
          return a === undefined ? s : b(qg());
        }
        function v() {
          var t = qg(),
            n = m(t);
          o = arguments;
          i = this;
          c = t;
          if (n) {
            if (a === undefined) {
              return p(c);
            }
            if (h) {
              clearTimeout(a);
              a = setTimeout(k, e);
              return f(c);
            }
          }
          if (a === undefined) {
            a = setTimeout(k, e);
          }
          return s;
        }
        v.cancel = w;
        v.flush = _;
        return v;
      }
      const am = sm;
      class cm extends Vg {
        constructor(t) {
          super(t);
          this._fireSelectionChangeDoneDebounced = am(t => {
            this.document.fire('selectionChangeDone', t);
          }, 200);
        }
        observe() {
          const t = this.document;
          t.on(
            'arrowKey',
            (e, n) => {
              const o = t.selection;
              if (o.isFake && this.isEnabled) {
                n.preventDefault();
              }
            },
            { context: '$capture' },
          );
          t.on(
            'arrowKey',
            (e, n) => {
              const o = t.selection;
              if (o.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode);
              }
            },
            { priority: 'lowest' },
          );
        }
        stopObserving() {}
        destroy() {
          super.destroy();
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t) {
          const e = this.document.selection;
          const n = new kp(e.getRanges(), {
            backward: e.isBackward,
            fake: false,
          });
          if (t == qc.arrowleft || t == qc.arrowup) {
            n.setTo(n.getFirstPosition());
          }
          if (t == qc.arrowright || t == qc.arrowdown) {
            n.setTo(n.getLastPosition());
          }
          const o = { oldSelection: e, newSelection: n, domSelection: null };
          this.document.fire('selectionChange', o);
          this._fireSelectionChangeDoneDebounced(o);
        }
      }
      var lm = '__lodash_hash_undefined__';
      function dm(t) {
        this.__data__.set(t, lm);
        return this;
      }
      const hm = dm;
      function um(t) {
        return this.__data__.has(t);
      }
      const fm = um;
      function pm(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.__data__ = new Yn();
        while (++e < n) {
          this.add(t[e]);
        }
      }
      pm.prototype.add = pm.prototype.push = hm;
      pm.prototype.has = fm;
      const gm = pm;
      function mm(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t)) {
            return true;
          }
        }
        return false;
      }
      const km = mm;
      function bm(t, e) {
        return t.has(e);
      }
      const wm = bm;
      var _m = 1,
        vm = 2;
      function Am(t, e, n, o, i, r) {
        var s = n & _m,
          a = t.length,
          c = e.length;
        if (a != c && !(s && c > a)) {
          return false;
        }
        var l = r.get(t);
        var d = r.get(e);
        if (l && d) {
          return l == e && d == t;
        }
        var h = -1,
          u = true,
          f = n & vm ? new gm() : undefined;
        r.set(t, e);
        r.set(e, t);
        while (++h < a) {
          var p = t[h],
            g = e[h];
          if (o) {
            var m = s ? o(g, p, h, e, t, r) : o(p, g, h, t, e, r);
          }
          if (m !== undefined) {
            if (m) {
              continue;
            }
            u = false;
            break;
          }
          if (f) {
            if (
              !km(e, function (t, e) {
                if (!wm(f, e) && (p === t || i(p, t, n, o, r))) {
                  return f.push(e);
                }
              })
            ) {
              u = false;
              break;
            }
          } else if (!(p === g || i(p, g, n, o, r))) {
            u = false;
            break;
          }
        }
        r['delete'](t);
        r['delete'](e);
        return u;
      }
      const Cm = Am;
      function ym(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t, o) {
          n[++e] = [o, t];
        });
        return n;
      }
      const xm = ym;
      function Em(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t) {
          n[++e] = t;
        });
        return n;
      }
      const Dm = Em;
      var Tm = 1,
        Sm = 2;
      var Pm = '[object Boolean]',
        Bm = '[object Date]',
        Rm = '[object Error]',
        Om = '[object Map]',
        Im = '[object Number]',
        Mm = '[object RegExp]',
        Vm = '[object Set]',
        zm = '[object String]',
        Fm = '[object Symbol]';
      var Nm = '[object ArrayBuffer]',
        Lm = '[object DataView]';
      var Hm = Bt ? Bt.prototype : undefined,
        jm = Hm ? Hm.valueOf : undefined;
      function qm(t, e, n, o, i, r, s) {
        switch (n) {
          case Lm:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false;
            }
            t = t.buffer;
            e = e.buffer;
          case Nm:
            if (t.byteLength != e.byteLength || !r(new ss(t), new ss(e))) {
              return false;
            }
            return true;
          case Pm:
          case Bm:
          case Im:
            return me(+t, +e);
          case Rm:
            return t.name == e.name && t.message == e.message;
          case Mm:
          case zm:
            return t == e + '';
          case Om:
            var a = xm;
          case Vm:
            var c = o & Tm;
            a || (a = Dm);
            if (t.size != e.size && !c) {
              return false;
            }
            var l = s.get(t);
            if (l) {
              return l == e;
            }
            o |= Sm;
            s.set(t, e);
            var d = Cm(a(t), a(e), o, i, r, s);
            s['delete'](t);
            return d;
          case Fm:
            if (jm) {
              return jm.call(t) == jm.call(e);
            }
        }
        return false;
      }
      const $m = qm;
      var Wm = 1;
      var Gm = Object.prototype;
      var Km = Gm.hasOwnProperty;
      function Um(t, e, n, o, i, r) {
        var s = n & Wm,
          a = Br(t),
          c = a.length,
          l = Br(e),
          d = l.length;
        if (c != d && !s) {
          return false;
        }
        var h = c;
        while (h--) {
          var u = a[h];
          if (!(s ? u in e : Km.call(e, u))) {
            return false;
          }
        }
        var f = r.get(t);
        var p = r.get(e);
        if (f && p) {
          return f == e && p == t;
        }
        var g = true;
        r.set(t, e);
        r.set(e, t);
        var m = s;
        while (++h < c) {
          u = a[h];
          var k = t[u],
            b = e[u];
          if (o) {
            var w = s ? o(b, k, u, e, t, r) : o(k, b, u, t, e, r);
          }
          if (!(w === undefined ? k === b || i(k, b, n, o, r) : w)) {
            g = false;
            break;
          }
          m || (m = u == 'constructor');
        }
        if (g && !m) {
          var _ = t.constructor,
            v = e.constructor;
          if (
            _ != v &&
            'constructor' in t &&
            'constructor' in e &&
            !(
              typeof _ == 'function' &&
              _ instanceof _ &&
              typeof v == 'function' &&
              v instanceof v
            )
          ) {
            g = false;
          }
        }
        r['delete'](t);
        r['delete'](e);
        return g;
      }
      const Zm = Um;
      var Jm = 1;
      var Ym = '[object Arguments]',
        Qm = '[object Array]',
        Xm = '[object Object]';
      var tk = Object.prototype;
      var ek = tk.hasOwnProperty;
      function nk(t, e, n, o, i, r) {
        var s = Ut(t),
          a = Ut(e),
          c = s ? Qm : ts(t),
          l = a ? Qm : ts(e);
        c = c == Ym ? Xm : c;
        l = l == Ym ? Xm : l;
        var d = c == Xm,
          h = l == Xm,
          u = c == l;
        if (u && Io(t)) {
          if (!Io(e)) {
            return false;
          }
          s = true;
          d = false;
        }
        if (u && !d) {
          r || (r = new no());
          return s || xi(t) ? Cm(t, e, n, o, i, r) : $m(t, e, c, n, o, i, r);
        }
        if (!(n & Jm)) {
          var f = d && ek.call(t, '__wrapped__'),
            p = h && ek.call(e, '__wrapped__');
          if (f || p) {
            var g = f ? t.value() : t,
              m = p ? e.value() : e;
            r || (r = new no());
            return i(g, m, n, o, r);
          }
        }
        if (!u) {
          return false;
        }
        r || (r = new no());
        return Zm(t, e, n, o, i, r);
      }
      const ok = nk;
      function ik(t, e, n, o, i) {
        if (t === e) {
          return true;
        }
        if (t == null || e == null || (!Jt(t) && !Jt(e))) {
          return t !== t && e !== e;
        }
        return ok(t, e, n, o, ik, i);
      }
      const rk = ik;
      function sk(t, e, n) {
        n = typeof n == 'function' ? n : undefined;
        var o = n ? n(t, e) : undefined;
        return o === undefined ? rk(t, e, undefined, n) : !!o;
      }
      const ak = sk;
      class ck extends Vg {
        constructor(t) {
          super(t);
          this._config = {
            childList: true,
            characterData: true,
            subtree: true,
          };
          this.domConverter = t.domConverter;
          this.renderer = t._renderer;
          this._domElements = new Set();
          this._mutationObserver = new window.MutationObserver(
            this._onMutations.bind(this),
          );
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t) {
          this._domElements.add(t);
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        stopObserving(t) {
          this._domElements.delete(t);
          if (this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements) {
              this._mutationObserver.observe(t, this._config);
            }
          }
        }
        enable() {
          super.enable();
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        disable() {
          super.disable();
          this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy();
          this._mutationObserver.disconnect();
        }
        _onMutations(t) {
          if (t.length === 0) {
            return;
          }
          const e = this.domConverter;
          const n = new Set();
          const o = new Set();
          for (const n of t) {
            const t = e.mapDomToView(n.target);
            if (!t) {
              continue;
            }
            if (t.is('uiElement') || t.is('rawElement')) {
              continue;
            }
            if (n.type === 'childList' && !this._isBogusBrMutation(n)) {
              o.add(t);
            }
          }
          for (const i of t) {
            const t = e.mapDomToView(i.target);
            if (t && (t.is('uiElement') || t.is('rawElement'))) {
              continue;
            }
            if (i.type === 'characterData') {
              const t = e.findCorrespondingViewText(i.target);
              if (t && !o.has(t.parent)) {
                n.add(t);
              } else if (!t && rg(i.target)) {
                o.add(e.mapDomToView(i.target.parentNode));
              }
            }
          }
          let i = false;
          for (const t of n) {
            i = true;
            this.renderer.markToSync('text', t);
          }
          for (const t of o) {
            const n = e.mapViewToDom(t);
            const o = Array.from(t.getChildren());
            const r = Array.from(
              e.domChildrenToView(n, { withChildren: false }),
            );
            if (!ak(o, r, lk)) {
              i = true;
              this.renderer.markToSync('children', t);
            }
          }
          if (i) {
            this.view.forceRender();
          }
        }
        _isBogusBrMutation(t) {
          let e = null;
          if (
            t.nextSibling === null &&
            t.removedNodes.length === 0 &&
            t.addedNodes.length == 1
          ) {
            e = this.domConverter.domToView(t.addedNodes[0], {
              withChildren: false,
            });
          }
          return e && e.is('element', 'br');
        }
      }
      function lk(t, e) {
        if (Array.isArray(t)) {
          return;
        }
        if (t === e) {
          return true;
        } else if (t.is('$text') && e.is('$text')) {
          return t.data === e.data;
        }
        return false;
      }
      class dk extends Lg {
        constructor(t) {
          super(t);
          this._isFocusChanging = false;
          this.domEventType = ['focus', 'blur'];
          this.useCapture = true;
          const e = this.document;
          e.on('focus', () => {
            this._isFocusChanging = true;
            this._renderTimeoutId = setTimeout(() => {
              this.flush();
              t.change(() => {});
            }, 50);
          });
          e.on('blur', (n, o) => {
            const i = e.selection.editableElement;
            if (i === null || i === o.target) {
              e.isFocused = false;
              this._isFocusChanging = false;
              t.change(() => {});
            }
          });
        }
        flush() {
          if (this._isFocusChanging) {
            this._isFocusChanging = false;
            this.document.isFocused = true;
          }
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId);
          }
          super.destroy();
        }
      }
      class hk extends Vg {
        constructor(t) {
          super(t);
          this.mutationObserver = t.getObserver(ck);
          this.focusObserver = t.getObserver(dk);
          this.selection = this.document.selection;
          this.domConverter = t.domConverter;
          this._documents = new WeakSet();
          this._fireSelectionChangeDoneDebounced = am(t => {
            this.document.fire('selectionChangeDone', t);
          }, 200);
          this._clearInfiniteLoopInterval = setInterval(
            () => this._clearInfiniteLoop(),
            1e3,
          );
          this._documentIsSelectingInactivityTimeoutDebounced = am(
            () => (this.document.isSelecting = false),
            5e3,
          );
          this._loopbackCounter = 0;
        }
        observe(t) {
          const e = t.ownerDocument;
          const n = () => {
            this.document.isSelecting = true;
            this._documentIsSelectingInactivityTimeoutDebounced();
          };
          const o = () => {
            if (!this.document.isSelecting) {
              return;
            }
            this._handleSelectionChange(null, e);
            this.document.isSelecting = false;
            this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          };
          this.listenTo(t, 'selectstart', n, { priority: 'highest' });
          this.listenTo(t, 'keydown', o, {
            priority: 'highest',
            useCapture: true,
          });
          this.listenTo(t, 'keyup', o, {
            priority: 'highest',
            useCapture: true,
          });
          if (this._documents.has(e)) {
            return;
          }
          this.listenTo(e, 'mouseup', o, {
            priority: 'highest',
            useCapture: true,
          });
          this.listenTo(e, 'selectionchange', (t, n) => {
            if (this.document.isComposing && !s.isAndroid) {
              return;
            }
            this._handleSelectionChange(n, e);
            this._documentIsSelectingInactivityTimeoutDebounced();
          });
          this._documents.add(e);
        }
        stopObserving(t) {
          this.stopListening(t);
        }
        destroy() {
          super.destroy();
          clearInterval(this._clearInfiniteLoopInterval);
          this._fireSelectionChangeDoneDebounced.cancel();
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {}
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return;
          }
          const n = e.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return;
          }
          this.mutationObserver.flush();
          const o = this.domConverter.domSelectionToView(n);
          if (o.rangeCount == 0) {
            this.view.hasDomSelection = false;
            return;
          }
          this.view.hasDomSelection = true;
          this.focusObserver.flush();
          if (
            this.selection.isEqual(o) &&
            this.domConverter.isDomSelectionCorrect(n)
          ) {
            return;
          }
          if (++this._loopbackCounter > 60) {
            this._reportInfiniteLoop();
            return;
          }
          if (this.selection.isSimilar(o)) {
            this.view.forceRender();
          } else {
            const t = {
              oldSelection: this.selection,
              newSelection: o,
              domSelection: n,
            };
            this.document.fire('selectionChange', t);
            this._fireSelectionChangeDoneDebounced(t);
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class uk extends Lg {
        constructor(t) {
          super(t);
          this.domEventType = [
            'compositionstart',
            'compositionupdate',
            'compositionend',
          ];
          const e = this.document;
          e.on(
            'compositionstart',
            () => {
              e.isComposing = true;
            },
            { priority: 'low' },
          );
          e.on(
            'compositionend',
            () => {
              e.isComposing = false;
            },
            { priority: 'low' },
          );
        }
        onDomEvent(t) {
          this.fire(t.type, t, { data: t.data });
        }
      }
      class fk {
        constructor(t, e = {}) {
          this._files = e.cacheFiles ? pk(t) : null;
          this._native = t;
        }
        get files() {
          if (!this._files) {
            this._files = pk(this._native);
          }
          return this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(t) {
          return this._native.getData(t);
        }
        setData(t, e) {
          this._native.setData(t, e);
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(t) {
          this._native.dropEffect = t;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(t, e, n) {
          this._native.setDragImage(t, e, n);
        }
        get isCanceled() {
          return (
            this._native.dropEffect == 'none' || !!this._native.mozUserCancelled
          );
        }
      }
      function pk(t) {
        const e = Array.from(t.files || []);
        const n = Array.from(t.items || []);
        if (e.length) {
          return e;
        }
        return n.filter(t => t.kind === 'file').map(t => t.getAsFile());
      }
      class gk extends Lg {
        constructor() {
          super(...arguments);
          this.domEventType = 'beforeinput';
        }
        onDomEvent(t) {
          const e = t.getTargetRanges();
          const n = this.view;
          const o = n.document;
          let i = null;
          let r = null;
          let a = [];
          if (t.dataTransfer) {
            i = new fk(t.dataTransfer);
          }
          if (t.data !== null) {
            r = t.data;
          } else if (i) {
            r = i.getData('text/plain');
          }
          if (o.selection.isFake) {
            a = Array.from(o.selection.getRanges());
          } else if (e.length) {
            a = e
              .map(t => {
                const e = n.domConverter.domPositionToView(
                  t.startContainer,
                  t.startOffset,
                );
                const o = n.domConverter.domPositionToView(
                  t.endContainer,
                  t.endOffset,
                );
                if (e) {
                  return n.createRange(e, o);
                } else if (o) {
                  return n.createRange(o);
                }
              })
              .filter(t => !!t);
          } else if (s.isAndroid) {
            const e = t.target.ownerDocument.defaultView.getSelection();
            a = Array.from(n.domConverter.domSelectionToView(e).getRanges());
          }
          if (
            s.isAndroid &&
            t.inputType == 'insertCompositionText' &&
            r &&
            r.endsWith('\n')
          ) {
            this.fire(t.type, t, {
              inputType: 'insertParagraph',
              targetRanges: [n.createRange(a[0].end)],
            });
            return;
          }
          if (t.inputType == 'insertText' && r && r.includes('\n')) {
            const e = r.split(/\n{1,2}/g);
            let n = a;
            for (let r = 0; r < e.length; r++) {
              const s = e[r];
              if (s != '') {
                this.fire(t.type, t, {
                  data: s,
                  dataTransfer: i,
                  targetRanges: n,
                  inputType: t.inputType,
                  isComposing: t.isComposing,
                });
                n = [o.selection.getFirstRange()];
              }
              if (r + 1 < e.length) {
                this.fire(t.type, t, {
                  inputType: 'insertParagraph',
                  targetRanges: n,
                });
                n = [o.selection.getFirstRange()];
              }
            }
            return;
          }
          this.fire(t.type, t, {
            data: r,
            dataTransfer: i,
            targetRanges: a,
            inputType: t.inputType,
            isComposing: t.isComposing,
          });
        }
      }
      class mk extends Vg {
        constructor(t) {
          super(t);
          this.document.on('keydown', (t, e) => {
            if (this.isEnabled && Uc(e.keyCode)) {
              const n = new wp(
                this.document,
                'arrowKey',
                this.document.selection.getFirstRange(),
              );
              this.document.fire(n, e);
              if (n.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      class kk extends Vg {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on('keydown', (t, n) => {
            if (!this.isEnabled || n.keyCode != qc.tab || n.ctrlKey) {
              return;
            }
            const o = new wp(e, 'tab', e.selection.getFirstRange());
            e.fire(o, n);
            if (o.stop.called) {
              t.stop();
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      var bk = 1,
        wk = 4;
      function _k(t) {
        return Ma(t, bk | wk);
      }
      const vk = _k;
      class Ak extends dt() {
        constructor(t) {
          super();
          this.domRoots = new Map();
          this._initialDomRootAttributes = new WeakMap();
          this._observers = new Map();
          this._ongoingChange = false;
          this._postFixersInProgress = false;
          this._renderingDisabled = false;
          this._hasChangedSinceTheLastRendering = false;
          this.document = new Dp(t);
          this.domConverter = new Sg(this.document);
          this.set('isRenderingInProgress', false);
          this.set('hasDomSelection', false);
          this._renderer = new pg(this.domConverter, this.document.selection);
          this._renderer
            .bind('isFocused', 'isSelecting', 'isComposing')
            .to(this.document, 'isFocused', 'isSelecting', 'isComposing');
          this._writer = new jp(this.document);
          this.addObserver(ck);
          this.addObserver(dk);
          this.addObserver(hk);
          this.addObserver(Hg);
          this.addObserver(cm);
          this.addObserver(uk);
          this.addObserver(mk);
          this.addObserver(gk);
          this.addObserver(kk);
          cg(this);
          Mp(this);
          this.on('render', () => {
            this._render();
            this.document.fire('layoutChanged');
            this._hasChangedSinceTheLastRendering = false;
          });
          this.listenTo(this.document.selection, 'change', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          this.listenTo(this.document, 'change:isFocused', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          if (s.isiOS) {
            this.listenTo(this.document, 'blur', (t, e) => {
              const n = this.domConverter.mapDomToView(
                e.domEvent.relatedTarget,
              );
              if (!n) {
                this.domConverter._clearDomSelection();
              }
            });
          }
        }
        attachDomRoot(t, e = 'main') {
          const n = this.document.getRoot(e);
          n._name = t.tagName.toLowerCase();
          const o = {};
          for (const { name: e, value: i } of Array.from(t.attributes)) {
            o[e] = i;
            if (e === 'class') {
              this._writer.addClass(i.split(' '), n);
            } else {
              this._writer.setAttribute(e, i, n);
            }
          }
          this._initialDomRootAttributes.set(t, o);
          const i = () => {
            this._writer.setAttribute(
              'contenteditable',
              (!n.isReadOnly).toString(),
              n,
            );
            if (n.isReadOnly) {
              this._writer.addClass('ck-read-only', n);
            } else {
              this._writer.removeClass('ck-read-only', n);
            }
          };
          i();
          this.domRoots.set(e, t);
          this.domConverter.bindElements(t, n);
          this._renderer.markToSync('children', n);
          this._renderer.markToSync('attributes', n);
          this._renderer.domDocuments.add(t.ownerDocument);
          n.on('change:children', (t, e) =>
            this._renderer.markToSync('children', e),
          );
          n.on('change:attributes', (t, e) =>
            this._renderer.markToSync('attributes', e),
          );
          n.on('change:text', (t, e) => this._renderer.markToSync('text', e));
          n.on('change:isReadOnly', () => this.change(i));
          n.on('change', () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n of this._observers.values()) {
            n.observe(t, e);
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t);
          Array.from(e.attributes).forEach(({ name: t }) =>
            e.removeAttribute(t),
          );
          const n = this._initialDomRootAttributes.get(e);
          for (const t in n) {
            e.setAttribute(t, n[t]);
          }
          this.domRoots.delete(t);
          this.domConverter.unbindDomElement(e);
          for (const t of this._observers.values()) {
            t.stopObserving(e);
          }
        }
        getDomRoot(t = 'main') {
          return this.domRoots.get(t);
        }
        addObserver(t) {
          let e = this._observers.get(t);
          if (e) {
            return e;
          }
          e = new t(this);
          this._observers.set(t, e);
          for (const [t, n] of this.domRoots) {
            e.observe(n, t);
          }
          e.enable();
          return e;
        }
        getObserver(t) {
          return this._observers.get(t);
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable();
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable();
          }
        }
        scrollToTheSelection({
          alignToTop: t,
          forceScroll: e,
          viewportOffset: n = 20,
          ancestorOffset: o = 20,
        } = {}) {
          const i = this.document.selection.getFirstRange();
          if (!i) {
            return;
          }
          const r = vk({
            alignToTop: t,
            forceScroll: e,
            viewportOffset: n,
            ancestorOffset: o,
          });
          if (typeof n === 'number') {
            n = { top: n, bottom: n, left: n, right: n };
          }
          const s = {
            target: this.domConverter.viewRangeToDom(i),
            viewportOffset: n,
            ancestorOffset: o,
            alignToTop: t,
            forceScroll: e,
          };
          this.fire('scrollToTheSelection', s, r);
          Sc(s);
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
              this.forceRender();
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new B('cannot-change-view-tree', this);
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer);
            }
            this._ongoingChange = true;
            const e = t(this._writer);
            this._ongoingChange = false;
            if (
              !this._renderingDisabled &&
              this._hasChangedSinceTheLastRendering
            ) {
              this._postFixersInProgress = true;
              this.document._callPostFixers(this._writer);
              this._postFixersInProgress = false;
              this.fire('render');
            }
            return e;
          } catch (t) {
            B.rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true;
          this.getObserver(dk).flush();
          this.change(() => {});
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy();
          }
          this.document.destroy();
          this.stopListening();
        }
        createPositionAt(t, e) {
          return pp._createAt(t, e);
        }
        createPositionAfter(t) {
          return pp._createAfter(t);
        }
        createPositionBefore(t) {
          return pp._createBefore(t);
        }
        createRange(t, e) {
          return new gp(t, e);
        }
        createRangeOn(t) {
          return gp._createOn(t);
        }
        createRangeIn(t) {
          return gp._createIn(t);
        }
        createSelection(...t) {
          return new kp(...t);
        }
        _disableRendering(t) {
          this._renderingDisabled = t;
          if (t == false) {
            this.change(() => {});
          }
        }
        _render() {
          this.isRenderingInProgress = true;
          this.disableObservers();
          this._renderer.render();
          this.enableObservers();
          this.isRenderingInProgress = false;
        }
      }
      class Ck {
        is() {
          throw new Error('is() method is abstract');
        }
      }
      class yk extends Ck {
        constructor(t) {
          super();
          this.parent = null;
          this._attrs = gl(t);
        }
        get document() {
          return null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new B('model-node-not-found-in-parent', this);
          }
          return t;
        }
        get startOffset() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new B('model-node-not-found-in-parent', this);
          }
          return t;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          if (!this.parent) {
            return null;
          }
          return this.startOffset + this.offsetSize;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.parent === null ? false : this.root.isAttached();
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.startOffset);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = Ct(e, n);
          switch (o) {
            case 'prefix':
              return true;
            case 'extension':
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t = {};
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1];
              return t;
            }, {});
          }
          return t;
        }
        _clone(t) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e);
        }
        _setAttributesTo(t) {
          this._attrs = gl(t);
        }
        _removeAttribute(t) {
          return this._attrs.delete(t);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      yk.prototype.is = function (t) {
        return t === 'node' || t === 'model:node';
      };
      class xk {
        constructor(t) {
          this._nodes = [];
          if (t) {
            this._insertNodes(0, t);
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
        }
        getNode(t) {
          return this._nodes[t] || null;
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t);
          return e == -1 ? null : e;
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t);
          return e === null
            ? null
            : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset;
          }
          const e = this._nodes[t];
          if (!e) {
            throw new B('model-nodelist-index-out-of-bounds', this);
          }
          return this.getNodeStartOffset(e);
        }
        offsetToIndex(t) {
          let e = 0;
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n);
            }
            e += n.offsetSize;
          }
          if (e != t) {
            throw new B('model-nodelist-offset-out-of-bounds', this, {
              offset: t,
              nodeList: this,
            });
          }
          return this.length;
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof yk)) {
              throw new B('model-nodelist-insertnodes-not-node', this);
            }
          }
          this._nodes = kl(this._nodes, Array.from(e), t, 0);
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e);
        }
        toJSON() {
          return this._nodes.map(t => t.toJSON());
        }
      }
      class Ek extends yk {
        constructor(t, e) {
          super(e);
          this._data = t || '';
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const t = super.toJSON();
          t.data = this.data;
          return t;
        }
        _clone() {
          return new Ek(this.data, this.getAttributes());
        }
        static fromJSON(t) {
          return new Ek(t.data, t.attributes);
        }
      }
      Ek.prototype.is = function (t) {
        return (
          t === '$text' ||
          t === 'model:$text' ||
          t === 'text' ||
          t === 'model:text' ||
          t === 'node' ||
          t === 'model:node'
        );
      };
      class Dk extends Ck {
        constructor(t, e, n) {
          super();
          this.textNode = t;
          if (e < 0 || e > t.offsetSize) {
            throw new B('model-textproxy-wrong-offsetintext', this);
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new B('model-textproxy-wrong-length', this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null
            ? this.startOffset + this.offsetSize
            : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const t = this.textNode.getPath();
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText;
          }
          return t;
        }
        getAncestors(t = {}) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? 'push' : 'unshift'](n);
            n = n.parent;
          }
          return e;
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t);
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Dk.prototype.is = function (t) {
        return (
          t === '$textProxy' ||
          t === 'model:$textProxy' ||
          t === 'textProxy' ||
          t === 'model:textProxy'
        );
      };
      class Tk extends yk {
        constructor(t, e, n) {
          super(e);
          this._children = new xk();
          this.name = t;
          if (n) {
            this._insertChild(0, n);
          }
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent;
          while (n) {
            if (n.name === t) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.name = this.name;
          if (this._children.length > 0) {
            t.children = [];
            for (const e of this._children) {
              t.children.push(e.toJSON());
            }
          }
          return t;
        }
        _clone(t = false) {
          const e = t
            ? Array.from(this._children).map(t => t._clone(true))
            : undefined;
          return new Tk(this.name, this.getAttributes(), e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Sk(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
        static fromJSON(t) {
          let e;
          if (t.children) {
            e = [];
            for (const n of t.children) {
              if (n.name) {
                e.push(Tk.fromJSON(n));
              } else {
                e.push(Ek.fromJSON(n));
              }
            }
          }
          return new Tk(t.name, t.attributes, e);
        }
      }
      Tk.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'element' ||
            t === 'model:element' ||
            t === 'node' ||
            t === 'model:node'
          );
        }
        return e === this.name && (t === 'element' || t === 'model:element');
      };
      function Sk(t) {
        if (typeof t == 'string') {
          return [new Ek(t)];
        }
        if (!yt(t)) {
          t = [t];
        }
        return Array.from(t).map(t => {
          if (typeof t == 'string') {
            return new Ek(t);
          }
          if (t instanceof Dk) {
            return new Ek(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Pk {
        constructor(t) {
          if (!t || (!t.boundaries && !t.startPosition)) {
            throw new B('model-tree-walker-no-start-position', null);
          }
          const e = t.direction || 'forward';
          if (e != 'forward' && e != 'backward') {
            throw new B('model-tree-walker-unknown-direction', t, {
              direction: e,
            });
          }
          this.direction = e;
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this._position = t.startPosition.clone();
          } else {
            this._position = Rk._createAt(
              this.boundaries[this.direction == 'backward' ? 'end' : 'start'],
            );
          }
          this.position.stickiness = 'toNone';
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
          this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t) {
          let e, n, o, i;
          do {
            o = this.position;
            i = this._visitedParent;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this._position = o;
            this._visitedParent = i;
          }
        }
        next() {
          if (this.direction == 'forward') {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined };
          }
          if (
            n === this._boundaryEndParent &&
            e.offset == this.boundaries.end.offset
          ) {
            return { done: true, value: undefined };
          }
          const o = Ok(e, n);
          const i = o || Ik(e, n, o);
          if (i instanceof Tk) {
            if (!this.shallow) {
              e.path.push(0);
              this._visitedParent = i;
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(e)) {
                return { done: true, value: undefined };
              }
              e.offset++;
            }
            this._position = e;
            return Bk('elementStart', i, t, e, 1);
          }
          if (i instanceof Ek) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = i.endOffset;
              if (
                this._boundaryEndParent == n &&
                this.boundaries.end.offset < t
              ) {
                t = this.boundaries.end.offset;
              }
              o = t - e.offset;
            }
            const r = e.offset - i.startOffset;
            const s = new Dk(i, r, o);
            e.offset += o;
            this._position = e;
            return Bk('text', s, t, e, o);
          }
          e.path.pop();
          e.offset++;
          this._position = e;
          this._visitedParent = n.parent;
          if (this.ignoreElementEnd) {
            return this._next();
          }
          return Bk('elementEnd', n, t, e);
        }
        _previous() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined };
          }
          if (
            n == this._boundaryStartParent &&
            e.offset == this.boundaries.start.offset
          ) {
            return { done: true, value: undefined };
          }
          const o = e.parent;
          const i = Ok(e, o);
          const r = i || Mk(e, o, i);
          if (r instanceof Tk) {
            e.offset--;
            if (this.shallow) {
              this._position = e;
              return Bk('elementStart', r, t, e, 1);
            }
            e.path.push(r.maxOffset);
            this._position = e;
            this._visitedParent = r;
            if (this.ignoreElementEnd) {
              return this._previous();
            }
            return Bk('elementEnd', r, t, e);
          }
          if (r instanceof Ek) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = r.startOffset;
              if (
                this._boundaryStartParent == n &&
                this.boundaries.start.offset > t
              ) {
                t = this.boundaries.start.offset;
              }
              o = e.offset - t;
            }
            const i = e.offset - r.startOffset;
            const s = new Dk(r, i - o, o);
            e.offset -= o;
            this._position = e;
            return Bk('text', s, t, e, o);
          }
          e.path.pop();
          this._position = e;
          this._visitedParent = n.parent;
          return Bk('elementStart', n, t, e, 1);
        }
      }
      function Bk(t, e, n, o, i) {
        return {
          done: false,
          value: {
            type: t,
            item: e,
            previousPosition: n,
            nextPosition: o,
            length: i,
          },
        };
      }
      class Rk extends Ck {
        constructor(t, e, n = 'toNone') {
          super();
          if (!t.is('element') && !t.is('documentFragment')) {
            throw new B('model-position-root-invalid', t);
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new B('model-position-path-incorrect-format', t, { path: e });
          }
          if (t.is('rootElement')) {
            e = e.slice();
          } else {
            e = [...t.getPath(), ...e];
            t = t.root;
          }
          this.root = t;
          this.path = e;
          this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t) {
          this.path[this.path.length - 1] = t;
        }
        get parent() {
          let t = this.root;
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]));
            if (!t) {
              throw new B('model-position-path-incorrect', this, {
                position: this,
              });
            }
          }
          if (t.is('$text')) {
            throw new B('model-position-path-incorrect', this, {
              position: this,
            });
          }
          return t;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Ok(this, this.parent);
        }
        get nodeAfter() {
          const t = this.parent;
          return Ik(this, t, Ok(this, t));
        }
        get nodeBefore() {
          const t = this.parent;
          return Mk(this, t, Ok(this, t));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t) {
          if (this.root != t.root) {
            return 'different';
          }
          const e = Ct(this.path, t.path);
          switch (e) {
            case 'same':
              return 'same';
            case 'prefix':
              return 'before';
            case 'extension':
              return 'after';
            default:
              return this.path[e] < t.path[e] ? 'before' : 'after';
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new Pk(e);
          n.skip(t);
          return n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t = this.parent;
          if (t.is('documentFragment')) {
            return [t];
          } else {
            return t.getAncestors({ includeSelf: true });
          }
        }
        findAncestor(t) {
          const e = this.parent;
          if (e.is('element')) {
            return e.findAncestor(t, { includeSelf: true });
          }
          return null;
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return [];
          }
          const e = Ct(this.path, t.path);
          const n =
            typeof e == 'string'
              ? Math.min(this.path.length, t.path.length)
              : e;
          return this.path.slice(0, n);
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        getShiftedBy(t) {
          const e = this.clone();
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        isAfter(t) {
          return this.compareWith(t) == 'after';
        }
        isBefore(t) {
          return this.compareWith(t) == 'before';
        }
        isEqual(t) {
          return this.compareWith(t) == 'same';
        }
        isTouching(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = Math.min(this.path.length, t.path.length);
          for (let n = 0; n < e; n++) {
            const e = this.path[n] - t.path[n];
            if (e < -1 || e > 1) {
              return false;
            } else if (e === 1) {
              return Vk(t, this, n);
            } else if (e === -1) {
              return Vk(this, t, n);
            }
          }
          if (this.path.length === t.path.length) {
            return true;
          } else if (this.path.length > t.path.length) {
            return zk(this.path, e);
          } else {
            return zk(t.path, e);
          }
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getParentPath();
          const n = t.getParentPath();
          return Ct(e, n) == 'same';
        }
        getTransformedByOperation(t) {
          let e;
          switch (t.type) {
            case 'insert':
              e = this._getTransformedByInsertOperation(t);
              break;
            case 'move':
            case 'remove':
            case 'reinsert':
              e = this._getTransformedByMoveOperation(t);
              break;
            case 'split':
              e = this._getTransformedBySplitOperation(t);
              break;
            case 'merge':
              e = this._getTransformedByMergeOperation(t);
              break;
            default:
              e = Rk._createAt(this);
              break;
          }
          return e;
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany);
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(
            t.sourcePosition,
            t.targetPosition,
            t.howMany,
          );
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange;
          const n =
            e.containsPosition(this) ||
            (e.start.isEqual(this) && this.stickiness == 'toNext');
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition);
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(
                t.graveyardPosition,
                t.insertionPosition,
                1,
              );
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1);
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange;
          const n = e.containsPosition(this) || e.start.isEqual(this);
          let o;
          if (n) {
            o = this._getCombined(t.sourcePosition, t.targetPosition);
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              o = o._getTransformedByDeletion(t.deletionPosition, 1);
            }
          } else if (this.isEqual(t.deletionPosition)) {
            o = Rk._createAt(t.deletionPosition);
          } else {
            o = this._getTransformedByMove(
              t.deletionPosition,
              t.graveyardPosition,
              1,
            );
          }
          return o;
        }
        _getTransformedByDeletion(t, e) {
          const n = Rk._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Ct(t.getParentPath(), this.getParentPath()) == 'same') {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null;
              } else {
                n.offset -= e;
              }
            }
          } else if (Ct(t.getParentPath(), this.getParentPath()) == 'prefix') {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              if (t.offset + e > this.path[o]) {
                return null;
              } else {
                n.path[o] -= e;
              }
            }
          }
          return n;
        }
        _getTransformedByInsertion(t, e) {
          const n = Rk._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Ct(t.getParentPath(), this.getParentPath()) == 'same') {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset && this.stickiness != 'toPrevious')
            ) {
              n.offset += e;
            }
          } else if (Ct(t.getParentPath(), this.getParentPath()) == 'prefix') {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              n.path[o] += e;
            }
          }
          return n;
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n);
          if (t.isEqual(e)) {
            return Rk._createAt(this);
          }
          const o = this._getTransformedByDeletion(t, n);
          const i =
            o === null ||
            (t.isEqual(this) && this.stickiness == 'toNext') ||
            (t.getShiftedBy(n).isEqual(this) &&
              this.stickiness == 'toPrevious');
          if (i) {
            return this._getCombined(t, e);
          } else {
            return o._getTransformedByInsertion(e, n);
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1;
          const o = Rk._createAt(e);
          o.stickiness = this.stickiness;
          o.offset = o.offset + this.path[n] - t.offset;
          o.path = [...o.path, ...this.path.slice(n + 1)];
          return o;
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(t, e, n = 'toNone') {
          if (t instanceof Rk) {
            return new Rk(t.root, t.path, t.stickiness);
          } else {
            const o = t;
            if (e == 'end') {
              e = o.maxOffset;
            } else if (e == 'before') {
              return this._createBefore(o, n);
            } else if (e == 'after') {
              return this._createAfter(o, n);
            } else if (e !== 0 && !e) {
              throw new B('model-createpositionat-offset-required', [this, t]);
            }
            if (!o.is('element') && !o.is('documentFragment')) {
              throw new B('model-position-parent-incorrect', [this, t]);
            }
            const i = o.getPath();
            i.push(e);
            return new this(o.root, i, n);
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new B('model-position-after-root', [this, t], { root: t });
          }
          return this._createAt(t.parent, t.endOffset, e);
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new B('model-position-before-root', t, { root: t });
          }
          return this._createAt(t.parent, t.startOffset, e);
        }
        static fromJSON(t, e) {
          if (t.root === '$graveyard') {
            const n = new Rk(e.graveyard, t.path);
            n.stickiness = t.stickiness;
            return n;
          }
          if (!e.getRoot(t.root)) {
            throw new B('model-position-fromjson-no-root', e, {
              rootName: t.root,
            });
          }
          return new Rk(e.getRoot(t.root), t.path, t.stickiness);
        }
      }
      Rk.prototype.is = function (t) {
        return t === 'position' || t === 'model:position';
      };
      function Ok(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset));
        if (n && n.is('$text') && n.startOffset < t.offset) {
          return n;
        }
        return null;
      }
      function Ik(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset));
      }
      function Mk(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1);
      }
      function Vk(t, e, n) {
        if (n + 1 === t.path.length) {
          return false;
        }
        if (!zk(e.path, n + 1)) {
          return false;
        }
        if (!Fk(t, n + 1)) {
          return false;
        }
        return true;
      }
      function zk(t, e) {
        while (e < t.length) {
          if (t[e] !== 0) {
            return false;
          }
          e++;
        }
        return true;
      }
      function Fk(t, e) {
        let n = t.parent;
        let o = t.path.length - 1;
        let i = 0;
        while (o >= e) {
          if (t.path[o] + i !== n.maxOffset) {
            return false;
          }
          i = 1;
          o--;
          n = n.parent;
        }
        return true;
      }
      class Nk extends Ck {
        constructor(t, e) {
          super();
          this.start = Rk._createAt(t);
          this.end = e ? Rk._createAt(e) : Rk._createAt(t);
          this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';
          this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';
        }
        *[Symbol.iterator]() {
          yield* new Pk({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          const t = this.start.getParentPath();
          const e = this.end.getParentPath();
          return Ct(t, e) == 'same';
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const o =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        containsItem(t) {
          const e = Rk._createBefore(t);
          return this.containsPosition(e) || this.start.isEqual(e);
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end);
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Nk(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new Nk(t.end, this.end));
            }
          } else {
            e.push(new Nk(this.start, this.end));
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new Nk(e, n);
          }
          return null;
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t);
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start);
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start);
            }
          }
          if (!n) {
            return null;
          }
          let o = this.start;
          let i = this.end;
          if (t.start.isBefore(o)) {
            o = t.start;
          }
          if (t.end.isAfter(i)) {
            i = t.end;
          }
          return new Nk(o, i);
        }
        getMinimalFlatRanges() {
          const t = [];
          const e = this.start.getCommonPath(this.end).length;
          const n = Rk._createAt(this.start);
          let o = n.parent;
          while (n.path.length > e + 1) {
            const e = o.maxOffset - n.offset;
            if (e !== 0) {
              t.push(new Nk(n, n.getShiftedBy(e)));
            }
            n.path = n.path.slice(0, -1);
            n.offset++;
            o = o.parent;
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1];
            const o = e - n.offset;
            if (o !== 0) {
              t.push(new Nk(n, n.getShiftedBy(o)));
            }
            n.offset = e;
            n.path.push(0);
          }
          return t;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new Pk(t);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new Pk(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new Pk(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case 'insert':
              return this._getTransformedByInsertOperation(t);
            case 'move':
            case 'remove':
            case 'reinsert':
              return this._getTransformedByMoveOperation(t);
            case 'split':
              return [this._getTransformedBySplitOperation(t)];
            case 'merge':
              return [this._getTransformedByMergeOperation(t)];
          }
          return [new Nk(this.start, this.end)];
        }
        getTransformedByOperations(t) {
          const e = [new Nk(this.start, this.end)];
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const o = e[t].getTransformedByOperation(n);
              e.splice(t, 1, ...o);
              t += o.length - 1;
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            for (let o = t + 1; o < e.length; o++) {
              const t = e[o];
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(o, 1);
              }
            }
          }
          return e;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          const t = this.start.nodeAfter;
          const e = this.end.nodeBefore;
          if (t && t.is('element') && t === e) {
            return t;
          }
          return null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e);
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition;
          const o = t.howMany;
          const i = t.targetPosition;
          return this._getTransformedByMove(n, i, o, e);
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t);
          let n = this.end._getTransformedBySplitOperation(t);
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1);
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          return new Nk(e, n);
        }
        _getTransformedByMergeOperation(t) {
          if (
            this.start.isEqual(t.targetPosition) &&
            this.end.isEqual(t.deletionPosition)
          ) {
            return new Nk(this.start);
          }
          let e = this.start._getTransformedByMergeOperation(t);
          let n = this.end._getTransformedByMergeOperation(t);
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = Rk._createAt(n);
              e.offset = 0;
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition;
              }
              e = t.targetPosition;
            }
            return new Nk(e, n);
          }
          return new Nk(e, n);
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new Nk(this.start, t),
              new Nk(
                t.getShiftedBy(e),
                this.end._getTransformedByInsertion(t, e),
              ),
            ];
          } else {
            const n = new Nk(this.start, this.end);
            n.start = n.start._getTransformedByInsertion(t, e);
            n.end = n.end._getTransformedByInsertion(t, e);
            return [n];
          }
        }
        _getTransformedByMove(t, e, n, o = false) {
          if (this.isCollapsed) {
            const o = this.start._getTransformedByMove(t, e, n);
            return [new Nk(o)];
          }
          const i = Nk._createFromPositionAndShift(t, n);
          const r = e._getTransformedByDeletion(t, n);
          if (this.containsPosition(e) && !o) {
            if (
              i.containsPosition(this.start) ||
              i.containsPosition(this.end)
            ) {
              const o = this.start._getTransformedByMove(t, e, n);
              const i = this.end._getTransformedByMove(t, e, n);
              return [new Nk(o, i)];
            }
          }
          let s;
          const a = this.getDifference(i);
          let c = null;
          const l = this.getIntersection(i);
          if (a.length == 1) {
            c = new Nk(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n),
            );
          } else if (a.length == 2) {
            c = new Nk(this.start, this.end._getTransformedByDeletion(t, n));
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || o);
          } else {
            s = [];
          }
          if (l) {
            const t = new Nk(
              l.start._getCombined(i.start, r),
              l.end._getCombined(i.start, r),
            );
            if (s.length == 2) {
              s.splice(1, 0, t);
            } else {
              s.push(t);
            }
          }
          return s;
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e);
          let o = this.end._getTransformedByDeletion(t, e);
          if (n == null && o == null) {
            return null;
          }
          if (n == null) {
            n = t;
          }
          if (o == null) {
            o = t;
          }
          return new Nk(n, o);
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return new this(Rk._createAt(t, 0), Rk._createAt(t, t.maxOffset));
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(
            Rk._createBefore(t),
            t.offsetSize,
          );
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new B('range-create-from-ranges-empty-array', null);
          } else if (t.length == 1) {
            return t[0].clone();
          }
          const e = t[0];
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
          const n = t.indexOf(e);
          const o = new this(e.start, e.end);
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(o.start)) {
                o.start = Rk._createAt(t[e].start);
              } else {
                break;
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(o.end)) {
              o.end = Rk._createAt(t[e].end);
            } else {
              break;
            }
          }
          return o;
        }
        static fromJSON(t, e) {
          return new this(Rk.fromJSON(t.start, e), Rk.fromJSON(t.end, e));
        }
      }
      Nk.prototype.is = function (t) {
        return t === 'range' || t === 'model:range';
      };
      class Lk extends $() {
        constructor() {
          super();
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._viewToModelLengthCallbacks = new Map();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._deferredBindingRemovals = new Map();
          this._unboundMarkerNames = new Set();
          this.on(
            'modelToViewPosition',
            (t, e) => {
              if (e.viewPosition) {
                return;
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent);
              if (!n) {
                throw new B(
                  'mapping-model-position-view-parent-not-found',
                  this,
                  { modelPosition: e.modelPosition },
                );
              }
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
            },
            { priority: 'low' },
          );
          this.on(
            'viewToModelPosition',
            (t, e) => {
              if (e.modelPosition) {
                return;
              }
              const n = this.findMappedViewAncestor(e.viewPosition);
              const o = this._viewToModelMapping.get(n);
              const i = this._toModelOffset(
                e.viewPosition.parent,
                e.viewPosition.offset,
                n,
              );
              e.modelPosition = Rk._createAt(o, i);
            },
            { priority: 'low' },
          );
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e);
          this._viewToModelMapping.set(e, t);
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t);
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e);
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root);
          } else {
            this._viewToModelMapping.delete(t);
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n);
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t);
          this._modelToViewMapping.delete(t);
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e);
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set();
          n.add(t);
          const o = this._elementToMarkerNames.get(t) || new Set();
          o.add(e);
          this._markerNameToElements.set(e, n);
          this._elementToMarkerNames.set(t, o);
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e);
          if (n) {
            n.delete(t);
            if (n.size == 0) {
              this._markerNameToElements.delete(e);
            }
          }
          const o = this._elementToMarkerNames.get(t);
          if (o) {
            o.delete(e);
            if (o.size == 0) {
              this._elementToMarkerNames.delete(t);
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames);
          this._unboundMarkerNames.clear();
          return t;
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t);
            }
          }
          this._deferredBindingRemovals = new Map();
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
          this._deferredBindingRemovals = new Map();
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t);
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t);
        }
        toModelRange(t) {
          return new Nk(
            this.toModelPosition(t.start),
            this.toModelPosition(t.end),
          );
        }
        toViewRange(t) {
          return new gp(
            this.toViewPosition(t.start),
            this.toViewPosition(t.end),
          );
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this };
          this.fire('viewToModelPosition', e);
          return e.modelPosition;
        }
        toViewPosition(t, e = {}) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
          this.fire('modelToViewPosition', n);
          return n.viewPosition;
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t);
          if (!e) {
            return null;
          }
          const n = new Set();
          for (const t of e) {
            if (t.is('attributeElement')) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e);
              }
            } else {
              n.add(t);
            }
          }
          return n;
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e);
        }
        findMappedViewAncestor(t) {
          let e = t.parent;
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent;
          }
          return e;
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const o = this._toModelOffset(t.parent, t.index, n);
            const i = this._toModelOffset(t, e, t);
            return o + i;
          }
          if (t.is('$text')) {
            return e;
          }
          let o = 0;
          for (let n = 0; n < e; n++) {
            o += this.getModelLength(t.getChild(n));
          }
          return o;
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name);
            return e(t);
          } else if (this._viewToModelMapping.has(t)) {
            return 1;
          } else if (t.is('$text')) {
            return t.data.length;
          } else if (t.is('uiElement')) {
            return 0;
          } else {
            let e = 0;
            for (const n of t.getChildren()) {
              e += this.getModelLength(n);
            }
            return e;
          }
        }
        findPositionIn(t, e) {
          let n;
          let o = 0;
          let i = 0;
          let r = 0;
          if (t.is('$text')) {
            return new pp(t, e);
          }
          while (i < e) {
            n = t.getChild(r);
            o = this.getModelLength(n);
            i += o;
            r++;
          }
          if (i == e) {
            return this._moveViewPositionToTextNode(new pp(t, r));
          } else {
            return this.findPositionIn(n, e - (i - o));
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (e instanceof ou) {
            return new pp(e, e.data.length);
          } else if (n instanceof ou) {
            return new pp(n, 0);
          }
          return t;
        }
      }
      class Hk {
        constructor() {
          this._consumable = new Map();
          this._textProxyRegistry = new Map();
        }
        add(t, e) {
          e = jk(e);
          if (t instanceof Dk) {
            t = this._getSymbolForTextProxy(t);
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map());
          }
          this._consumable.get(t).set(e, true);
        }
        consume(t, e) {
          e = jk(e);
          if (t instanceof Dk) {
            t = this._getSymbolForTextProxy(t);
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false);
            return true;
          } else {
            return false;
          }
        }
        test(t, e) {
          e = jk(e);
          if (t instanceof Dk) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this._consumable.get(t);
          if (n === undefined) {
            return null;
          }
          const o = n.get(e);
          if (o === undefined) {
            return null;
          }
          return o;
        }
        revert(t, e) {
          e = jk(e);
          if (t instanceof Dk) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this.test(t, e);
          if (n === false) {
            this._consumable.get(t).set(e, true);
            return true;
          } else if (n === true) {
            return false;
          }
          return null;
        }
        verifyAllConsumed(t) {
          const e = [];
          for (const [n, o] of this._consumable) {
            for (const [i, r] of o) {
              const o = i.split(':')[0];
              if (r && t == o) {
                e.push({ event: i, item: n.name || n.description });
              }
            }
          }
          if (e.length) {
            throw new B('conversion-model-consumable-not-consumed', null, {
              items: e,
            });
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null;
          const n = this._textProxyRegistry.get(t.startOffset);
          if (n) {
            const o = n.get(t.endOffset);
            if (o) {
              e = o.get(t.parent);
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t);
          }
          return e;
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset;
          const n = t.endOffset;
          const o = t.parent;
          const i = Symbol('$textProxy:' + t.data);
          let r;
          let s;
          r = this._textProxyRegistry.get(e);
          if (!r) {
            r = new Map();
            this._textProxyRegistry.set(e, r);
          }
          s = r.get(n);
          if (!s) {
            s = new Map();
            r.set(n, s);
          }
          s.set(o, i);
          return i;
        }
      }
      function jk(t) {
        const e = t.split(':');
        if (e[0] == 'insert') {
          return e[0];
        }
        if (e[0] == 'addMarker' || e[0] == 'removeMarker') {
          return t;
        }
        return e.length > 1 ? e[0] + ':' + e[1] : e[0];
      }
      class qk extends $() {
        constructor(t) {
          super();
          this._conversionApi = { dispatcher: this, ...t };
          this._firedEventsMap = new WeakMap();
        }
        convertChanges(t, e, n) {
          const o = this._createConversionApi(n, t.getRefreshedItems());
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, o);
          }
          const i = this._reduceChanges(t.getChanges());
          for (const t of i) {
            if (t.type === 'insert') {
              this._convertInsert(
                Nk._createFromPositionAndShift(t.position, t.length),
                o,
              );
            } else if (t.type === 'reinsert') {
              this._convertReinsert(
                Nk._createFromPositionAndShift(t.position, t.length),
                o,
              );
            } else if (t.type === 'remove') {
              this._convertRemove(t.position, t.length, t.name, o);
            } else {
              this._convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                o,
              );
            }
          }
          for (const t of o.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange();
            this._convertMarkerRemove(t, n, o);
            this._convertMarkerAdd(t, n, o);
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, o);
          }
          o.mapper.flushDeferredBindings();
          o.consumable.verifyAllConsumed('insert');
        }
        convert(t, e, n, o = {}) {
          const i = this._createConversionApi(n, undefined, o);
          this._convertInsert(t, i);
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, i);
          }
          i.consumable.verifyAllConsumed('insert');
        }
        convertSelection(t, e, n) {
          const o = this._createConversionApi(n);
          this.fire('cleanSelection', { selection: t }, o);
          const i = t.getFirstPosition().root;
          if (!o.mapper.toViewElement(i)) {
            return;
          }
          const r = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
          this._addConsumablesForSelection(o.consumable, t, r);
          this.fire('selection', { selection: t }, o);
          if (!t.isCollapsed) {
            return;
          }
          for (const e of r) {
            if (o.consumable.test(t, 'addMarker:' + e.name)) {
              const n = e.getRange();
              if (!$k(t.getFirstPosition(), e, o.mapper)) {
                continue;
              }
              const i = { item: t, markerName: e.name, markerRange: n };
              this.fire(`addMarker:${e.name}`, i, o);
            }
          }
          for (const e of t.getAttributeKeys()) {
            if (o.consumable.test(t, 'attribute:' + e)) {
              const n = {
                item: t,
                range: t.getFirstRange(),
                attributeKey: e,
                attributeOldValue: null,
                attributeNewValue: t.getAttribute(e),
              };
              this.fire(`attribute:${e}:$text`, n, o);
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(e.consumable, t);
          }
          for (const n of Array.from(t.getWalker({ shallow: true })).map(Gk)) {
            this._testAndFire('insert', n, e);
          }
        }
        _convertRemove(t, e, n, o) {
          this.fire(`remove:${n}`, { position: t, length: e }, o);
        }
        _convertAttribute(t, e, n, o, i) {
          this._addConsumablesForRange(i.consumable, t, `attribute:${e}`);
          for (const r of t) {
            const t = {
              item: r.item,
              range: Nk._createFromPositionAndShift(
                r.previousPosition,
                r.length,
              ),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: o,
            };
            this._testAndFire(`attribute:${e}`, t, i);
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }));
          this._addConsumablesForInsert(e.consumable, n);
          for (const t of n.map(Gk)) {
            this._testAndFire('insert', { ...t, reconversion: true }, e);
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return;
          }
          const o = `addMarker:${t}`;
          n.consumable.add(e, o);
          this.fire(o, { markerName: t, markerRange: e }, n);
          if (!n.consumable.consume(e, o)) {
            return;
          }
          this._addConsumablesForRange(n.consumable, e, o);
          for (const i of e.getItems()) {
            if (!n.consumable.test(i, o)) {
              continue;
            }
            const r = {
              item: i,
              range: Nk._createOn(i),
              markerName: t,
              markerRange: e,
            };
            this.fire(o, r, n);
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == '$graveyard') {
            return;
          }
          this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n);
        }
        _reduceChanges(t) {
          const e = { changes: t };
          this.fire('reduceChanges', e);
          return e.changes;
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item;
            if (t.test(e, 'insert') === null) {
              t.add(e, 'insert');
              for (const n of e.getAttributeKeys()) {
                t.add(e, 'attribute:' + n);
              }
            }
          }
          return t;
        }
        _addConsumablesForRange(t, e, n) {
          for (const o of e.getItems()) {
            t.add(o, n);
          }
          return t;
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, 'selection');
          for (const o of n) {
            t.add(e, 'addMarker:' + o.name);
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, 'attribute:' + n);
          }
          return t;
        }
        _testAndFire(t, e, n) {
          const o = Wk(t, e);
          const i = e.item.is('$textProxy')
            ? n.consumable._getSymbolForTextProxy(e.item)
            : e.item;
          const r = this._firedEventsMap.get(n);
          const s = r.get(i);
          if (!s) {
            r.set(i, new Set([o]));
          } else if (!s.has(o)) {
            s.add(o);
          } else {
            return;
          }
          this.fire(o, e, n);
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: Nk._createOn(t) };
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t;
            n.attributeOldValue = null;
            n.attributeNewValue = n.item.getAttribute(t);
            this._testAndFire(`attribute:${t}`, n, e);
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const o = {
            ...this._conversionApi,
            consumable: new Hk(),
            writer: t,
            options: n,
            convertItem: t => this._convertInsert(Nk._createOn(t), o),
            convertChildren: t =>
              this._convertInsert(Nk._createIn(t), o, {
                doNotAddConsumables: true,
              }),
            convertAttributes: t => this._testAndFireAddAttributes(t, o),
            canReuseView: t => !e.has(o.mapper.toModelElement(t)),
          };
          this._firedEventsMap.set(o, new Map());
          return o;
        }
      }
      function $k(t, e, n) {
        const o = e.getRange();
        const i = Array.from(t.getAncestors());
        i.shift();
        i.reverse();
        const r = i.some(t => {
          if (o.containsItem(t)) {
            const e = n.toViewElement(t);
            return !!e.getCustomProperty('addHighlight');
          }
        });
        return !r;
      }
      function Wk(t, e) {
        const n = e.item.is('element') ? e.item.name : '$text';
        return `${t}:${n}`;
      }
      function Gk(t) {
        const e = t.item;
        const n = Nk._createFromPositionAndShift(t.previousPosition, t.length);
        return { item: e, range: n };
      }
      class Kk extends $(Ck) {
        constructor(...t) {
          super();
          this._lastRangeBackward = false;
          this._attrs = new Map();
          this._ranges = [];
          if (t.length) {
            this.setTo(...t);
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.end : t.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.start : t.end;
          }
          return null;
        }
        get isCollapsed() {
          const t = this._ranges.length;
          if (t === 1) {
            return this._ranges[0].isCollapsed;
          } else {
            return false;
          }
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new Nk(t.start, t.end);
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? new Nk(t.start, t.end) : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? new Nk(t.start, t.end) : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        setTo(...t) {
          let [e, n, o] = t;
          if (typeof n == 'object') {
            o = n;
            n = undefined;
          }
          if (e === null) {
            this._setRanges([]);
          } else if (e instanceof Kk) {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e && typeof e.getRanges == 'function') {
            this._setRanges(e.getRanges(), e.isBackward);
          } else if (e instanceof Nk) {
            this._setRanges([e], !!o && !!o.backward);
          } else if (e instanceof Rk) {
            this._setRanges([new Nk(e)]);
          } else if (e instanceof yk) {
            const t = !!o && !!o.backward;
            let i;
            if (n == 'in') {
              i = Nk._createIn(e);
            } else if (n == 'on') {
              i = Nk._createOn(e);
            } else if (n !== undefined) {
              i = new Nk(Rk._createAt(e, n));
            } else {
              throw new B('model-selection-setto-required-second-parameter', [
                this,
                e,
              ]);
            }
            this._setRanges([i], t);
          } else if (yt(e)) {
            this._setRanges(e, o && !!o.backward);
          } else {
            throw new B('model-selection-setto-not-selectable', [this, e]);
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t);
          const o = n.some(e => {
            if (!(e instanceof Nk)) {
              throw new B('model-selection-set-ranges-not-range', [this, t]);
            }
            return this._ranges.every(t => !t.isEqual(e));
          });
          if (n.length === this._ranges.length && !o) {
            return;
          }
          this._replaceAllRanges(n);
          this._lastRangeBackward = !!e;
          this.fire('change:range', { directChange: true });
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new B('model-selection-setfocus-no-ranges', [this, t]);
          }
          const n = Rk._createAt(t, e);
          if (n.compareWith(this.focus) == 'same') {
            return;
          }
          const o = this.anchor;
          if (this._ranges.length) {
            this._popRange();
          }
          if (n.compareWith(o) == 'before') {
            this._pushRange(new Nk(n, o));
            this._lastRangeBackward = true;
          } else {
            this._pushRange(new Nk(o, n));
            this._lastRangeBackward = false;
          }
          this.fire('change:range', { directChange: true });
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t);
            this.fire('change:attribute', {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e);
            this.fire('change:attribute', {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const t = new WeakSet();
          for (const e of this.getRanges()) {
            const n = Jk(e.start, t);
            if (Qk(n, e)) {
              yield n;
            }
            for (const n of e.getWalker()) {
              const o = n.item;
              if (n.type == 'elementEnd' && Zk(o, t, e)) {
                yield o;
              }
            }
            const o = Jk(e.end, t);
            if (Xk(o, e)) {
              yield o;
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = Rk._createAt(t, 0);
          const n = Rk._createAt(t, 'end');
          return (
            e.isTouching(this.getFirstPosition()) &&
            n.isTouching(this.getLastPosition())
          );
        }
        _pushRange(t) {
          this._checkRange(t);
          this._ranges.push(new Nk(t.start, t.end));
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new B('model-selection-range-intersects', [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              });
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges();
          for (const e of t) {
            this._pushRange(e);
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange();
          }
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      Kk.prototype.is = function (t) {
        return t === 'selection' || t === 'model:selection';
      };
      function Uk(t, e) {
        if (e.has(t)) {
          return false;
        }
        e.add(t);
        return t.root.document.model.schema.isBlock(t) && !!t.parent;
      }
      function Zk(t, e, n) {
        return Uk(t, e) && Yk(t, n);
      }
      function Jk(t, e) {
        const n = t.parent;
        const o = n.root.document.model.schema;
        const i = t.parent.getAncestors({
          parentFirst: true,
          includeSelf: true,
        });
        let r = false;
        const s = i.find(t => {
          if (r) {
            return false;
          }
          r = o.isLimit(t);
          return !r && Uk(t, e);
        });
        i.forEach(t => e.add(t));
        return s;
      }
      function Yk(t, e) {
        const n = tb(t);
        if (!n) {
          return true;
        }
        const o = e.containsRange(Nk._createOn(n), true);
        return !o;
      }
      function Qk(t, e) {
        if (!t) {
          return false;
        }
        if (e.isCollapsed || t.isEmpty) {
          return true;
        }
        if (e.start.isTouching(Rk._createAt(t, t.maxOffset))) {
          return false;
        }
        return Yk(t, e);
      }
      function Xk(t, e) {
        if (!t) {
          return false;
        }
        if (e.isCollapsed || t.isEmpty) {
          return true;
        }
        if (e.end.isTouching(Rk._createAt(t, 0))) {
          return false;
        }
        return Yk(t, e);
      }
      function tb(t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        while (n) {
          if (e.isBlock(n)) {
            return n;
          }
          n = n.parent;
        }
      }
      class eb extends $(Nk) {
        constructor(t, e) {
          super(t, e);
          nb.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new Nk(this.start, this.end);
        }
        static fromRange(t) {
          return new eb(t.start, t.end);
        }
      }
      eb.prototype.is = function (t) {
        return (
          t === 'liveRange' ||
          t === 'model:liveRange' ||
          t == 'range' ||
          t === 'model:range'
        );
      };
      function nb() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            ob.call(this, n);
          },
          { priority: 'low' },
        );
      }
      function ob(t) {
        const e = this.getTransformedByOperation(t);
        const n = Nk._createFromRanges(e);
        const o = !n.isEqual(this);
        const i = ib(this, t);
        let r = null;
        if (o) {
          if (n.root.rootName == '$graveyard') {
            if (t.type == 'remove') {
              r = t.sourcePosition;
            } else {
              r = t.deletionPosition;
            }
          }
          const e = this.toRange();
          this.start = n.start;
          this.end = n.end;
          this.fire('change:range', e, { deletionPosition: r });
        } else if (i) {
          this.fire('change:content', this.toRange(), { deletionPosition: r });
        }
      }
      function ib(t, e) {
        switch (e.type) {
          case 'insert':
            return t.containsPosition(e.position);
          case 'move':
          case 'remove':
          case 'reinsert':
          case 'merge':
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            );
          case 'split':
            return (
              t.containsPosition(e.splitPosition) ||
              t.containsPosition(e.insertionPosition)
            );
        }
        return false;
      }
      const rb = 'selection:';
      class sb extends $(Ck) {
        constructor(t) {
          super();
          this._selection = new ab(t);
          this._selection.delegate('change:range').to(this);
          this._selection.delegate('change:attribute').to(this);
          this._selection.delegate('change:marker').to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t) {
          return this._selection.getAttribute(t);
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t);
        }
        refresh() {
          this._selection.updateMarkers();
          this._selection._updateAttributes(false);
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
        _setTo(...t) {
          this._selection.setTo(...t);
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e);
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t);
        }
        static _getStoreAttributeKey(t) {
          return rb + t;
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(rb);
        }
      }
      sb.prototype.is = function (t) {
        return (
          t === 'selection' ||
          t == 'model:selection' ||
          t == 'documentSelection' ||
          t == 'model:documentSelection'
        );
      };
      class ab extends Kk {
        constructor(t) {
          super();
          this.markers = new dl({ idProperty: 'name' });
          this._attributePriority = new Map();
          this._selectionRestorePosition = null;
          this._hasChangedRange = false;
          this._overriddenGravityRegister = new Set();
          this._observedMarkers = new Set();
          this._model = t.model;
          this._document = t;
          this.listenTo(
            this._model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (
                !n.isDocumentOperation ||
                n.type == 'marker' ||
                n.type == 'rename' ||
                n.type == 'noop'
              ) {
                return;
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition);
              }
              this._selectionRestorePosition = null;
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire('change:range', { directChange: false });
              }
            },
            { priority: 'lowest' },
          );
          this.on('change:range', () => {
            this._validateSelectionRanges(this.getRanges());
          });
          this.listenTo(this._model.markers, 'update', (t, e, n, o) => {
            this._updateMarker(e, o);
          });
          this.listenTo(this._document, 'change', (t, e) => {
            lb(this._model, e);
          });
        }
        get isCollapsed() {
          const t = this._ranges.length;
          return t === 0
            ? this._document._getDefaultRange().isCollapsed
            : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach();
          }
          this.stopListening();
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges();
          } else {
            yield this._document._getDefaultRange();
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...t) {
          super.setTo(...t);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setFocus(t, e) {
          super.setFocus(t, e);
          this._updateAttributes(true);
          this.updateMarkers();
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t];
            this.fire('change:attribute', {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t];
            this.fire('change:attribute', {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        overrideGravity() {
          const t = E();
          this._overriddenGravityRegister.add(t);
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true);
          }
          return t;
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new B('document-selection-gravity-wrong-restore', this, {
              uid: t,
            });
          }
          this._overriddenGravityRegister.delete(t);
          if (!this.isGravityOverridden) {
            this._updateAttributes(true);
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t);
          this.updateMarkers();
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t);
          super._replaceAllRanges(t);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t) {
          const e = this._prepareRange(t);
          if (e) {
            this._ranges.push(e);
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new B('document-selection-wrong-position', this, {
                range: e,
              });
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t);
          if (t.root == this._document.graveyard) {
            return;
          }
          const e = eb.fromRange(t);
          e.on('change:range', (t, n, o) => {
            this._hasChangedRange = true;
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = o.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1);
              e.detach();
            }
          });
          return e;
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return;
          }
          const t = [];
          let e = false;
          for (const e of this._model.markers) {
            const n = e.name.split(':', 1)[0];
            if (!this._observedMarkers.has(n)) {
              continue;
            }
            const o = e.getRange();
            for (const n of this.getRanges()) {
              if (o.containsRange(n, !n.isCollapsed)) {
                t.push(e);
              }
            }
          }
          const n = Array.from(this.markers);
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n);
              e = true;
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n);
              e = true;
            }
          }
          if (e) {
            this.fire('change:marker', { oldMarkers: n, directChange: false });
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(':', 1)[0];
          if (!this._observedMarkers.has(n)) {
            return;
          }
          let o = false;
          const i = Array.from(this.markers);
          const r = this.markers.has(t);
          if (!e) {
            if (r) {
              this.markers.remove(t);
              o = true;
            }
          } else {
            let n = false;
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true;
                break;
              }
            }
            if (n && !r) {
              this.markers.add(t);
              o = true;
            } else if (!n && r) {
              this.markers.remove(t);
              o = true;
            }
          }
          if (o) {
            this.fire('change:marker', { oldMarkers: i, directChange: false });
          }
        }
        _updateAttributes(t) {
          const e = gl(this._getSurroundingAttributes());
          const n = gl(this.getAttributes());
          if (t) {
            this._attributePriority = new Map();
            this._attrs = new Map();
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == 'low') {
                this._attrs.delete(t);
                this._attributePriority.delete(t);
              }
            }
          }
          this._setAttributesTo(e);
          const o = [];
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              o.push(t);
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              o.push(t);
            }
          }
          if (o.length > 0) {
            this.fire('change:attribute', {
              attributeKeys: o,
              directChange: false,
            });
          }
        }
        _setAttribute(t, e, n = true) {
          const o = n ? 'normal' : 'low';
          if (o == 'low' && this._attributePriority.get(t) == 'normal') {
            return false;
          }
          const i = super.getAttribute(t);
          if (i === e) {
            return false;
          }
          this._attrs.set(t, e);
          this._attributePriority.set(t, o);
          return true;
        }
        _removeAttribute(t, e = true) {
          const n = e ? 'normal' : 'low';
          if (n == 'low' && this._attributePriority.get(t) == 'normal') {
            return false;
          }
          this._attributePriority.set(t, n);
          if (!super.hasAttribute(t)) {
            return false;
          }
          this._attrs.delete(t);
          return true;
        }
        _setAttributesTo(t) {
          const e = new Set();
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue;
            }
            this._removeAttribute(e, false);
          }
          for (const [n, o] of t) {
            const t = this._setAttribute(n, o, false);
            if (t) {
              e.add(n);
            }
          }
          return e;
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent;
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(rb)) {
                const n = e.substr(rb.length);
                yield [n, t.getAttribute(e)];
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition();
          const e = this._model.schema;
          if (t.root.rootName == '$graveyard') {
            return null;
          }
          let n = null;
          if (!this.isCollapsed) {
            const t = this.getFirstRange();
            for (const o of t) {
              if (o.item.is('element') && e.isObject(o.item)) {
                n = cb(o.item, e);
                break;
              }
              if (o.type == 'text') {
                n = o.item.getAttributes();
                break;
              }
            }
          } else {
            const o = t.textNode ? t.textNode : t.nodeBefore;
            const i = t.textNode ? t.textNode : t.nodeAfter;
            if (!this.isGravityOverridden) {
              n = cb(o, e);
            }
            if (!n) {
              n = cb(i, e);
            }
            if (!this.isGravityOverridden && !n) {
              let t = o;
              while (t && !n) {
                t = t.previousSibling;
                n = cb(t, e);
              }
            }
            if (!n) {
              let t = i;
              while (t && !n) {
                t = t.nextSibling;
                n = cb(t, e);
              }
            }
            if (!n) {
              n = this.getStoredAttributes();
            }
          }
          return n;
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t);
          if (e) {
            this._pushRange(e);
          }
        }
      }
      function cb(t, e) {
        if (!t) {
          return null;
        }
        if (t instanceof Dk || t instanceof Ek) {
          return t.getAttributes();
        }
        if (!e.isInline(t)) {
          return null;
        }
        if (!e.isObject(t)) {
          return [];
        }
        const n = [];
        for (const [o, i] of t.getAttributes()) {
          if (
            e.checkAttribute('$text', o) &&
            e.getAttributeProperties(o).copyFromObject !== false
          ) {
            n.push([o, i]);
          }
        }
        return n;
      }
      function lb(t, e) {
        const n = t.document.differ;
        for (const o of n.getChanges()) {
          if (o.type != 'insert') {
            continue;
          }
          const n = o.position.parent;
          const i = o.length === n.maxOffset;
          if (i) {
            t.enqueueChange(e, t => {
              const e = Array.from(n.getAttributeKeys()).filter(t =>
                t.startsWith(rb),
              );
              for (const o of e) {
                t.removeAttribute(o, n);
              }
            });
          }
        }
      }
      class db {
        constructor(t) {
          this._dispatchers = t;
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e);
          }
          return this;
        }
      }
      class hb extends db {
        elementToElement(t) {
          return this.add(Ob(t));
        }
        elementToStructure(t) {
          return this.add(Ib(t));
        }
        attributeToElement(t) {
          return this.add(Mb(t));
        }
        attributeToAttribute(t) {
          return this.add(Vb(t));
        }
        markerToElement(t) {
          return this.add(zb(t));
        }
        markerToHighlight(t) {
          return this.add(Nb(t));
        }
        markerToData(t) {
          return this.add(Fb(t));
        }
      }
      function ub() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const o = n.writer;
          const i = n.mapper.toViewPosition(e.range.start);
          const r = o.createText(e.item.data);
          o.insert(i, r);
        };
      }
      function fb() {
        return (t, e, n) => {
          n.convertAttributes(e.item);
          if (!e.reconversion && e.item.is('element') && !e.item.isEmpty) {
            n.convertChildren(e.item);
          }
        };
      }
      function pb() {
        return (t, e, n) => {
          const o = n.mapper.toViewPosition(e.position);
          const i = e.position.getShiftedBy(e.length);
          const r = n.mapper.toViewPosition(i, { isPhantom: true });
          const s = n.writer.createRange(o, r);
          const a = n.writer.remove(s.getTrimmed());
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true });
          }
        };
      }
      function gb(t, e) {
        const n = t.createAttributeElement('span', e.attributes);
        if (e.classes) {
          n._addClass(e.classes);
        }
        if (typeof e.priority === 'number') {
          n._priority = e.priority;
        }
        n._id = e.id;
        return n;
      }
      function mb() {
        return (t, e, n) => {
          const o = e.selection;
          if (o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, 'selection')) {
            return;
          }
          const i = [];
          for (const t of o.getRanges()) {
            i.push(n.mapper.toViewRange(t));
          }
          n.writer.setSelection(i, { backward: o.isBackward });
        };
      }
      function kb() {
        return (t, e, n) => {
          const o = e.selection;
          if (!o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, 'selection')) {
            return;
          }
          const i = n.writer;
          const r = o.getFirstPosition();
          const s = n.mapper.toViewPosition(r);
          const a = i.breakAttributes(s);
          i.setSelection(a);
        };
      }
      function bb() {
        return (t, e, n) => {
          const o = n.writer;
          const i = o.document.selection;
          for (const t of i.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start);
              }
            }
          }
          o.setSelection(null);
        };
      }
      function wb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const i = t(n.attributeOldValue, o, n);
          const r = t(n.attributeNewValue, o, n);
          if (!i && !r) {
            return;
          }
          o.consumable.consume(n.item, e.name);
          const s = o.writer;
          const a = s.document.selection;
          if (n.item instanceof Kk || n.item instanceof sb) {
            s.wrap(a.getFirstRange(), r);
          } else {
            let t = o.mapper.toViewRange(n.range);
            if (n.attributeOldValue !== null && i) {
              t = s.unwrap(t, i);
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r);
            }
          }
        };
      }
      function _b(t, e = tw) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return;
          }
          const r = t(o.item, i, o);
          if (!r) {
            return;
          }
          e(o.item, i.consumable);
          const s = i.mapper.toViewPosition(o.range.start);
          i.mapper.bindElements(o.item, r);
          i.writer.insert(s, r);
          i.convertAttributes(o.item);
          Qb(r, o.item.getChildren(), i, { reconversion: o.reconversion });
        };
      }
      function vb(t, e) {
        return (n, o, i) => {
          if (!e(o.item, i.consumable, { preflight: true })) {
            return;
          }
          const r = new Map();
          i.writer._registerSlotFactory(Zb(o.item, r, i));
          const s = t(o.item, i, o);
          i.writer._clearSlotFactory();
          if (!s) {
            return;
          }
          Jb(o.item, r, i);
          e(o.item, i.consumable);
          const a = i.mapper.toViewPosition(o.range.start);
          i.mapper.bindElements(o.item, s);
          i.writer.insert(a, s);
          i.convertAttributes(o.item);
          Yb(s, r, i, { reconversion: o.reconversion });
        };
      }
      function Ab(t) {
        return (e, n, o) => {
          n.isOpening = true;
          const i = t(n, o);
          n.isOpening = false;
          const r = t(n, o);
          if (!i || !r) {
            return;
          }
          const s = n.markerRange;
          if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
            return;
          }
          for (const t of s) {
            if (!o.consumable.consume(t.item, e.name)) {
              return;
            }
          }
          const a = o.mapper;
          const c = o.writer;
          c.insert(a.toViewPosition(s.start), i);
          o.mapper.bindElementToMarker(i, n.markerName);
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
          e.stop();
        };
      }
      function Cb() {
        return (t, e, n) => {
          const o = n.mapper.markerNameToElements(e.markerName);
          if (!o) {
            return;
          }
          for (const t of o) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName);
            n.writer.clear(n.writer.createRangeOn(t), t);
          }
          n.writer.clearClonedElementsGroup(e.markerName);
          t.stop();
        };
      }
      function yb(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = n.markerRange;
          if (!o.consumable.consume(r, e.name)) {
            return;
          }
          xb(r, false, o, n, i);
          xb(r, true, o, n, i);
          e.stop();
        };
      }
      function xb(t, e, n, o, i) {
        const r = e ? t.start : t.end;
        const s = r.nodeAfter && r.nodeAfter.is('element') ? r.nodeAfter : null;
        const a =
          r.nodeBefore && r.nodeBefore.is('element') ? r.nodeBefore : null;
        if (s || a) {
          let t;
          let r;
          if ((e && s) || (!e && !a)) {
            t = s;
            r = true;
          } else {
            t = a;
            r = false;
          }
          const c = n.mapper.toViewElement(t);
          if (c) {
            Eb(c, e, r, n, o, i);
            return;
          }
        }
        const c = n.mapper.toViewPosition(r);
        Db(c, e, n, o, i);
      }
      function Eb(t, e, n, o, i, r) {
        const s = `data-${r.group}-${e ? 'start' : 'end'}-${
          n ? 'before' : 'after'
        }`;
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(',') : [];
        a.unshift(r.name);
        o.writer.setAttribute(s, a.join(','), t);
        o.mapper.bindElementToMarker(t, i.markerName);
      }
      function Db(t, e, n, o, i) {
        const r = `${i.group}-${e ? 'start' : 'end'}`;
        const s = i.name ? { name: i.name } : null;
        const a = n.writer.createUIElement(r, s);
        n.writer.insert(t, a);
        n.mapper.bindElementToMarker(a, o.markerName);
      }
      function Tb(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = o.mapper.markerNameToElements(n.markerName);
          if (!r) {
            return;
          }
          for (const t of r) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is('containerElement')) {
              s(`data-${i.group}-start-before`, t);
              s(`data-${i.group}-start-after`, t);
              s(`data-${i.group}-end-before`, t);
              s(`data-${i.group}-end-after`, t);
            } else {
              o.writer.clear(o.writer.createRangeOn(t), t);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(','));
              n.delete(i.name);
              if (n.size == 0) {
                o.writer.removeAttribute(t, e);
              } else {
                o.writer.setAttribute(t, Array.from(n).join(','), e);
              }
            }
          }
        };
      }
      function Sb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const i = t(n.attributeOldValue, o, n);
          const r = t(n.attributeNewValue, o, n);
          if (!i && !r) {
            return;
          }
          o.consumable.consume(n.item, e.name);
          const s = o.mapper.toViewElement(n.item);
          const a = o.writer;
          if (!s) {
            throw new B(
              'conversion-attribute-to-attribute-on-text',
              o.dispatcher,
              n,
            );
          }
          if (n.attributeOldValue !== null && i) {
            if (i.key == 'class') {
              const t = tl(i.value);
              for (const e of t) {
                a.removeClass(e, s);
              }
            } else if (i.key == 'style') {
              const t = Object.keys(i.value);
              for (const e of t) {
                a.removeStyle(e, s);
              }
            } else {
              a.removeAttribute(i.key, s);
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == 'class') {
              const t = tl(r.value);
              for (const e of t) {
                a.addClass(e, s);
              }
            } else if (r.key == 'style') {
              const t = Object.keys(r.value);
              for (const e of t) {
                a.setStyle(e, r.value[e], s);
              }
            } else {
              a.setAttribute(r.key, r.value, s);
            }
          }
        };
      }
      function Pb(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (
            !(n.item instanceof Kk || n.item instanceof sb) &&
            !n.item.is('$textProxy')
          ) {
            return;
          }
          const i = Wb(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return;
          }
          const r = o.writer;
          const s = gb(r, i);
          const a = r.document.selection;
          if (n.item instanceof Kk || n.item instanceof sb) {
            r.wrap(a.getFirstRange(), s);
          } else {
            const t = o.mapper.toViewRange(n.range);
            const e = r.wrap(t, s);
            for (const t of e.getItems()) {
              if (t.is('attributeElement') && t.isSimilar(s)) {
                o.mapper.bindElementToMarker(t, n.markerName);
                break;
              }
            }
          }
        };
      }
      function Bb(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof Tk)) {
            return;
          }
          const i = Wb(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const r = o.mapper.toViewElement(n.item);
          if (r && r.getCustomProperty('addHighlight')) {
            o.consumable.consume(n.item, e.name);
            for (const t of Nk._createIn(n.item)) {
              o.consumable.consume(t.item, e.name);
            }
            const t = r.getCustomProperty('addHighlight');
            t(r, i, o.writer);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
        };
      }
      function Rb(t) {
        return (e, n, o) => {
          if (n.markerRange.isCollapsed) {
            return;
          }
          const i = Wb(t, n, o);
          if (!i) {
            return;
          }
          const r = gb(o.writer, i);
          const s = o.mapper.markerNameToElements(n.markerName);
          if (!s) {
            return;
          }
          for (const t of s) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is('attributeElement')) {
              o.writer.unwrap(o.writer.createRangeOn(t), r);
            } else {
              const e = t.getCustomProperty('removeHighlight');
              e(t, i.id, o.writer);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
        };
      }
      function Ob(t) {
        const e = Lb(t.model);
        const n = Hb(t.view, 'container');
        if (e.attributes.length) {
          e.children = true;
        }
        return o => {
          o.on(`insert:${e.name}`, _b(n, Ub(e)), {
            priority: t.converterPriority || 'normal',
          });
          if (e.children || e.attributes.length) {
            o.on('reduceChanges', Kb(e), { priority: 'low' });
          }
        };
      }
      function Ib(t) {
        const e = Lb(t.model);
        const n = Hb(t.view, 'container');
        e.children = true;
        return o => {
          if (o._conversionApi.schema.checkChild(e.name, '$text')) {
            throw new B('conversion-element-to-structure-disallowed-text', o, {
              elementName: e.name,
            });
          }
          o.on(`insert:${e.name}`, vb(n, Ub(e)), {
            priority: t.converterPriority || 'normal',
          });
          o.on('reduceChanges', Kb(e), { priority: 'low' });
        };
      }
      function Mb(t) {
        t = vk(t);
        let e = t.model;
        if (typeof e == 'string') {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ':' + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Hb(t.view[n], 'attribute');
          }
        } else {
          t.view = Hb(t.view, 'attribute');
        }
        const o = qb(t);
        return e => {
          e.on(n, wb(o), { priority: t.converterPriority || 'normal' });
        };
      }
      function Vb(t) {
        t = vk(t);
        let e = t.model;
        if (typeof e == 'string') {
          e = { key: e };
        }
        let n = `attribute:${e.key}`;
        if (e.name) {
          n += ':' + e.name;
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = $b(t.view[n]);
          }
        } else {
          t.view = $b(t.view);
        }
        const o = qb(t);
        return e => {
          e.on(n, Sb(o), { priority: t.converterPriority || 'normal' });
        };
      }
      function zb(t) {
        const e = Hb(t.view, 'ui');
        return n => {
          n.on(`addMarker:${t.model}`, Ab(e), {
            priority: t.converterPriority || 'normal',
          });
          n.on(`removeMarker:${t.model}`, Cb(), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Fb(t) {
        t = vk(t);
        const e = t.model;
        let n = t.view;
        if (!n) {
          n = n => ({ group: e, name: n.substr(t.model.length + 1) });
        }
        return o => {
          o.on(`addMarker:${e}`, yb(n), {
            priority: t.converterPriority || 'normal',
          });
          o.on(`removeMarker:${e}`, Tb(n), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Nb(t) {
        return e => {
          e.on(`addMarker:${t.model}`, Pb(t.view), {
            priority: t.converterPriority || 'normal',
          });
          e.on(`addMarker:${t.model}`, Bb(t.view), {
            priority: t.converterPriority || 'normal',
          });
          e.on(`removeMarker:${t.model}`, Rb(t.view), {
            priority: t.converterPriority || 'normal',
          });
        };
      }
      function Lb(t) {
        if (typeof t == 'string') {
          t = { name: t };
        }
        return {
          name: t.name,
          attributes: t.attributes ? tl(t.attributes) : [],
          children: !!t.children,
        };
      }
      function Hb(t, e) {
        if (typeof t == 'function') {
          return t;
        }
        return (n, o) => jb(t, o, e);
      }
      function jb(t, e, n) {
        if (typeof t == 'string') {
          t = { name: t };
        }
        let o;
        const i = e.writer;
        const r = Object.assign({}, t.attributes);
        if (n == 'container') {
          o = i.createContainerElement(t.name, r);
        } else if (n == 'attribute') {
          const e = { priority: t.priority || Sp.DEFAULT_PRIORITY };
          o = i.createAttributeElement(t.name, r, e);
        } else {
          o = i.createUIElement(t.name, r);
        }
        if (t.styles) {
          const e = Object.keys(t.styles);
          for (const n of e) {
            i.setStyle(n, t.styles[n], o);
          }
        }
        if (t.classes) {
          const e = t.classes;
          if (typeof e == 'string') {
            i.addClass(e, o);
          } else {
            for (const t of e) {
              i.addClass(t, o);
            }
          }
        }
        return o;
      }
      function qb(t) {
        if (t.model.values) {
          return (e, n, o) => {
            const i = t.view[e];
            if (i) {
              return i(e, n, o);
            }
            return null;
          };
        } else {
          return t.view;
        }
      }
      function $b(t) {
        if (typeof t == 'string') {
          return e => ({ key: t, value: e });
        } else if (typeof t == 'object') {
          if (t.value) {
            return () => t;
          } else {
            return e => ({ key: t.key, value: e });
          }
        } else {
          return t;
        }
      }
      function Wb(t, e, n) {
        const o = typeof t == 'function' ? t(e, n) : t;
        if (!o) {
          return null;
        }
        if (!o.priority) {
          o.priority = 10;
        }
        if (!o.id) {
          o.id = e.markerName;
        }
        return o;
      }
      function Gb(t) {
        return (e, n) => {
          if (!e.is('element', t.name)) {
            return false;
          }
          if (n.type == 'attribute') {
            if (t.attributes.includes(n.attributeKey)) {
              return true;
            }
          } else {
            if (t.children) {
              return true;
            }
          }
          return false;
        };
      }
      function Kb(t) {
        const e = Gb(t);
        return (t, n) => {
          const o = [];
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set();
          }
          for (const t of n.changes) {
            const i =
              t.type == 'attribute'
                ? t.range.start.nodeAfter
                : t.position.parent;
            if (!i || !e(i, t)) {
              o.push(t);
              continue;
            }
            if (!n.reconvertedElements.has(i)) {
              n.reconvertedElements.add(i);
              const t = Rk._createBefore(i);
              let e = o.length;
              for (let n = o.length - 1; n >= 0; n--) {
                const i = o[n];
                const r = i.type == 'attribute' ? i.range.start : i.position;
                const s = r.compareWith(t);
                if (s == 'before' || (i.type == 'remove' && s == 'same')) {
                  break;
                }
                e = n;
              }
              o.splice(
                e,
                0,
                { type: 'remove', name: i.name, position: t, length: 1 },
                { type: 'reinsert', name: i.name, position: t, length: 1 },
              );
            }
          }
          n.changes = o;
        };
      }
      function Ub(t) {
        return (e, n, o = {}) => {
          const i = ['insert'];
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              i.push(`attribute:${n}`);
            }
          }
          if (!i.every(t => n.test(e, t))) {
            return false;
          }
          if (!o.preflight) {
            i.forEach(t => n.consume(e, t));
          }
          return true;
        };
      }
      function Zb(t, e, n) {
        return (o, i) => {
          const r = o.createContainerElement('$slot');
          let s = null;
          if (i === 'children') {
            s = Array.from(t.getChildren());
          } else if (typeof i == 'function') {
            s = Array.from(t.getChildren()).filter(t => i(t));
          } else {
            throw new B('conversion-slot-mode-unknown', n.dispatcher, {
              modeOrFilter: i,
            });
          }
          e.set(r, s);
          return r;
        };
      }
      function Jb(t, e, n) {
        const o = Array.from(e.values()).flat();
        const i = new Set(o);
        if (i.size != o.length) {
          throw new B('conversion-slot-filter-overlap', n.dispatcher, {
            element: t,
          });
        }
        if (i.size != t.childCount) {
          throw new B('conversion-slot-filter-incomplete', n.dispatcher, {
            element: t,
          });
        }
      }
      function Yb(t, e, n, o) {
        n.mapper.on('modelToViewPosition', s, { priority: 'highest' });
        let i = null;
        let r = null;
        for ([i, r] of e) {
          Qb(t, r, n, o);
          n.writer.move(
            n.writer.createRangeIn(i),
            n.writer.createPositionBefore(i),
          );
          n.writer.remove(i);
        }
        n.mapper.off('modelToViewPosition', s);
        function s(t, e) {
          const n = e.modelPosition.nodeAfter;
          const o = r.indexOf(n);
          if (o < 0) {
            return;
          }
          e.viewPosition = e.mapper.findPositionIn(i, o);
        }
      }
      function Qb(t, e, n, o) {
        for (const i of e) {
          if (!Xb(t.root, i, n, o)) {
            n.convertItem(i);
          }
        }
      }
      function Xb(t, e, n, o) {
        const { writer: i, mapper: r } = n;
        if (!o.reconversion) {
          return false;
        }
        const s = r.toViewElement(e);
        if (!s || s.root == t) {
          return false;
        }
        if (!n.canReuseView(s)) {
          return false;
        }
        i.move(i.createRangeOn(s), r.toViewPosition(Rk._createBefore(e)));
        return true;
      }
      function tw(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, 'insert');
        } else {
          return e.consume(t, 'insert');
        }
      }
      function ew(t) {
        const { schema: e, document: n } = t.model;
        for (const o of n.getRoots()) {
          if (o.isEmpty && !e.checkChild(o, '$text')) {
            if (e.checkChild(o, 'paragraph')) {
              t.insertElement('paragraph', o);
              return true;
            }
          }
        }
        return false;
      }
      function nw(t, e, n) {
        const o = n.createContext(t);
        if (!n.checkChild(o, 'paragraph')) {
          return false;
        }
        if (!n.checkChild(o.push('paragraph'), e)) {
          return false;
        }
        return true;
      }
      function ow(t, e) {
        const n = e.createElement('paragraph');
        e.insert(n, t);
        return e.createPositionAt(n, 0);
      }
      class iw extends db {
        elementToElement(t) {
          return this.add(cw(t));
        }
        elementToAttribute(t) {
          return this.add(lw(t));
        }
        attributeToAttribute(t) {
          return this.add(dw(t));
        }
        elementToMarker(t) {
          return this.add(hw(t));
        }
        dataToMarker(t) {
          return this.add(uw(t));
        }
      }
      function rw() {
        return (t, e, n) => {
          if (
            !e.modelRange &&
            n.consumable.consume(e.viewItem, { name: true })
          ) {
            const { modelRange: t, modelCursor: o } = n.convertChildren(
              e.viewItem,
              e.modelCursor,
            );
            e.modelRange = t;
            e.modelCursor = o;
          }
        };
      }
      function sw() {
        return (t, e, { schema: n, consumable: o, writer: i }) => {
          let r = e.modelCursor;
          if (!o.test(e.viewItem)) {
            return;
          }
          if (!n.checkChild(r, '$text')) {
            if (!nw(r, '$text', n)) {
              return;
            }
            if (e.viewItem.data.trim().length == 0) {
              return;
            }
            const t = r.nodeBefore;
            r = ow(r, i);
            if (t && t.is('element', '$marker')) {
              i.move(i.createRangeOn(t), r);
              r = i.createPositionAfter(t);
            }
          }
          o.consume(e.viewItem);
          const s = i.createText(e.viewItem.data);
          i.insert(s, r);
          e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize));
          e.modelCursor = e.modelRange.end;
        };
      }
      function aw(t, e) {
        return (n, o) => {
          const i = o.newSelection;
          const r = [];
          for (const t of i.getRanges()) {
            r.push(e.toModelRange(t));
          }
          const s = t.createSelection(r, { backward: i.isBackward });
          if (!s.isEqual(t.document.selection)) {
            t.change(t => {
              t.setSelection(s);
            });
          }
        };
      }
      function cw(t) {
        t = vk(t);
        const e = gw(t);
        const n = pw(t.view);
        const o = n ? `element:${n}` : 'element';
        return n => {
          n.on(o, e, { priority: t.converterPriority || 'normal' });
        };
      }
      function lw(t) {
        t = vk(t);
        bw(t);
        const e = ww(t, false);
        const n = pw(t.view);
        const o = n ? `element:${n}` : 'element';
        return n => {
          n.on(o, e, { priority: t.converterPriority || 'low' });
        };
      }
      function dw(t) {
        t = vk(t);
        let e = null;
        if (typeof t.view == 'string' || t.view.key) {
          e = kw(t);
        }
        bw(t, e);
        const n = ww(t, true);
        return e => {
          e.on('element', n, { priority: t.converterPriority || 'low' });
        };
      }
      function hw(t) {
        const e = Aw(t.model);
        return cw({ ...t, model: e });
      }
      function uw(t) {
        t = vk(t);
        if (!t.model) {
          t.model = e => (e ? t.view + ':' + e : t.view);
        }
        const e = { view: t.view, model: t.model };
        const n = gw(Cw(e, 'start'));
        const o = gw(Cw(e, 'end'));
        return i => {
          i.on(`element:${t.view}-start`, n, {
            priority: t.converterPriority || 'normal',
          });
          i.on(`element:${t.view}-end`, o, {
            priority: t.converterPriority || 'normal',
          });
          const r = T.low;
          const s = T.highest;
          const a = T.get(t.converterPriority) / s;
          i.on('element', fw(e), { priority: r + a });
        };
      }
      function fw(t) {
        return (e, n, o) => {
          const i = `data-${t.view}`;
          if (
            !o.consumable.test(n.viewItem, { attributes: i + '-end-after' }) &&
            !o.consumable.test(n.viewItem, {
              attributes: i + '-start-after',
            }) &&
            !o.consumable.test(n.viewItem, { attributes: i + '-end-before' }) &&
            !o.consumable.test(n.viewItem, { attributes: i + '-start-before' })
          ) {
            return;
          }
          if (!n.modelRange) {
            Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor));
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + '-end-after' })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(i + '-end-after').split(','),
            );
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + '-start-after' })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(i + '-start-after').split(','),
            );
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + '-end-before' })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(i + '-end-before').split(','),
            );
          }
          if (
            o.consumable.consume(n.viewItem, {
              attributes: i + '-start-before',
            })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(i + '-start-before').split(','),
            );
          }
          function r(e, i) {
            for (const r of i) {
              const i = t.model(r, o);
              const s = o.writer.createElement('$marker', { 'data-name': i });
              o.writer.insert(s, e);
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1);
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1);
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0];
            }
          }
        };
      }
      function pw(t) {
        if (typeof t == 'string') {
          return t;
        }
        if (typeof t == 'object' && typeof t.name == 'string') {
          return t.name;
        }
        return null;
      }
      function gw(t) {
        const e = new ru(t.view);
        return (n, o, i) => {
          const r = e.match(o.viewItem);
          if (!r) {
            return;
          }
          const s = r.match;
          s.name = true;
          if (!i.consumable.test(o.viewItem, s)) {
            return;
          }
          const a = mw(t.model, o.viewItem, i);
          if (!a) {
            return;
          }
          if (!i.safeInsert(a, o.modelCursor)) {
            return;
          }
          i.consumable.consume(o.viewItem, s);
          i.convertChildren(o.viewItem, a);
          i.updateConversionResult(a, o);
        };
      }
      function mw(t, e, n) {
        if (t instanceof Function) {
          return t(e, n);
        } else {
          return n.writer.createElement(t);
        }
      }
      function kw(t) {
        if (typeof t.view == 'string') {
          t.view = { key: t.view };
        }
        const e = t.view.key;
        let n;
        if (e == 'class' || e == 'style') {
          const o = e == 'class' ? 'classes' : 'styles';
          n = { [o]: t.view.value };
        } else {
          const o =
            typeof t.view.value == 'undefined' ? /[\s\S]*/ : t.view.value;
          n = { attributes: { [e]: o } };
        }
        if (t.view.name) {
          n.name = t.view.name;
        }
        t.view = n;
        return e;
      }
      function bw(t, e = null) {
        const n = e === null ? true : t => t.getAttribute(e);
        const o = typeof t.model != 'object' ? t.model : t.model.key;
        const i =
          typeof t.model != 'object' || typeof t.model.value == 'undefined'
            ? n
            : t.model.value;
        t.model = { key: o, value: i };
      }
      function ww(t, e) {
        const n = new ru(t.view);
        return (o, i, r) => {
          if (!i.modelRange && e) {
            return;
          }
          const s = n.match(i.viewItem);
          if (!s) {
            return;
          }
          if (_w(t.view, i.viewItem)) {
            s.match.name = true;
          } else {
            delete s.match.name;
          }
          if (!r.consumable.test(i.viewItem, s.match)) {
            return;
          }
          const a = t.model.key;
          const c =
            typeof t.model.value == 'function'
              ? t.model.value(i.viewItem, r)
              : t.model.value;
          if (c === null) {
            return;
          }
          if (!i.modelRange) {
            Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
          }
          const l = vw(i.modelRange, { key: a, value: c }, e, r);
          if (l) {
            if (r.consumable.test(i.viewItem, { name: true })) {
              s.match.name = true;
            }
            r.consumable.consume(i.viewItem, s.match);
          }
        };
      }
      function _w(t, e) {
        const n = typeof t == 'function' ? t(e) : t;
        if (typeof n == 'object' && !pw(n)) {
          return false;
        }
        return !n.classes && !n.attributes && !n.styles;
      }
      function vw(t, e, n, o) {
        let i = false;
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (!o.schema.checkAttribute(r, e.key)) {
            continue;
          }
          i = true;
          if (r.hasAttribute(e.key)) {
            continue;
          }
          o.writer.setAttribute(e.key, e.value, r);
        }
        return i;
      }
      function Aw(t) {
        return (e, n) => {
          const o = typeof t == 'string' ? t : t(e, n);
          return n.writer.createElement('$marker', { 'data-name': o });
        };
      }
      function Cw(t, e) {
        const n = (e, n) => {
          const o = e.getAttribute('name');
          const i = t.model(o, n);
          return n.writer.createElement('$marker', { 'data-name': i });
        };
        return { view: `${t.view}-${e}`, model: n };
      }
      function yw(t) {
        t.document.registerPostFixer(e => xw(e, t));
      }
      function xw(t, e) {
        const n = e.document.selection;
        const o = e.schema;
        const i = [];
        let r = false;
        for (const t of n.getRanges()) {
          const e = Ew(t, o);
          if (e && !e.isEqual(t)) {
            i.push(e);
            r = true;
          } else {
            i.push(t);
          }
        }
        if (r) {
          t.setSelection(Bw(i), { backward: n.isBackward });
        }
        return false;
      }
      function Ew(t, e) {
        if (t.isCollapsed) {
          return Dw(t, e);
        }
        return Tw(t, e);
      }
      function Dw(t, e) {
        const n = t.start;
        const o = e.getNearestSelectionRange(n);
        if (!o) {
          const t = n
            .getAncestors()
            .reverse()
            .find(t => e.isObject(t));
          if (t) {
            return Nk._createOn(t);
          }
          return null;
        }
        if (!o.isCollapsed) {
          return o;
        }
        const i = o.start;
        if (n.isEqual(i)) {
          return null;
        }
        return new Nk(i);
      }
      function Tw(t, e) {
        const { start: n, end: o } = t;
        const i = e.checkChild(n, '$text');
        const r = e.checkChild(o, '$text');
        const s = e.getLimitElement(n);
        const a = e.getLimitElement(o);
        if (s === a) {
          if (i && r) {
            return null;
          }
          if (Pw(n, o, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
            const i = t ? null : e.getNearestSelectionRange(n, 'forward');
            const r = o.nodeBefore && e.isSelectable(o.nodeBefore);
            const s = r ? null : e.getNearestSelectionRange(o, 'backward');
            const a = i ? i.start : n;
            const c = s ? s.end : o;
            return new Nk(a, c);
          }
        }
        const c = s && !s.is('rootElement');
        const l = a && !a.is('rootElement');
        if (c || l) {
          const t =
            n.nodeAfter &&
            o.nodeBefore &&
            n.nodeAfter.parent === o.nodeBefore.parent;
          const i = c && (!t || !Rw(n.nodeAfter, e));
          const r = l && (!t || !Rw(o.nodeBefore, e));
          let d = n;
          let h = o;
          if (i) {
            d = Rk._createBefore(Sw(s, e));
          }
          if (r) {
            h = Rk._createAfter(Sw(a, e));
          }
          return new Nk(d, h);
        }
        return null;
      }
      function Sw(t, e) {
        let n = t;
        let o = n;
        while (e.isLimit(o) && o.parent) {
          n = o;
          o = o.parent;
        }
        return n;
      }
      function Pw(t, e, n) {
        const o =
          (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, '$text');
        const i =
          (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
          n.checkChild(e, '$text');
        return o || i;
      }
      function Bw(t) {
        const e = [...t];
        const n = new Set();
        let o = 1;
        while (o < e.length) {
          const t = e[o];
          const i = e.slice(0, o);
          for (const [r, s] of i.entries()) {
            if (n.has(r)) {
              continue;
            }
            if (t.isEqual(s)) {
              n.add(r);
            } else if (t.isIntersecting(s)) {
              n.add(r);
              n.add(o);
              const i = t.getJoined(s);
              e.push(i);
            }
          }
          o++;
        }
        const i = e.filter((t, e) => !n.has(e));
        return i;
      }
      function Rw(t, e) {
        return t && e.isSelectable(t);
      }
      class Ow extends dt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.view = new Ak(e);
          this.mapper = new Lk();
          this.downcastDispatcher = new qk({
            mapper: this.mapper,
            schema: t.schema,
          });
          const n = this.model.document;
          const o = n.selection;
          const i = this.model.markers;
          this.listenTo(
            this.model,
            '_beforeChanges',
            () => {
              this.view._disableRendering(true);
            },
            { priority: 'highest' },
          );
          this.listenTo(
            this.model,
            '_afterChanges',
            () => {
              this.view._disableRendering(false);
            },
            { priority: 'lowest' },
          );
          this.listenTo(
            n,
            'change',
            () => {
              this.view.change(t => {
                this.downcastDispatcher.convertChanges(n.differ, i, t);
                this.downcastDispatcher.convertSelection(o, i, t);
              });
            },
            { priority: 'low' },
          );
          this.listenTo(
            this.view.document,
            'selectionChange',
            aw(this.model, this.mapper),
          );
          this.listenTo(
            this.view.document,
            'beforeinput',
            Iw(this.mapper, this.model.schema, this.view),
            { priority: 'high' },
          );
          this.downcastDispatcher.on('insert:$text', ub(), {
            priority: 'lowest',
          });
          this.downcastDispatcher.on('insert', fb(), { priority: 'lowest' });
          this.downcastDispatcher.on('remove', pb(), { priority: 'low' });
          this.downcastDispatcher.on('cleanSelection', bb());
          this.downcastDispatcher.on('selection', mb(), { priority: 'low' });
          this.downcastDispatcher.on('selection', kb(), { priority: 'low' });
          this.view.document.roots
            .bindTo(this.model.document.roots)
            .using(t => {
              if (t.rootName == '$graveyard') {
                return null;
              }
              const e = new up(this.view.document, t.name);
              e.rootName = t.rootName;
              this.mapper.bindElements(t, e);
              return e;
            });
        }
        destroy() {
          this.view.destroy();
          this.stopListening();
        }
        reconvertMarker(t) {
          const e = typeof t == 'string' ? t : t.name;
          const n = this.model.markers.get(e);
          if (!n) {
            throw new B(
              'editingcontroller-reconvertmarker-marker-not-exist',
              this,
              { markerName: e },
            );
          }
          this.model.change(() => {
            this.model.markers._refresh(n);
          });
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t);
          });
        }
      }
      function Iw(t, e, n) {
        return (o, i) => {
          if (n.document.isComposing && !s.isAndroid) {
            return;
          }
          for (let n = 0; n < i.targetRanges.length; n++) {
            const o = i.targetRanges[n];
            const r = t.toModelRange(o);
            const s = Ew(r, e);
            if (!s || s.isEqual(r)) {
              continue;
            }
            i.targetRanges[n] = t.toViewRange(s);
          }
        };
      }
      class Mw {
        constructor() {
          this._consumables = new Map();
        }
        add(t, e) {
          let n;
          if (t.is('$text') || t.is('documentFragment')) {
            this._consumables.set(t, true);
            return;
          }
          if (!this._consumables.has(t)) {
            n = new zw(t);
            this._consumables.set(t, n);
          } else {
            n = this._consumables.get(t);
          }
          n.add(e);
        }
        test(t, e) {
          const n = this._consumables.get(t);
          if (n === undefined) {
            return null;
          }
          if (t.is('$text') || t.is('documentFragment')) {
            return n;
          }
          return n.test(e);
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, false);
            } else {
              this._consumables.get(t).consume(e);
            }
            return true;
          }
          return false;
        }
        revert(t, e) {
          const n = this._consumables.get(t);
          if (n !== undefined) {
            if (t.is('$text') || t.is('documentFragment')) {
              this._consumables.set(t, true);
            } else {
              n.revert(e);
            }
          }
        }
        static consumablesFromElement(t) {
          const e = {
            element: t,
            name: true,
            attributes: [],
            classes: [],
            styles: [],
          };
          const n = t.getAttributeKeys();
          for (const t of n) {
            if (t == 'style' || t == 'class') {
              continue;
            }
            e.attributes.push(t);
          }
          const o = t.getClassNames();
          for (const t of o) {
            e.classes.push(t);
          }
          const i = t.getStyleNames();
          for (const t of i) {
            e.styles.push(t);
          }
          return e;
        }
        static createFrom(t, e) {
          if (!e) {
            e = new Mw();
          }
          if (t.is('$text')) {
            e.add(t);
            return e;
          }
          if (t.is('element')) {
            e.add(t, Mw.consumablesFromElement(t));
          }
          if (t.is('documentFragment')) {
            e.add(t);
          }
          for (const n of t.getChildren()) {
            e = Mw.createFrom(n, e);
          }
          return e;
        }
      }
      const Vw = ['attributes', 'classes', 'styles'];
      class zw {
        constructor(t) {
          this.element = t;
          this._canConsumeName = null;
          this._consumables = {
            attributes: new Map(),
            styles: new Map(),
            classes: new Map(),
          };
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Vw) {
            if (e in t) {
              this._add(e, t[e]);
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName;
          }
          for (const e of Vw) {
            if (e in t) {
              const n = this._test(e, t[e]);
              if (n !== true) {
                return n;
              }
            }
          }
          return true;
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false;
          }
          for (const e of Vw) {
            if (e in t) {
              this._consume(e, t[e]);
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e of Vw) {
            if (e in t) {
              this._revert(e, t[e]);
            }
          }
        }
        _add(t, e) {
          const n = Ut(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              throw new B('viewconsumable-invalid-attribute', this);
            }
            o.set(e, true);
            if (t === 'styles') {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                e,
              )) {
                o.set(t, true);
              }
            }
          }
        }
        _test(t, e) {
          const n = Ut(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles';
              const n = this._test(t, [...this._consumables[t].keys()]);
              if (n !== true) {
                return n;
              }
            } else {
              const t = o.get(e);
              if (t === undefined) {
                return null;
              }
              if (!t) {
                return false;
              }
            }
          }
          return true;
        }
        _consume(t, e) {
          const n = Ut(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles';
              this._consume(t, [...this._consumables[t].keys()]);
            } else {
              o.set(e, false);
              if (t == 'styles') {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                  e,
                )) {
                  o.set(t, false);
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Ut(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === 'attributes' && (e === 'class' || e === 'style')) {
              const t = e == 'class' ? 'classes' : 'styles';
              this._revert(t, [...this._consumables[t].keys()]);
            } else {
              const t = o.get(e);
              if (t === false) {
                o.set(e, true);
              }
            }
          }
        }
      }
      class Fw extends dt() {
        constructor() {
          super();
          this._sourceDefinitions = {};
          this._attributeProperties = {};
          this.decorate('checkChild');
          this.decorate('checkAttribute');
          this.on(
            'checkAttribute',
            (t, e) => {
              e[0] = new Nw(e[0]);
            },
            { priority: 'highest' },
          );
          this.on(
            'checkChild',
            (t, e) => {
              e[0] = new Nw(e[0]);
              e[1] = this.getDefinition(e[1]);
            },
            { priority: 'highest' },
          );
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new B('schema-cannot-register-item-twice', this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)];
          this._clearCache();
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new B('schema-cannot-extend-missing-item', this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t].push(Object.assign({}, e));
          this._clearCache();
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile();
          }
          return this._compiledDefinitions;
        }
        getDefinition(t) {
          let e;
          if (typeof t == 'string') {
            e = t;
          } else if ('is' in t && (t.is('$text') || t.is('$textProxy'))) {
            e = '$text';
          } else {
            e = t.name;
          }
          return this.getDefinitions()[e];
        }
        isRegistered(t) {
          return !!this.getDefinition(t);
        }
        isBlock(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isBlock);
        }
        isLimit(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isLimit || e.isObject);
        }
        isObject(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent));
        }
        isInline(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isInline);
        }
        isSelectable(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isSelectable || e.isObject);
        }
        isContent(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isContent || e.isObject);
        }
        checkChild(t, e) {
          if (!e) {
            return false;
          }
          return this._checkContextMatch(e, t);
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last);
          if (!n) {
            return false;
          }
          return n.allowAttributes.includes(e);
        }
        checkMerge(t, e) {
          if (t instanceof Rk) {
            const e = t.nodeBefore;
            const n = t.nodeAfter;
            if (!(e instanceof Tk)) {
              throw new B('schema-check-merge-no-element-before', this);
            }
            if (!(n instanceof Tk)) {
              throw new B('schema-check-merge-no-element-after', this);
            }
            return this.checkMerge(e, n);
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false;
            }
          }
          return true;
        }
        addChildCheck(t) {
          this.on(
            'checkChild',
            (e, [n, o]) => {
              if (!o) {
                return;
              }
              const i = t(n, o);
              if (typeof i == 'boolean') {
                e.stop();
                e.return = i;
              }
            },
            { priority: 'high' },
          );
        }
        addAttributeCheck(t) {
          this.on(
            'checkAttribute',
            (e, [n, o]) => {
              const i = t(n, o);
              if (typeof i == 'boolean') {
                e.stop();
                e.return = i;
              }
            },
            { priority: 'high' },
          );
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(
            this.getAttributeProperties(t),
            e,
          );
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {};
        }
        getLimitElement(t) {
          let e;
          if (t instanceof Rk) {
            e = t.parent;
          } else {
            const n = t instanceof Nk ? [t] : Array.from(t.getRanges());
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor();
              if (!t) {
                return n;
              }
              return t.getCommonAncestor(n, { includeSelf: true });
            }, null);
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent;
            } else {
              break;
            }
          }
          return e;
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition();
            const o = [...n.getAncestors(), new Ek('', t.getAttributes())];
            return this.checkAttribute(o, e);
          } else {
            const n = t.getRanges();
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        *getValidRanges(t, e) {
          t = n_(t);
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e);
          }
        }
        getNearestSelectionRange(t, e = 'both') {
          if (t.root.rootName == '$graveyard') {
            return null;
          }
          if (this.checkChild(t, '$text')) {
            return new Nk(t);
          }
          let n, o;
          const i =
            t
              .getAncestors()
              .reverse()
              .find(t => this.isLimit(t)) || t.root;
          if (e == 'both' || e == 'backward') {
            n = new Pk({
              boundaries: Nk._createIn(i),
              startPosition: t,
              direction: 'backward',
            });
          }
          if (e == 'both' || e == 'forward') {
            o = new Pk({ boundaries: Nk._createIn(i), startPosition: t });
          }
          for (const t of e_(n, o)) {
            const e = t.walker == n ? 'elementEnd' : 'elementStart';
            const o = t.value;
            if (o.type == e && this.isObject(o.item)) {
              return Nk._createOn(o.item);
            }
            if (this.checkChild(o.nextPosition, '$text')) {
              return new Nk(o.nextPosition);
            }
          }
          return null;
        }
        findAllowedParent(t, e) {
          let n = t.parent;
          while (n) {
            if (this.checkChild(n, e)) {
              return n;
            }
            if (this.isLimit(n)) {
              return null;
            }
            n = n.parent;
          }
          return null;
        }
        setAllowedAttributes(t, e, n) {
          const o = n.model;
          for (const [i, r] of Object.entries(e)) {
            if (o.schema.checkAttribute(t, i)) {
              n.setAttribute(i, r, t);
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is('$text')) {
              o_(this, n, e);
            } else {
              const t = Nk._createIn(n);
              const o = t.getPositions();
              for (const t of o) {
                const n = t.nodeBefore || t.parent;
                o_(this, n, e);
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const o = {};
          for (const [i, r] of t.getAttributes()) {
            const t = this.getAttributeProperties(i);
            if (t[e] === undefined) {
              continue;
            }
            if (n === undefined || n === t[e]) {
              o[i] = r;
            }
          }
          return o;
        }
        createContext(t) {
          return new Nw(t);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t = {};
          const e = this._sourceDefinitions;
          const n = Object.keys(e);
          for (const o of n) {
            t[o] = Lw(e[o], o);
          }
          for (const e of n) {
            Hw(t, e);
          }
          for (const e of n) {
            jw(t, e);
          }
          for (const e of n) {
            qw(t, e);
          }
          for (const e of n) {
            $w(t, e);
            Ww(t, e);
          }
          for (const e of n) {
            Gw(t, e);
            Kw(t, e);
            Uw(t, e);
          }
          this._compiledDefinitions = t;
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const o = e.getItem(n);
          if (t.allowIn.includes(o.name)) {
            if (n == 0) {
              return true;
            } else {
              const t = this.getDefinition(o);
              return this._checkContextMatch(t, e, n - 1);
            }
          } else {
            return false;
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start;
          let o = t.start;
          for (const i of t.getItems({ shallow: true })) {
            if (i.is('element')) {
              yield* this._getValidRangesForRange(Nk._createIn(i), e);
            }
            if (!this.checkAttribute(i, e)) {
              if (!n.isEqual(o)) {
                yield new Nk(n, o);
              }
              n = Rk._createAfter(i);
            }
            o = Rk._createAfter(i);
          }
          if (!n.isEqual(o)) {
            yield new Nk(n, o);
          }
        }
      }
      class Nw {
        constructor(t) {
          if (t instanceof Nw) {
            return t;
          }
          let e;
          if (typeof t == 'string') {
            e = [t];
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true });
          } else {
            e = t;
          }
          this._items = e.map(t_);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t) {
          const e = new Nw([t]);
          e._items = [...this._items, ...e._items];
          return e;
        }
        getItem(t) {
          return this._items[t];
        }
        *getNames() {
          yield* this._items.map(t => t.name);
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(' ').endsWith(t);
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(' ').startsWith(t);
        }
      }
      function Lw(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        };
        Zw(t, n);
        Jw(t, n, 'allowIn');
        Jw(t, n, 'allowContentOf');
        Jw(t, n, 'allowWhere');
        Jw(t, n, 'allowAttributes');
        Jw(t, n, 'allowAttributesOf');
        Jw(t, n, 'allowChildren');
        Jw(t, n, 'inheritTypesFrom');
        Yw(t, n);
        return n;
      }
      function Hw(t, e) {
        const n = t[e];
        for (const o of n.allowChildren) {
          const n = t[o];
          if (!n) {
            continue;
          }
          n.allowIn.push(e);
        }
        n.allowChildren.length = 0;
      }
      function jw(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const o = Qw(t, n);
            o.forEach(t => {
              t.allowIn.push(e);
            });
          }
        }
        delete t[e].allowContentOf;
      }
      function qw(t, e) {
        for (const n of t[e].allowWhere) {
          const o = t[n];
          if (o) {
            const n = o.allowIn;
            t[e].allowIn.push(...n);
          }
        }
        delete t[e].allowWhere;
      }
      function $w(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const o = t[n];
          if (o) {
            const n = o.allowAttributes;
            t[e].allowAttributes.push(...n);
          }
        }
        delete t[e].allowAttributesOf;
      }
      function Ww(t, e) {
        const n = t[e];
        for (const e of n.inheritTypesFrom) {
          const o = t[e];
          if (o) {
            const t = Object.keys(o).filter(t => t.startsWith('is'));
            for (const e of t) {
              if (!(e in n)) {
                n[e] = o[e];
              }
            }
          }
        }
        delete n.inheritTypesFrom;
      }
      function Gw(t, e) {
        const n = t[e];
        const o = n.allowIn.filter(e => t[e]);
        n.allowIn = Array.from(new Set(o));
      }
      function Kw(t, e) {
        const n = t[e];
        for (const o of n.allowIn) {
          const n = t[o];
          n.allowChildren.push(e);
        }
      }
      function Uw(t, e) {
        const n = t[e];
        n.allowAttributes = Array.from(new Set(n.allowAttributes));
      }
      function Zw(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter(t => t.startsWith('is'));
          for (const o of t) {
            e[o] = !!n[o];
          }
        }
      }
      function Jw(t, e, n) {
        for (const o of t) {
          const t = o[n];
          if (typeof t == 'string') {
            e[n].push(t);
          } else if (Array.isArray(t)) {
            e[n].push(...t);
          }
        }
      }
      function Yw(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom;
          if (t) {
            e.allowContentOf.push(t);
            e.allowWhere.push(t);
            e.allowAttributesOf.push(t);
            e.inheritTypesFrom.push(t);
          }
        }
      }
      function Qw(t, e) {
        const n = t[e];
        return Xw(t).filter(t => t.allowIn.includes(n.name));
      }
      function Xw(t) {
        return Object.keys(t).map(e => t[e]);
      }
      function t_(t) {
        if (typeof t == 'string' || t.is('documentFragment')) {
          return {
            name: typeof t == 'string' ? t : '$documentFragment',
            *getAttributeKeys() {},
            getAttribute() {},
          };
        } else {
          return {
            name: t.is('element') ? t.name : '$text',
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute(e) {
              return t.getAttribute(e);
            },
          };
        }
      }
      function* e_(t, e) {
        let n = false;
        while (!n) {
          n = true;
          if (t) {
            const e = t.next();
            if (!e.done) {
              n = false;
              yield { walker: t, value: e.value };
            }
          }
          if (e) {
            const t = e.next();
            if (!t.done) {
              n = false;
              yield { walker: e, value: t.value };
            }
          }
        }
      }
      function* n_(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges();
        }
      }
      function o_(t, e, n) {
        for (const o of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, o)) {
            n.removeAttribute(o, e);
          }
        }
      }
      class i_ extends $() {
        constructor(t) {
          super();
          this._splitParts = new Map();
          this._cursorParents = new Map();
          this._modelCursor = null;
          this._emptyElementsToKeep = new Set();
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) =>
              this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
            getSplitParts: t => this._getSplitParts(t),
            keepEmptyElement: t => this._keepEmptyElement(t),
          };
        }
        convert(t, e, n = ['$root']) {
          this.fire('viewCleanup', t);
          this._modelCursor = s_(n, e);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = Mw.createFrom(t);
          this.conversionApi.store = {};
          const { modelRange: o } = this._convertItem(t, this._modelCursor);
          const i = e.createDocumentFragment();
          if (o) {
            this._removeEmptyElements();
            for (const t of Array.from(
              this._modelCursor.parent.getChildren(),
            )) {
              e.append(t, i);
            }
            i.markers = r_(i, e);
          }
          this._modelCursor = null;
          this._splitParts.clear();
          this._cursorParents.clear();
          this._emptyElementsToKeep.clear();
          this.conversionApi.writer = null;
          this.conversionApi.store = null;
          return i;
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null };
          if (t.is('element')) {
            this.fire(`element:${t.name}`, n, this.conversionApi);
          } else if (t.is('$text')) {
            this.fire('text', n, this.conversionApi);
          } else {
            this.fire('documentFragment', n, this.conversionApi);
          }
          if (n.modelRange && !(n.modelRange instanceof Nk)) {
            throw new B('view-conversion-dispatcher-incorrect-result', this);
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(t, e) {
          let n = e.is('position') ? e : Rk._createAt(e, 0);
          const o = new Nk(n);
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n);
            if (t.modelRange instanceof Nk) {
              o.end = t.modelRange.end;
              n = t.modelCursor;
            }
          }
          return { modelRange: o, modelCursor: n };
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e);
          if (!n) {
            return false;
          }
          this.conversionApi.writer.insert(t, n.position);
          return true;
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t);
          const o = this.conversionApi.writer;
          if (!e.modelRange) {
            e.modelRange = o.createRange(
              o.createPositionBefore(t),
              o.createPositionAfter(n[n.length - 1]),
            );
          }
          const i = this._cursorParents.get(t);
          if (i) {
            e.modelCursor = o.createPositionAt(i, 0);
          } else {
            e.modelCursor = e.modelRange.end;
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: o } = this.conversionApi;
          let i = n.findAllowedParent(e, t);
          if (i) {
            if (i === e.parent) {
              return { position: e };
            }
            if (this._modelCursor.parent.getAncestors().includes(i)) {
              i = null;
            }
          }
          if (!i) {
            if (!nw(e, t, n)) {
              return null;
            }
            return { position: ow(e, o) };
          }
          const r = this.conversionApi.writer.split(e, i);
          const s = [];
          for (const t of r.range.getWalker()) {
            if (t.type == 'elementEnd') {
              s.push(t.item);
            } else {
              const e = s.pop();
              const n = t.item;
              this._registerSplitPair(e, n);
            }
          }
          const a = r.range.end.parent;
          this._cursorParents.set(t, a);
          return { position: r.position, cursorParent: a };
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t]);
          }
          const n = this._splitParts.get(t);
          this._splitParts.set(e, n);
          n.push(e);
        }
        _getSplitParts(t) {
          let e;
          if (!this._splitParts.has(t)) {
            e = [t];
          } else {
            e = this._splitParts.get(t);
          }
          return e;
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t);
        }
        _removeEmptyElements() {
          let t = false;
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e);
              this._splitParts.delete(e);
              t = true;
            }
          }
          if (t) {
            this._removeEmptyElements();
          }
        }
      }
      function r_(t, e) {
        const n = new Set();
        const o = new Map();
        const i = Nk._createIn(t).getItems();
        for (const t of i) {
          if (t.is('element', '$marker')) {
            n.add(t);
          }
        }
        for (const t of n) {
          const n = t.getAttribute('data-name');
          const i = e.createPositionBefore(t);
          if (!o.has(n)) {
            o.set(n, new Nk(i.clone()));
          } else {
            o.get(n).end = i.clone();
          }
          e.remove(t);
        }
        return o;
      }
      function s_(t, e) {
        let n;
        for (const o of new Nw(t)) {
          const t = {};
          for (const e of o.getAttributeKeys()) {
            t[e] = o.getAttribute(e);
          }
          const i = e.createElement(o.name, t);
          if (n) {
            e.insert(i, n);
          }
          n = Rk._createAt(i, 0);
        }
        return n;
      }
      class a_ {
        getHtml(t) {
          const e = Xa.document.implementation.createHTMLDocument('');
          const n = e.createElement('div');
          n.appendChild(t);
          return n.innerHTML;
        }
      }
      class c_ {
        constructor(t) {
          this.skipComments = true;
          this.domParser = new DOMParser();
          this.domConverter = new Sg(t, { renderingMode: 'data' });
          this.htmlWriter = new a_();
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t);
          return this.htmlWriter.getHtml(e);
        }
        toView(t) {
          const e = this._toDom(t);
          return this.domConverter.domToView(e, {
            skipComments: this.skipComments,
          });
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t);
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode =
            t == 'marked' ? 'markedNbsp' : 'nbsp';
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
            t = `<body>${t}</body>`;
          }
          const e = this.domParser.parseFromString(t, 'text/html');
          const n = e.createDocumentFragment();
          const o = e.body.childNodes;
          while (o.length > 0) {
            n.appendChild(o[0]);
          }
          return n;
        }
      }
      class l_ extends $() {
        constructor(t, e) {
          super();
          this.model = t;
          this.mapper = new Lk();
          this.downcastDispatcher = new qk({
            mapper: this.mapper,
            schema: t.schema,
          });
          this.downcastDispatcher.on('insert:$text', ub(), {
            priority: 'lowest',
          });
          this.downcastDispatcher.on('insert', fb(), { priority: 'lowest' });
          this.upcastDispatcher = new i_({ schema: t.schema });
          this.viewDocument = new Dp(e);
          this.stylesProcessor = e;
          this.htmlProcessor = new c_(this.viewDocument);
          this.processor = this.htmlProcessor;
          this._viewWriter = new jp(this.viewDocument);
          this.upcastDispatcher.on('text', sw(), { priority: 'lowest' });
          this.upcastDispatcher.on('element', rw(), { priority: 'lowest' });
          this.upcastDispatcher.on('documentFragment', rw(), {
            priority: 'lowest',
          });
          dt().prototype.decorate.call(this, 'init');
          dt().prototype.decorate.call(this, 'set');
          dt().prototype.decorate.call(this, 'get');
          dt().prototype.decorate.call(this, 'toView');
          dt().prototype.decorate.call(this, 'toModel');
          this.on(
            'init',
            () => {
              this.fire('ready');
            },
            { priority: 'lowest' },
          );
          this.on(
            'ready',
            () => {
              this.model.enqueueChange({ isUndoable: false }, ew);
            },
            { priority: 'lowest' },
          );
        }
        get(t = {}) {
          const { rootName: e = 'main', trim: n = 'empty' } = t;
          if (!this._checkIfRootsExists([e])) {
            throw new B('datacontroller-get-non-existent-root', this);
          }
          const o = this.model.document.getRoot(e);
          if (!o.isAttached()) {
            R('datacontroller-get-detached-root', this);
          }
          if (
            n === 'empty' &&
            !this.model.hasContent(o, { ignoreWhitespaces: true })
          ) {
            return '';
          }
          return this.stringify(o, t);
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e);
          return this.processor.toData(n);
        }
        toView(t, e = {}) {
          const n = this.viewDocument;
          const o = this._viewWriter;
          this.mapper.clearBindings();
          const i = Nk._createIn(t);
          const r = new Lp(n);
          this.mapper.bindElements(t, r);
          const s = t.is('documentFragment') ? t.markers : d_(t);
          this.downcastDispatcher.convert(i, s, o, e);
          return r;
        }
        init(t) {
          if (this.model.document.version) {
            throw new B('datacontroller-init-document-not-empty', this);
          }
          let e = {};
          if (typeof t === 'string') {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new B('datacontroller-init-non-existent-root', this);
          }
          this.model.enqueueChange({ isUndoable: false }, t => {
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], o), o, 0);
            }
          });
          return Promise.resolve();
        }
        set(t, e = {}) {
          let n = {};
          if (typeof t === 'string') {
            n.main = t;
          } else {
            n = t;
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new B('datacontroller-set-non-existent-root', this);
          }
          this.model.enqueueChange(e.batchType || {}, t => {
            t.setSelection(null);
            t.removeSelectionAttribute(
              this.model.document.selection.getAttributeKeys(),
            );
            for (const e of Object.keys(n)) {
              const o = this.model.document.getRoot(e);
              t.remove(t.createRangeIn(o));
              t.insert(this.parse(n[e], o), o, 0);
            }
          });
        }
        parse(t, e = '$root') {
          const n = this.processor.toView(t);
          return this.toModel(n, e);
        }
        toModel(t, e = '$root') {
          return this.model.change(n => this.upcastDispatcher.convert(t, n, e));
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor);
        }
        registerRawContentMatcher(t) {
          if (this.processor && this.processor !== this.htmlProcessor) {
            this.processor.registerRawContentMatcher(t);
          }
          this.htmlProcessor.registerRawContentMatcher(t);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRoot(e)) {
              return false;
            }
          }
          return true;
        }
      }
      function d_(t) {
        const e = [];
        const n = t.root.document;
        if (!n) {
          return new Map();
        }
        const o = Nk._createIn(t);
        for (const t of n.model.markers) {
          const n = t.getRange();
          const i = n.isCollapsed;
          const r = n.start.isEqual(o.start) || n.end.isEqual(o.end);
          if (i && r) {
            e.push([t.name, n]);
          } else {
            const i = o.getIntersection(n);
            if (i) {
              e.push([t.name, i]);
            }
          }
        }
        e.sort(([t, e], [n, o]) => {
          if (e.end.compareWith(o.start) !== 'after') {
            return 1;
          } else if (e.start.compareWith(o.end) !== 'before') {
            return -1;
          } else {
            switch (e.start.compareWith(o.start)) {
              case 'before':
                return 1;
              case 'after':
                return -1;
              default:
                switch (e.end.compareWith(o.end)) {
                  case 'before':
                    return 1;
                  case 'after':
                    return -1;
                  default:
                    return n.localeCompare(t);
                }
            }
          }
        });
        return new Map(e);
      }
      class h_ {
        constructor(t, e) {
          this._helpers = new Map();
          this._downcast = tl(t);
          this._createConversionHelpers({
            name: 'downcast',
            dispatchers: this._downcast,
            isDowncast: true,
          });
          this._upcast = tl(e);
          this._createConversionHelpers({
            name: 'upcast',
            dispatchers: this._upcast,
            isDowncast: false,
          });
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e);
          const o = this._upcast.includes(e);
          if (!o && !n) {
            throw new B('conversion-add-alias-dispatcher-not-registered', this);
          }
          this._createConversionHelpers({
            name: t,
            dispatchers: [e],
            isDowncast: n,
          });
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new B('conversion-for-unknown-group', this);
          }
          return this._helpers.get(t);
        }
        elementToElement(t) {
          this.for('downcast').elementToElement(t);
          for (const { model: e, view: n } of u_(t)) {
            this.for('upcast').elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToElement(t) {
          this.for('downcast').attributeToElement(t);
          for (const { model: e, view: n } of u_(t)) {
            this.for('upcast').elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToAttribute(t) {
          this.for('downcast').attributeToAttribute(t);
          for (const { model: e, view: n } of u_(t)) {
            this.for('upcast').attributeToAttribute({ view: n, model: e });
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new B('conversion-group-exists', this);
          }
          const o = n ? new hb(e) : new iw(e);
          this._helpers.set(t, o);
        }
      }
      function* u_(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e };
            const o = t.view[e];
            const i = t.upcastAlso ? t.upcastAlso[e] : undefined;
            yield* f_(n, o, i);
          }
        } else {
          yield* f_(t.model, t.view, t.upcastAlso);
        }
      }
      function* f_(t, e, n) {
        yield { model: t, view: e };
        if (n) {
          for (const e of tl(n)) {
            yield { model: t, view: e };
          }
        }
      }
      class p_ {
        constructor(t) {
          this.baseVersion = t;
          this.isDocumentOperation = this.baseVersion !== null;
          this.batch = null;
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this);
          t.__className = this.constructor.className;
          delete t.batch;
          delete t.isDocumentOperation;
          return t;
        }
        static get className() {
          return 'Operation';
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion);
        }
      }
      function g_(t, e) {
        const n = w_(e);
        const o = n.reduce((t, e) => t + e.offsetSize, 0);
        const i = t.parent;
        v_(t);
        const r = t.index;
        i._insertChild(r, n);
        __(i, r + n.length);
        __(i, r);
        return new Nk(t, t.getShiftedBy(o));
      }
      function m_(t) {
        if (!t.isFlat) {
          throw new B('operation-utils-remove-range-not-flat', this);
        }
        const e = t.start.parent;
        v_(t.start);
        v_(t.end);
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
        __(e, t.start.index);
        return n;
      }
      function k_(t, e) {
        if (!t.isFlat) {
          throw new B('operation-utils-move-range-not-flat', this);
        }
        const n = m_(t);
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
        return g_(e, n);
      }
      function b_(t, e, n) {
        v_(t.start);
        v_(t.end);
        for (const o of t.getItems({ shallow: true })) {
          const t = o.is('$textProxy') ? o.textNode : o;
          if (n !== null) {
            t._setAttribute(e, n);
          } else {
            t._removeAttribute(e);
          }
          __(t.parent, t.index);
        }
        __(t.end.parent, t.end.index);
      }
      function w_(t) {
        const e = [];
        function n(t) {
          if (typeof t == 'string') {
            e.push(new Ek(t));
          } else if (t instanceof Dk) {
            e.push(new Ek(t.data, t.getAttributes()));
          } else if (t instanceof yk) {
            e.push(t);
          } else if (yt(t)) {
            for (const e of t) {
              n(e);
            }
          } else {
            const e = t;
          }
        }
        n(t);
        for (let t = 1; t < e.length; t++) {
          const n = e[t];
          const o = e[t - 1];
          if (n instanceof Ek && o instanceof Ek && A_(n, o)) {
            e.splice(t - 1, 2, new Ek(o.data + n.data, o.getAttributes()));
            t--;
          }
        }
        return e;
      }
      function __(t, e) {
        const n = t.getChild(e - 1);
        const o = t.getChild(e);
        if (n && o && n.is('$text') && o.is('$text') && A_(n, o)) {
          const i = new Ek(n.data + o.data, n.getAttributes());
          t._removeChildren(e - 1, 2);
          t._insertChild(e - 1, i);
        }
      }
      function v_(t) {
        const e = t.textNode;
        const n = t.parent;
        if (e) {
          const o = t.offset - e.startOffset;
          const i = e.index;
          n._removeChildren(i, 1);
          const r = new Ek(e.data.substr(0, o), e.getAttributes());
          const s = new Ek(e.data.substr(o), e.getAttributes());
          n._insertChild(i, [r, s]);
        }
      }
      function A_(t, e) {
        const n = t.getAttributes();
        const o = e.getAttributes();
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false;
          }
          o.next();
        }
        return o.next().done;
      }
      class C_ extends p_ {
        constructor(t, e, n, o) {
          super(o);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = 'toNext';
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = 'toNone';
        }
        get type() {
          if (this.targetPosition.root.rootName == '$graveyard') {
            return 'remove';
          } else if (this.sourcePosition.root.rootName == '$graveyard') {
            return 'reinsert';
          }
          return 'move';
        }
        get affectedSelectable() {
          return [
            Nk._createFromPositionAndShift(this.sourcePosition, this.howMany),
            Nk._createFromPositionAndShift(this.targetPosition, 0),
          ];
        }
        clone() {
          return new C_(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.baseVersion,
          );
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(
            this.sourcePosition,
            this.howMany,
          );
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany,
          );
          return new C_(
            this.getMovedRangeStart(),
            this.howMany,
            t,
            this.baseVersion + 1,
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          const n = this.sourcePosition.offset;
          const o = this.targetPosition.offset;
          if (n + this.howMany > t.maxOffset) {
            throw new B('move-operation-nodes-do-not-exist', this);
          } else if (t === e && n < o && o < n + this.howMany) {
            throw new B('move-operation-range-into-itself', this);
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (
              Ct(
                this.sourcePosition.getParentPath(),
                this.targetPosition.getParentPath(),
              ) == 'prefix'
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new B('move-operation-node-into-itself', this);
              }
            }
          }
        }
        _execute() {
          k_(
            Nk._createFromPositionAndShift(this.sourcePosition, this.howMany),
            this.targetPosition,
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          t.targetPosition = this.targetPosition.toJSON();
          return t;
        }
        static get className() {
          return 'MoveOperation';
        }
        static fromJSON(t, e) {
          const n = Rk.fromJSON(t.sourcePosition, e);
          const o = Rk.fromJSON(t.targetPosition, e);
          return new this(n, t.howMany, o, t.baseVersion);
        }
      }
      class y_ extends p_ {
        constructor(t, e, n) {
          super(n);
          this.position = t.clone();
          this.position.stickiness = 'toNone';
          this.nodes = new xk(w_(e));
          this.shouldReceiveAttributes = false;
        }
        get type() {
          return 'insert';
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const t = new xk([...this.nodes].map(t => t._clone(true)));
          const e = new y_(this.position, t, this.baseVersion);
          e.shouldReceiveAttributes = this.shouldReceiveAttributes;
          return e;
        }
        getReversed() {
          const t = this.position.root.document.graveyard;
          const e = new Rk(t, [0]);
          return new C_(
            this.position,
            this.nodes.maxOffset,
            e,
            this.baseVersion + 1,
          );
        }
        _validate() {
          const t = this.position.parent;
          if (!t || t.maxOffset < this.position.offset) {
            throw new B('insert-operation-position-invalid', this);
          }
        }
        _execute() {
          const t = this.nodes;
          this.nodes = new xk([...t].map(t => t._clone(true)));
          g_(this.position, t);
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          t.nodes = this.nodes.toJSON();
          return t;
        }
        static get className() {
          return 'InsertOperation';
        }
        static fromJSON(t, e) {
          const n = [];
          for (const e of t.nodes) {
            if (e.name) {
              n.push(Tk.fromJSON(e));
            } else {
              n.push(Ek.fromJSON(e));
            }
          }
          const o = new y_(Rk.fromJSON(t.position, e), n, t.baseVersion);
          o.shouldReceiveAttributes = t.shouldReceiveAttributes;
          return o;
        }
      }
      class x_ extends p_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.splitPosition = t.clone();
          this.splitPosition.stickiness = 'toNext';
          this.howMany = e;
          this.insertionPosition = n;
          this.graveyardPosition = o ? o.clone() : null;
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = 'toNext';
          }
        }
        get type() {
          return 'split';
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice();
          t.push(0);
          return new Rk(this.insertionPosition.root, t);
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Nk(this.splitPosition, t);
        }
        get affectedSelectable() {
          const t = [
            Nk._createFromPositionAndShift(this.splitPosition, 0),
            Nk._createFromPositionAndShift(this.insertionPosition, 0),
          ];
          if (this.graveyardPosition) {
            t.push(Nk._createFromPositionAndShift(this.graveyardPosition, 0));
          }
          return t;
        }
        clone() {
          return new x_(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion,
          );
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard;
          const e = new Rk(t, [0]);
          return new E_(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1,
          );
        }
        _validate() {
          const t = this.splitPosition.parent;
          const e = this.splitPosition.offset;
          if (!t || t.maxOffset < e) {
            throw new B('split-operation-position-invalid', this);
          } else if (!t.parent) {
            throw new B('split-operation-split-in-root', this);
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new B('split-operation-how-many-invalid', this);
          } else if (
            this.graveyardPosition &&
            !this.graveyardPosition.nodeAfter
          ) {
            throw new B('split-operation-graveyard-position-invalid', this);
          }
        }
        _execute() {
          const t = this.splitPosition.parent;
          if (this.graveyardPosition) {
            k_(
              Nk._createFromPositionAndShift(this.graveyardPosition, 1),
              this.insertionPosition,
            );
          } else {
            const e = t._clone();
            g_(this.insertionPosition, e);
          }
          const e = new Nk(
            Rk._createAt(t, this.splitPosition.offset),
            Rk._createAt(t, t.maxOffset),
          );
          k_(e, this.moveTargetPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.splitPosition = this.splitPosition.toJSON();
          t.insertionPosition = this.insertionPosition.toJSON();
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON();
          }
          return t;
        }
        static get className() {
          return 'SplitOperation';
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1);
          e[e.length - 1]++;
          return new Rk(t.root, e, 'toPrevious');
        }
        static fromJSON(t, e) {
          const n = Rk.fromJSON(t.splitPosition, e);
          const o = Rk.fromJSON(t.insertionPosition, e);
          const i = t.graveyardPosition
            ? Rk.fromJSON(t.graveyardPosition, e)
            : null;
          return new this(n, t.howMany, o, i, t.baseVersion);
        }
      }
      class E_ extends p_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = 'toPrevious';
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = 'toNext';
          this.graveyardPosition = o.clone();
        }
        get type() {
          return 'merge';
        }
        get deletionPosition() {
          return new Rk(
            this.sourcePosition.root,
            this.sourcePosition.path.slice(0, -1),
          );
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Nk(this.sourcePosition, t);
        }
        get affectedSelectable() {
          const t = this.sourcePosition.parent;
          return [
            Nk._createOn(t),
            Nk._createFromPositionAndShift(this.targetPosition, 0),
            Nk._createFromPositionAndShift(this.graveyardPosition, 0),
          ];
        }
        clone() {
          return new E_(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion,
          );
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this);
          const e = this.sourcePosition.path.slice(0, -1);
          const n = new Rk(
            this.sourcePosition.root,
            e,
          )._getTransformedByMergeOperation(this);
          return new x_(
            t,
            this.howMany,
            n,
            this.graveyardPosition,
            this.baseVersion + 1,
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          if (!t.parent) {
            throw new B('merge-operation-source-position-invalid', this);
          } else if (!e.parent) {
            throw new B('merge-operation-target-position-invalid', this);
          } else if (this.howMany != t.maxOffset) {
            throw new B('merge-operation-how-many-invalid', this);
          }
        }
        _execute() {
          const t = this.sourcePosition.parent;
          const e = Nk._createIn(t);
          k_(e, this.targetPosition);
          k_(Nk._createOn(t), this.graveyardPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = t.sourcePosition.toJSON();
          t.targetPosition = t.targetPosition.toJSON();
          t.graveyardPosition = t.graveyardPosition.toJSON();
          return t;
        }
        static get className() {
          return 'MergeOperation';
        }
        static fromJSON(t, e) {
          const n = Rk.fromJSON(t.sourcePosition, e);
          const o = Rk.fromJSON(t.targetPosition, e);
          const i = Rk.fromJSON(t.graveyardPosition, e);
          return new this(n, t.howMany, o, i, t.baseVersion);
        }
      }
      class D_ extends p_ {
        constructor(t, e, n, o, i, r) {
          super(r);
          this.name = t;
          this.oldRange = e ? e.clone() : null;
          this.newRange = n ? n.clone() : null;
          this.affectsData = i;
          this._markers = o;
        }
        get type() {
          return 'marker';
        }
        get affectedSelectable() {
          const t = [];
          if (this.oldRange) {
            t.push(this.oldRange.clone());
          }
          if (this.newRange) {
            if (this.oldRange) {
              t.push(...this.newRange.getDifference(this.oldRange));
            } else {
              t.push(this.newRange.clone());
            }
          }
          return t;
        }
        clone() {
          return new D_(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion,
          );
        }
        getReversed() {
          return new D_(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1,
          );
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(
              this.name,
              this.newRange,
              true,
              this.affectsData,
            );
          } else {
            this._markers._remove(this.name);
          }
        }
        toJSON() {
          const t = super.toJSON();
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON();
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON();
          }
          delete t._markers;
          return t;
        }
        static get className() {
          return 'MarkerOperation';
        }
        static fromJSON(t, e) {
          return new D_(
            t.name,
            t.oldRange ? Nk.fromJSON(t.oldRange, e) : null,
            t.newRange ? Nk.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion,
          );
        }
      }
      function T_(t, e) {
        return rk(t, e);
      }
      const S_ = T_;
      class P_ extends p_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.range = t.clone();
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = o === undefined ? null : o;
        }
        get type() {
          if (this.oldValue === null) {
            return 'addAttribute';
          } else if (this.newValue === null) {
            return 'removeAttribute';
          } else {
            return 'changeAttribute';
          }
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new P_(
            this.range,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion,
          );
        }
        getReversed() {
          return new P_(
            this.range,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1,
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.range = this.range.toJSON();
          return t;
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new B('attribute-operation-range-not-flat', this);
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (
              this.oldValue !== null &&
              !S_(t.getAttribute(this.key), this.oldValue)
            ) {
              throw new B('attribute-operation-wrong-old-value', this, {
                item: t,
                key: this.key,
                value: this.oldValue,
              });
            }
            if (
              this.oldValue === null &&
              this.newValue !== null &&
              t.hasAttribute(this.key)
            ) {
              throw new B('attribute-operation-attribute-exists', this, {
                node: t,
                key: this.key,
              });
            }
          }
        }
        _execute() {
          if (!S_(this.oldValue, this.newValue)) {
            b_(this.range, this.key, this.newValue);
          }
        }
        static get className() {
          return 'AttributeOperation';
        }
        static fromJSON(t, e) {
          return new P_(
            Nk.fromJSON(t.range, e),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion,
          );
        }
      }
      class B_ extends p_ {
        get type() {
          return 'noop';
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new B_(this.baseVersion);
        }
        getReversed() {
          return new B_(this.baseVersion + 1);
        }
        _execute() {}
        static get className() {
          return 'NoOperation';
        }
      }
      class R_ extends p_ {
        constructor(t, e, n, o) {
          super(o);
          this.position = t;
          this.position.stickiness = 'toNext';
          this.oldName = e;
          this.newName = n;
        }
        get type() {
          return 'rename';
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new R_(
            this.position.clone(),
            this.oldName,
            this.newName,
            this.baseVersion,
          );
        }
        getReversed() {
          return new R_(
            this.position.clone(),
            this.newName,
            this.oldName,
            this.baseVersion + 1,
          );
        }
        _validate() {
          const t = this.position.nodeAfter;
          if (!(t instanceof Tk)) {
            throw new B('rename-operation-wrong-position', this);
          } else if (t.name !== this.oldName) {
            throw new B('rename-operation-wrong-name', this);
          }
        }
        _execute() {
          const t = this.position.nodeAfter;
          t.name = this.newName;
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          return t;
        }
        static get className() {
          return 'RenameOperation';
        }
        static fromJSON(t, e) {
          return new R_(
            Rk.fromJSON(t.position, e),
            t.oldName,
            t.newName,
            t.baseVersion,
          );
        }
      }
      class O_ extends p_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.root = t;
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = o === undefined ? null : o;
        }
        get type() {
          if (this.oldValue === null) {
            return 'addRootAttribute';
          } else if (this.newValue === null) {
            return 'removeRootAttribute';
          } else {
            return 'changeRootAttribute';
          }
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new O_(
            this.root,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion,
          );
        }
        getReversed() {
          return new O_(
            this.root,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1,
          );
        }
        _validate() {
          if (this.root != this.root.root || this.root.is('documentFragment')) {
            throw new B('rootattribute-operation-not-a-root', this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue !== null &&
            this.root.getAttribute(this.key) !== this.oldValue
          ) {
            throw new B('rootattribute-operation-wrong-old-value', this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new B('rootattribute-operation-attribute-exists', this, {
              root: this.root,
              key: this.key,
            });
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue);
          } else {
            this.root._removeAttribute(this.key);
          }
        }
        toJSON() {
          const t = super.toJSON();
          t.root = this.root.toJSON();
          return t;
        }
        static get className() {
          return 'RootAttributeOperation';
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new B('rootattribute-operation-fromjson-no-root', this, {
              rootName: t.root,
            });
          }
          return new O_(
            e.getRoot(t.root),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion,
          );
        }
      }
      class I_ extends p_ {
        constructor(t, e, n, o, i) {
          super(i);
          this.rootName = t;
          this.elementName = e;
          this.isAdd = n;
          this._document = o;
          if (!this._document.getRoot(this.rootName)) {
            const t = this._document.createRoot(
              this.elementName,
              this.rootName,
            );
            t._isAttached = false;
          }
        }
        get type() {
          return this.isAdd ? 'addRoot' : 'detachRoot';
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new I_(
            this.rootName,
            this.elementName,
            this.isAdd,
            this._document,
            this.baseVersion,
          );
        }
        getReversed() {
          return new I_(
            this.rootName,
            this.elementName,
            !this.isAdd,
            this._document,
            this.baseVersion + 1,
          );
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const t = super.toJSON();
          delete t._document;
          return t;
        }
        static get className() {
          return 'RootOperation';
        }
        static fromJSON(t, e) {
          return new I_(t.rootName, t.elementName, t.isAdd, e, t.baseVersion);
        }
      }
      const M_ = {};
      M_[P_.className] = P_;
      M_[y_.className] = y_;
      M_[D_.className] = D_;
      M_[C_.className] = C_;
      M_[B_.className] = B_;
      M_[p_.className] = p_;
      M_[R_.className] = R_;
      M_[O_.className] = O_;
      M_[I_.className] = I_;
      M_[x_.className] = x_;
      M_[E_.className] = E_;
      class V_ {
        static fromJSON(t, e) {
          return M_[t.__className].fromJSON(t, e);
        }
      }
      const z_ = new Map();
      function F_(t, e, n) {
        let o = z_.get(t);
        if (!o) {
          o = new Map();
          z_.set(t, o);
        }
        o.set(e, n);
      }
      function N_(t, e) {
        const n = z_.get(t);
        if (n && n.has(e)) {
          return n.get(e);
        }
        return L_;
      }
      function L_(t) {
        return [t];
      }
      function H_(t, e, n = {}) {
        const o = N_(t.constructor, e.constructor);
        try {
          t = t.clone();
          return o(t, e, n);
        } catch (t) {
          throw t;
        }
      }
      function j_(t, e, n) {
        t = t.slice();
        e = e.slice();
        const o = new q_(n.document, n.useRelations, n.forceWeakRemove);
        o.setOriginalOperations(t);
        o.setOriginalOperations(e);
        const i = o.originalOperations;
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: i };
        }
        const r = new WeakMap();
        for (const e of t) {
          r.set(e, 0);
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        };
        let a = 0;
        while (a < t.length) {
          const n = t[a];
          const i = r.get(n);
          if (i == e.length) {
            a++;
            continue;
          }
          const s = e[i];
          const c = H_(n, s, o.getContext(n, s, true));
          const l = H_(s, n, o.getContext(s, n, false));
          o.updateRelation(n, s);
          o.setOriginalOperations(c, n);
          o.setOriginalOperations(l, s);
          for (const t of c) {
            r.set(t, i + l.length);
          }
          t.splice(a, 1, ...c);
          e.splice(i, 1, ...l);
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount;
          const o = e.length - s.originalOperationsBCount;
          W_(t, o - n);
          W_(e, n - o);
        }
        $_(t, s.nextBaseVersionB);
        $_(e, s.nextBaseVersionA);
        return { operationsA: t, operationsB: e, originalOperations: i };
      }
      class q_ {
        constructor(t, e, n = false) {
          this.originalOperations = new Map();
          this._history = t.history;
          this._useRelations = e;
          this._forceWeakRemove = !!n;
          this._relations = new Map();
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null;
          for (const e of t) {
            this.originalOperations.set(e, n || e);
          }
        }
        updateRelation(t, e) {
          if (t instanceof C_) {
            if (e instanceof E_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
              ) {
                this._setRelation(t, e, 'insertAtSource');
              } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                this._setRelation(t, e, 'insertBetween');
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, 'moveTargetAfter');
              }
            } else if (e instanceof C_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, 'insertBefore');
              } else {
                this._setRelation(t, e, 'insertAfter');
              }
            }
          } else if (t instanceof x_) {
            if (e instanceof E_) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, 'splitBefore');
              }
            } else if (e instanceof C_) {
              if (
                t.splitPosition.isEqual(e.sourcePosition) ||
                t.splitPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, 'splitBefore');
              } else {
                const n = Nk._createFromPositionAndShift(
                  e.sourcePosition,
                  e.howMany,
                );
                if (
                  t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  n.containsPosition(t.splitPosition)
                ) {
                  const o = n.end.offset - t.splitPosition.offset;
                  const i = t.splitPosition.offset - n.start.offset;
                  this._setRelation(t, e, { howMany: o, offset: i });
                }
              }
            }
          } else if (t instanceof E_) {
            if (e instanceof E_) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeTargetNotMoved');
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, 'mergeSourceNotMoved');
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, 'mergeSameElement');
              }
            } else if (e instanceof x_) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, 'splitAtSource');
              }
            }
          } else if (t instanceof D_) {
            const n = t.newRange;
            if (!n) {
              return;
            }
            if (e instanceof C_) {
              const o = Nk._createFromPositionAndShift(
                e.sourcePosition,
                e.howMany,
              );
              const i = o.containsPosition(n.start) || o.start.isEqual(n.start);
              const r = o.containsPosition(n.end) || o.end.isEqual(n.end);
              if ((i || r) && !o.containsRange(n)) {
                this._setRelation(t, e, {
                  side: i ? 'left' : 'right',
                  path: i ? n.start.path.slice() : n.end.path.slice(),
                });
              }
            } else if (e instanceof E_) {
              const o = n.start.isEqual(e.targetPosition);
              const i = n.start.isEqual(e.deletionPosition);
              const r = n.end.isEqual(e.deletionPosition);
              const s = n.end.isEqual(e.sourcePosition);
              if (o || i || r || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: o,
                  wasStartBeforeMergedElement: i,
                  wasEndBeforeMergedElement: r,
                  wasInRightElement: s,
                });
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          };
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t);
          return e.wasUndone || this._history.isUndoneOperation(e);
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e);
          const o = this._history.getUndoneOperation(n);
          if (!o) {
            return null;
          }
          const i = this.originalOperations.get(t);
          const r = this._relations.get(i);
          if (r) {
            return r.get(o) || null;
          }
          return null;
        }
        _setRelation(t, e, n) {
          const o = this.originalOperations.get(t);
          const i = this.originalOperations.get(e);
          let r = this._relations.get(o);
          if (!r) {
            r = new Map();
            this._relations.set(o, r);
          }
          r.set(i, n);
        }
      }
      function $_(t, e) {
        for (const n of t) {
          n.baseVersion = e++;
        }
      }
      function W_(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new B_(0));
        }
      }
      F_(P_, P_, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const o = t.range
            .getDifference(e.range)
            .map(e => new P_(e, t.key, t.oldValue, t.newValue, 0));
          const i = t.range.getIntersection(e.range);
          if (i) {
            if (n.aIsStrong) {
              o.push(new P_(i, e.key, e.newValue, t.newValue, 0));
            }
          }
          if (o.length == 0) {
            return [new B_(0)];
          }
          return o;
        } else {
          return [t];
        }
      });
      F_(P_, y_, (t, e) => {
        if (
          t.range.start.hasSameParentAs(e.position) &&
          t.range.containsPosition(e.position)
        ) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes,
          );
          const o = n.map(
            e => new P_(e, t.key, t.oldValue, t.newValue, t.baseVersion),
          );
          if (e.shouldReceiveAttributes) {
            const n = G_(e, t.key, t.oldValue);
            if (n) {
              o.unshift(n);
            }
          }
          return o;
        }
        t.range = t.range._getTransformedByInsertion(
          e.position,
          e.howMany,
          false,
        )[0];
        return [t];
      });
      function G_(t, e, n) {
        const o = t.nodes;
        const i = o.getNode(0).getAttribute(e);
        if (i == n) {
          return null;
        }
        const r = new Nk(t.position, t.position.getShiftedBy(t.howMany));
        return new P_(r, e, i, n, 0);
      }
      F_(P_, E_, (t, e) => {
        const n = [];
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(Nk._createFromPositionAndShift(e.graveyardPosition, 1));
          }
        }
        const o = t.range._getTransformedByMergeOperation(e);
        if (!o.isCollapsed) {
          n.push(o);
        }
        return n.map(
          e => new P_(e, t.key, t.oldValue, t.newValue, t.baseVersion),
        );
      });
      F_(P_, C_, (t, e) => {
        const n = K_(t.range, e);
        return n.map(
          e => new P_(e, t.key, t.oldValue, t.newValue, t.baseVersion),
        );
      });
      function K_(t, e) {
        const n = Nk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let o = null;
        let i = [];
        if (n.containsRange(t, true)) {
          o = t;
        } else if (t.start.hasSameParentAs(n.start)) {
          i = t.getDifference(n);
          o = t.getIntersection(n);
        } else {
          i = [t];
        }
        const r = [];
        for (let t of i) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n = e.getMovedRangeStart();
          const o = t.start.hasSameParentAs(n);
          const i = t._getTransformedByInsertion(n, e.howMany, o);
          r.push(...i);
        }
        if (o) {
          r.push(
            o._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany,
              false,
            )[0],
          );
        }
        return r;
      }
      F_(P_, x_, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++;
          }
          return [t];
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          n.range = new Nk(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition),
          );
          t.range.end = e.splitPosition.clone();
          t.range.end.stickiness = 'toPrevious';
          return [t, n];
        }
        t.range = t.range._getTransformedBySplitOperation(e);
        return [t];
      });
      F_(y_, P_, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const o = G_(t, e.key, e.newValue);
          if (o) {
            n.push(o);
          }
        }
        return n;
      });
      F_(y_, y_, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t];
        }
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      F_(y_, C_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      F_(y_, x_, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      F_(y_, E_, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      F_(D_, y_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0];
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0];
        }
        return [t];
      });
      F_(D_, D_, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null;
          } else {
            return [new B_(0)];
          }
        }
        return [t];
      });
      F_(D_, E_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e);
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      F_(D_, C_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = Nk._createFromRanges(
            t.oldRange._getTransformedByMoveOperation(e),
          );
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = Nk._createFromRanges(
              t.newRange._getTransformedByMoveOperation(e),
            );
            if (
              n.abRelation.side == 'left' &&
              e.targetPosition.isEqual(t.newRange.start)
            ) {
              t.newRange.end = o.end;
              t.newRange.start.path = n.abRelation.path;
              return [t];
            } else if (
              n.abRelation.side == 'right' &&
              e.targetPosition.isEqual(t.newRange.end)
            ) {
              t.newRange.start = o.start;
              t.newRange.end.path = n.abRelation.path;
              return [t];
            }
          }
          t.newRange = Nk._createFromRanges(
            t.newRange._getTransformedByMoveOperation(e),
          );
        }
        return [t];
      });
      F_(D_, x_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e);
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = t.newRange._getTransformedBySplitOperation(e);
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = Rk._createAt(e.insertionPosition);
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = Rk._createAt(e.moveTargetPosition);
            }
            if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasInRightElement
            ) {
              t.newRange.end = Rk._createAt(e.moveTargetPosition);
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = Rk._createAt(e.insertionPosition);
            } else {
              t.newRange.end = o.end;
            }
            return [t];
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      });
      F_(E_, y_, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      F_(E_, E_, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new B_(0)];
          } else {
            const n = e.graveyardPosition.path.slice();
            n.push(0);
            t.sourcePosition = new Rk(e.graveyardPosition.root, n);
            t.howMany = 0;
            return [t];
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != 'splitAtSource'
        ) {
          const o = t.targetPosition.root.rootName == '$graveyard';
          const i = e.targetPosition.root.rootName == '$graveyard';
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e);
            const o = t.targetPosition._getTransformedByMergeOperation(e);
            return [new C_(n, t.howMany, o, 0)];
          } else {
            return [new B_(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      F_(E_, C_, (t, e, n) => {
        const o = Nk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (e.type == 'remove' && !n.bWasUndone && !n.forceWeakRemove) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            o.containsPosition(t.sourcePosition)
          ) {
            return [new B_(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        return [t];
      });
      F_(E_, x_, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(
            e.graveyardPosition,
            1,
          );
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany;
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const o = e.howMany != 0;
          const i =
            e.graveyardPosition &&
            t.deletionPosition.isEqual(e.graveyardPosition);
          if (o || i || n.abRelation == 'mergeTargetNotMoved') {
            t.sourcePosition =
              t.sourcePosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == 'mergeSourceNotMoved') {
            t.howMany = 0;
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
          if (
            n.abRelation == 'mergeSameElement' ||
            t.sourcePosition.offset > 0
          ) {
            t.sourcePosition = e.moveTargetPosition.clone();
            t.targetPosition =
              t.targetPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset;
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
        return [t];
      });
      F_(C_, y_, (t, e) => {
        const n = Nk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const o = n._getTransformedByInsertOperation(e, false)[0];
        t.sourcePosition = o.start;
        t.howMany = o.end.offset - o.start.offset;
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition =
            t.targetPosition._getTransformedByInsertOperation(e);
        }
        return [t];
      });
      F_(C_, C_, (t, e, n) => {
        const o = Nk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const i = Nk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r = n.aIsStrong;
        let s = !n.aIsStrong;
        if (n.abRelation == 'insertBefore' || n.baRelation == 'insertAfter') {
          s = true;
        } else if (
          n.abRelation == 'insertAfter' ||
          n.baRelation == 'insertBefore'
        ) {
          s = false;
        }
        let a;
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany,
          );
        } else {
          a = t.targetPosition._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany,
          );
        }
        if (U_(t, e) && U_(e, t)) {
          return [e.getReversed()];
        }
        const c = o.containsPosition(e.targetPosition);
        if (c && o.containsRange(i, true)) {
          o.start = o.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany,
          );
          o.end = o.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany,
          );
          return Z_([o], a);
        }
        const l = i.containsPosition(t.targetPosition);
        if (l && i.containsRange(o, true)) {
          o.start = o.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart(),
          );
          o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          return Z_([o], a);
        }
        const d = Ct(
          t.sourcePosition.getParentPath(),
          e.sourcePosition.getParentPath(),
        );
        if (d == 'prefix' || d == 'extension') {
          o.start = o.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany,
          );
          o.end = o.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany,
          );
          return Z_([o], a);
        }
        if (
          t.type == 'remove' &&
          e.type != 'remove' &&
          !n.aWasUndone &&
          !n.forceWeakRemove
        ) {
          r = true;
        } else if (
          t.type != 'remove' &&
          e.type == 'remove' &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          r = false;
        }
        const h = [];
        const u = o.getDifference(i);
        for (const t of u) {
          t.start = t.start._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany,
          );
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n =
            Ct(
              t.start.getParentPath(),
              e.getMovedRangeStart().getParentPath(),
            ) == 'same';
          const o = t._getTransformedByInsertion(
            e.getMovedRangeStart(),
            e.howMany,
            n,
          );
          h.push(...o);
        }
        const f = o.getIntersection(i);
        if (f !== null && r) {
          f.start = f.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart(),
          );
          f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          if (h.length === 0) {
            h.push(f);
          } else if (h.length == 1) {
            if (i.start.isBefore(o.start) || i.start.isEqual(o.start)) {
              h.unshift(f);
            } else {
              h.push(f);
            }
          } else {
            h.splice(1, 0, f);
          }
        }
        if (h.length === 0) {
          return [new B_(t.baseVersion)];
        }
        return Z_(h, a);
      });
      F_(C_, x_, (t, e, n) => {
        let o = t.targetPosition.clone();
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == 'moveTargetAfter'
        ) {
          o = t.targetPosition._getTransformedBySplitOperation(e);
        }
        const i = Nk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (i.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++;
          }
          t.targetPosition = o;
          return [t];
        }
        if (
          i.start.hasSameParentAs(e.splitPosition) &&
          i.containsPosition(e.splitPosition)
        ) {
          let t = new Nk(e.splitPosition, i.end);
          t = t._getTransformedBySplitOperation(e);
          const n = [new Nk(i.start, e.splitPosition), t];
          return Z_(n, o);
        }
        if (
          t.targetPosition.isEqual(e.splitPosition) &&
          n.abRelation == 'insertAtSource'
        ) {
          o = e.moveTargetPosition;
        }
        if (
          t.targetPosition.isEqual(e.insertionPosition) &&
          n.abRelation == 'insertBetween'
        ) {
          o = t.targetPosition;
        }
        const r = i._getTransformedBySplitOperation(e);
        const s = [r];
        if (e.graveyardPosition) {
          const o =
            i.start.isEqual(e.graveyardPosition) ||
            i.containsPosition(e.graveyardPosition);
          if (t.howMany > 1 && o && !n.aWasUndone) {
            s.push(Nk._createFromPositionAndShift(e.insertionPosition, 1));
          }
        }
        return Z_(s, o);
      });
      F_(C_, E_, (t, e, n) => {
        const o = Nk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          o.containsPosition(e.sourcePosition)
        ) {
          if (t.type == 'remove' && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = [];
              let o = e.graveyardPosition.clone();
              let i = e.targetPosition._getTransformedByMergeOperation(e);
              if (t.howMany > 1) {
                n.push(
                  new C_(t.sourcePosition, t.howMany - 1, t.targetPosition, 0),
                );
                o = o._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1,
                );
                i = i._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1,
                );
              }
              const r = e.deletionPosition._getCombined(
                t.sourcePosition,
                t.targetPosition,
              );
              const s = new C_(o, 1, r, 0);
              const a = s.getMovedRangeStart().path.slice();
              a.push(0);
              const c = new Rk(s.targetPosition.root, a);
              i = i._getTransformedByMove(o, r, 1);
              const l = new C_(i, e.howMany, c, 0);
              n.push(s);
              n.push(l);
              return n;
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new B_(0)];
              } else {
                t.sourcePosition = e.graveyardPosition.clone();
                t.targetPosition =
                  t.targetPosition._getTransformedByMergeOperation(e);
                return [t];
              }
            }
          }
        }
        const i = Nk._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const r = i._getTransformedByMergeOperation(e);
        t.sourcePosition = r.start;
        t.howMany = r.end.offset - r.start.offset;
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        return [t];
      });
      F_(R_, y_, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      F_(R_, E_, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone();
          t.position.stickiness = 'toNext';
          return [t];
        }
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      F_(R_, C_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      F_(R_, R_, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName;
          } else {
            return [new B_(0)];
          }
        }
        return [t];
      });
      F_(R_, x_, (t, e) => {
        const n = t.position.path;
        const o = e.splitPosition.getParentPath();
        if (Ct(n, o) == 'same' && !e.graveyardPosition) {
          const e = new R_(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
          return [t, e];
        }
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      F_(O_, O_, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new B_(0)];
          } else {
            t.oldValue = e.newValue;
          }
        }
        return [t];
      });
      F_(I_, I_, (t, e) => {
        if (t.rootName === e.rootName && t.isAdd === e.isAdd) {
          return [new B_(0)];
        }
        return [t];
      });
      F_(x_, y_, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
        t.insertionPosition =
          t.insertionPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      F_(x_, E_, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const o = new Rk(e.graveyardPosition.root, n);
          const i = x_.getInsertionPosition(
            new Rk(e.graveyardPosition.root, n),
          );
          const r = new x_(o, 0, i, null, 0);
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
          t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
          t.graveyardPosition = r.insertionPosition.clone();
          t.graveyardPosition.stickiness = 'toNext';
          return [r, t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--;
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
        t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      F_(x_, C_, (t, e, n) => {
        const o = Nk._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (t.graveyardPosition) {
          const i =
            o.start.isEqual(t.graveyardPosition) ||
            o.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && i) {
            const n = t.splitPosition._getTransformedByMoveOperation(e);
            const o = t.graveyardPosition._getTransformedByMoveOperation(e);
            const i = o.path.slice();
            i.push(0);
            const r = new Rk(o.root, i);
            const s = new C_(n, t.howMany, r, 0);
            return [s];
          }
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const i = t.splitPosition.isEqual(e.targetPosition);
        if (
          i &&
          (n.baRelation == 'insertAtSource' || n.abRelation == 'splitBefore')
        ) {
          t.howMany += e.howMany;
          t.splitPosition = t.splitPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany,
          );
          t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (i && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: o } = n.abRelation;
          t.howMany += e;
          t.splitPosition = t.splitPosition.getShiftedBy(o);
          return [t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          o.containsPosition(t.splitPosition)
        ) {
          const n =
            e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
          t.howMany -= n;
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
          t.splitPosition = e.sourcePosition.clone();
          t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany;
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
        }
        t.splitPosition.stickiness = 'toNone';
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
        t.splitPosition.stickiness = 'toNext';
        if (t.graveyardPosition) {
          t.insertionPosition =
            t.insertionPosition._getTransformedByMoveOperation(e);
        } else {
          t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
        }
        return [t];
      });
      F_(x_, x_, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new B_(0)];
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new B_(0)];
          }
          if (n.abRelation == 'splitBefore') {
            t.howMany = 0;
            t.graveyardPosition =
              t.graveyardPosition._getTransformedBySplitOperation(e);
            return [t];
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const o = t.splitPosition.root.rootName == '$graveyard';
          const i = e.splitPosition.root.rootName == '$graveyard';
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = [];
            if (e.howMany) {
              n.push(
                new C_(e.moveTargetPosition, e.howMany, e.splitPosition, 0),
              );
            }
            if (t.howMany) {
              n.push(
                new C_(t.splitPosition, t.howMany, t.moveTargetPosition, 0),
              );
            }
            return n;
          } else {
            return [new B_(0)];
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition =
            t.graveyardPosition._getTransformedBySplitOperation(e);
        }
        if (
          t.splitPosition.isEqual(e.insertionPosition) &&
          n.abRelation == 'splitBefore'
        ) {
          t.howMany++;
          return [t];
        }
        if (
          e.splitPosition.isEqual(t.insertionPosition) &&
          n.baRelation == 'splitBefore'
        ) {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const o = new Rk(e.insertionPosition.root, n);
          const i = new C_(t.insertionPosition, 1, o, 0);
          return [t, i];
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
        t.insertionPosition = x_.getInsertionPosition(t.splitPosition);
        return [t];
      });
      function U_(t, e) {
        return (
          t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany,
          ) === null
        );
      }
      function Z_(t, e) {
        const n = [];
        for (let o = 0; o < t.length; o++) {
          const i = t[o];
          const r = new C_(i.start, i.end.offset - i.start.offset, e, 0);
          n.push(r);
          for (let e = o + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(
              r.sourcePosition,
              r.targetPosition,
              r.howMany,
            )[0];
          }
          e = e._getTransformedByMove(
            r.sourcePosition,
            r.targetPosition,
            r.howMany,
          );
        }
        return n;
      }
      class J_ extends $(Rk) {
        constructor(t, e, n = 'toNone') {
          super(t, e, n);
          if (!this.root.is('rootElement')) {
            throw new B('model-liveposition-root-not-rootelement', t);
          }
          Y_.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new Rk(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness);
        }
      }
      J_.prototype.is = function (t) {
        return (
          t === 'livePosition' ||
          t === 'model:livePosition' ||
          t == 'position' ||
          t === 'model:position'
        );
      };
      function Y_() {
        this.listenTo(
          this.root.document.model,
          'applyOperation',
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            Q_.call(this, n);
          },
          { priority: 'low' },
        );
      }
      function Q_(t) {
        const e = this.getTransformedByOperation(t);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path;
          this.root = e.root;
          this.fire('change', t);
        }
      }
      class X_ {
        constructor(t = {}) {
          if (typeof t === 'string') {
            t = t === 'transparent' ? { isUndoable: false } : {};
            R('batch-constructor-deprecated-string-type');
          }
          const {
            isUndoable: e = true,
            isLocal: n = true,
            isUndo: o = false,
            isTyping: i = false,
          } = t;
          this.operations = [];
          this.isUndoable = e;
          this.isLocal = n;
          this.isUndo = o;
          this.isTyping = i;
        }
        get type() {
          R('batch-type-deprecated');
          return 'default';
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion;
            }
          }
          return null;
        }
        addOperation(t) {
          t.batch = this;
          this.operations.push(t);
          return t;
        }
      }
      class tv {
        constructor(t) {
          this._changesInElement = new Map();
          this._elementSnapshots = new Map();
          this._changedMarkers = new Map();
          this._changedRoots = new Map();
          this._changeCount = 0;
          this._cachedChanges = null;
          this._cachedChangesWithGraveyard = null;
          this._refreshedItems = new Set();
          this._markerCollection = t;
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 &&
            this._changedMarkers.size == 0 &&
            this._changedRoots.size == 0
          );
        }
        bufferOperation(t) {
          const e = t;
          switch (e.type) {
            case 'insert': {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markInsert(
                e.position.parent,
                e.position.offset,
                e.nodes.maxOffset,
              );
              break;
            }
            case 'addAttribute':
            case 'removeAttribute':
            case 'changeAttribute': {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue;
                }
                this._markAttribute(t);
              }
              break;
            }
            case 'remove':
            case 'move':
            case 'reinsert': {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition
                  .getShiftedBy(e.howMany)
                  .isEqual(e.targetPosition)
              ) {
                return;
              }
              const t = this._isInInsertedElement(e.sourcePosition.parent);
              const n = this._isInInsertedElement(e.targetPosition.parent);
              if (!t) {
                this._markRemove(
                  e.sourcePosition.parent,
                  e.sourcePosition.offset,
                  e.howMany,
                );
              }
              if (!n) {
                this._markInsert(
                  e.targetPosition.parent,
                  e.getMovedRangeStart().offset,
                  e.howMany,
                );
              }
              break;
            }
            case 'rename': {
              if (this._isInInsertedElement(e.position.parent)) {
                return;
              }
              this._markRemove(e.position.parent, e.position.offset, 1);
              this._markInsert(e.position.parent, e.position.offset, 1);
              const t = Nk._createFromPositionAndShift(e.position, 1);
              for (const e of this._markerCollection.getMarkersIntersectingRange(
                t,
              )) {
                const t = e.getData();
                this.bufferMarkerChange(e.name, t, t);
              }
              break;
            }
            case 'split': {
              const t = e.splitPosition.parent;
              if (!this._isInInsertedElement(t)) {
                this._markRemove(t, e.splitPosition.offset, e.howMany);
              }
              if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                this._markInsert(
                  e.insertionPosition.parent,
                  e.insertionPosition.offset,
                  1,
                );
              }
              if (e.graveyardPosition) {
                this._markRemove(
                  e.graveyardPosition.parent,
                  e.graveyardPosition.offset,
                  1,
                );
              }
              break;
            }
            case 'merge': {
              const t = e.sourcePosition.parent;
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1);
              }
              const n = e.graveyardPosition.parent;
              this._markInsert(n, e.graveyardPosition.offset, 1);
              const o = e.targetPosition.parent;
              if (!this._isInInsertedElement(o)) {
                this._markInsert(o, e.targetPosition.offset, t.maxOffset);
              }
              break;
            }
            case 'detachRoot':
            case 'addRoot': {
              const t = e.affectedSelectable;
              if (!t._isLoaded) {
                return;
              }
              if (t.isAttached() == e.isAdd) {
                return;
              }
              this._bufferRootStateChange(e.rootName, e.isAdd);
              break;
            }
            case 'addRootAttribute':
            case 'removeRootAttribute':
            case 'changeRootAttribute': {
              if (!e.root._isLoaded) {
                return;
              }
              const t = e.root.rootName;
              this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t, e, n) {
          if (
            e.range &&
            e.range.root.is('rootElement') &&
            !e.range.root._isLoaded
          ) {
            e.range = null;
          }
          if (
            n.range &&
            n.range.root.is('rootElement') &&
            !n.range.root._isLoaded
          ) {
            n.range = null;
          }
          let o = this._changedMarkers.get(t);
          if (!o) {
            o = { newMarkerData: n, oldMarkerData: e };
            this._changedMarkers.set(t, o);
          } else {
            o.newMarkerData = n;
          }
          if (o.oldMarkerData.range == null && n.range == null) {
            this._changedMarkers.delete(t);
          }
        }
        getMarkersToRemove() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range });
            }
          }
          return t;
        }
        getMarkersToAdd() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range });
            }
          }
          return t;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: {
              oldRange: e.oldMarkerData.range,
              newRange: e.newMarkerData.range,
            },
          }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true;
          }
          if (this._changedRoots.size > 0) {
            return true;
          }
          for (const {
            newMarkerData: t,
            oldMarkerData: e,
          } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true;
            }
            if (t.affectsData) {
              const n = t.range && !e.range;
              const o = !t.range && e.range;
              const i = t.range && e.range && !t.range.isEqual(e.range);
              if (n || o || i) {
                return true;
              }
            }
          }
          return false;
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice();
            } else {
              return this._cachedChanges.slice();
            }
          }
          let e = [];
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == 'remove' ? -1 : 1;
                }
                return 0;
              }
              return t.offset < e.offset ? -1 : 1;
            });
            const o = this._elementSnapshots.get(t);
            const i = ev(t.getChildren());
            const r = nv(o.length, n);
            let s = 0;
            let a = 0;
            for (const n of r) {
              if (n === 'i') {
                e.push(this._getInsertDiff(t, s, i[s]));
                s++;
              } else if (n === 'r') {
                e.push(this._getRemoveDiff(t, s, o[a]));
                a++;
              } else if (n === 'a') {
                const n = i[s].attributes;
                const r = o[a].attributes;
                let c;
                if (i[s].name == '$text') {
                  c = new Nk(Rk._createAt(t, s), Rk._createAt(t, s + 1));
                } else {
                  const e = t.offsetToIndex(s);
                  c = new Nk(
                    Rk._createAt(t, s),
                    Rk._createAt(t.getChild(e), 0),
                  );
                }
                e.push(...this._getAttributesDiff(c, r, n));
                s++;
                a++;
              } else {
                s++;
                a++;
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName
                ? -1
                : 1;
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount;
            }
            return t.position.isBefore(e.position) ? -1 : 1;
          });
          for (let t = 1, n = 0; t < e.length; t++) {
            const o = e[n];
            const i = e[t];
            const r =
              o.type == 'remove' &&
              i.type == 'remove' &&
              o.name == '$text' &&
              i.name == '$text' &&
              o.position.isEqual(i.position);
            const s =
              o.type == 'insert' &&
              i.type == 'insert' &&
              o.name == '$text' &&
              i.name == '$text' &&
              o.position.parent == i.position.parent &&
              o.position.offset + o.length == i.position.offset;
            const a =
              o.type == 'attribute' &&
              i.type == 'attribute' &&
              o.position.parent == i.position.parent &&
              o.range.isFlat &&
              i.range.isFlat &&
              o.position.offset + o.length == i.position.offset &&
              o.attributeKey == i.attributeKey &&
              o.attributeOldValue == i.attributeOldValue &&
              o.attributeNewValue == i.attributeNewValue;
            if (r || s || a) {
              o.length++;
              if (a) {
                o.range.end = o.range.end.getShiftedBy(1);
              }
              e[t] = null;
            } else {
              n = t;
            }
          }
          e = e.filter(t => t);
          for (const t of e) {
            delete t.changeCount;
            if (t.type == 'attribute') {
              delete t.position;
              delete t.length;
            }
          }
          this._changeCount = 0;
          this._cachedChangesWithGraveyard = e;
          this._cachedChanges = e.filter(ov);
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map(t => {
            const e = { ...t };
            if (e.state !== undefined) {
              delete e.attributes;
            }
            return e;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear();
          this._elementSnapshots.clear();
          this._changedMarkers.clear();
          this._changedRoots.clear();
          this._refreshedItems = new Set();
          this._cachedChanges = null;
        }
        _bufferRootStateChange(t, e) {
          if (!this._changedRoots.has(t)) {
            this._changedRoots.set(t, {
              name: t,
              state: e ? 'attached' : 'detached',
            });
            return;
          }
          const n = this._changedRoots.get(t);
          if (n.state !== undefined) {
            delete n.state;
            if (n.attributes === undefined) {
              this._changedRoots.delete(t);
            }
          } else {
            n.state = e ? 'attached' : 'detached';
          }
        }
        _bufferRootAttributeChange(t, e, n, o) {
          const i = this._changedRoots.get(t) || { name: t };
          const r = i.attributes || {};
          if (r[e]) {
            const t = r[e];
            if (o === t.oldValue) {
              delete r[e];
            } else {
              t.newValue = o;
            }
          } else {
            r[e] = { oldValue: n, newValue: o };
          }
          if (Object.entries(r).length === 0) {
            delete i.attributes;
            if (i.state === undefined) {
              this._changedRoots.delete(t);
            }
          } else {
            i.attributes = r;
            this._changedRoots.set(t, i);
          }
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return;
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize);
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
          this._refreshedItems.add(t);
          const e = Nk._createOn(t);
          for (const t of this._markerCollection.getMarkersIntersectingRange(
            e,
          )) {
            const e = t.getData();
            this.bufferMarkerChange(t.name, e, e);
          }
          this._cachedChanges = null;
        }
        _bufferRootLoad(t) {
          if (!t.isAttached()) {
            return;
          }
          this._bufferRootStateChange(t.rootName, true);
          this._markInsert(t, 0, t.maxOffset);
          for (const e of t.getAttributeKeys()) {
            this._bufferRootAttributeChange(
              t.rootName,
              e,
              null,
              t.getAttribute(e),
            );
          }
          for (const e of this._markerCollection) {
            if (e.getRange().root == t) {
              const t = e.getData();
              this.bufferMarkerChange(e.name, { ...t, range: null }, t);
            }
          }
        }
        _markInsert(t, e, n) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return;
          }
          const o = {
            type: 'insert',
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, o);
        }
        _markRemove(t, e, n) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return;
          }
          const o = {
            type: 'remove',
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, o);
          this._removeAllNestedChanges(t, e, n);
        }
        _markAttribute(t) {
          if (t.root.is('rootElement') && !t.root._isLoaded) {
            return;
          }
          const e = {
            type: 'attribute',
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          };
          this._markChange(t.parent, e);
        }
        _markChange(t, e) {
          this._makeSnapshot(t);
          const n = this._getChangesForElement(t);
          this._handleChange(e, n);
          n.push(e);
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1);
              t--;
            }
          }
        }
        _getChangesForElement(t) {
          let e;
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t);
          } else {
            e = [];
            this._changesInElement.set(t, e);
          }
          return e;
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, ev(t.getChildren()));
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany;
          for (const n of e) {
            const o = t.offset + t.howMany;
            const i = n.offset + n.howMany;
            if (t.type == 'insert') {
              if (n.type == 'insert') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  n.howMany += t.nodesToHandle;
                  t.nodesToHandle = 0;
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset) {
                  n.offset += t.howMany;
                }
              }
              if (n.type == 'attribute') {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  const i = n.howMany;
                  n.howMany = t.offset - n.offset;
                  e.unshift({
                    type: 'attribute',
                    offset: o,
                    howMany: i - n.howMany,
                    count: this._changeCount++,
                  });
                }
              }
            }
            if (t.type == 'remove') {
              if (n.type == 'insert') {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (o <= i) {
                  if (t.offset < n.offset) {
                    const e = o - n.offset;
                    n.offset = t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  } else {
                    n.howMany -= t.nodesToHandle;
                    t.nodesToHandle = 0;
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany;
                    n.howMany = 0;
                  } else if (t.offset < i) {
                    const e = i - t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  }
                }
              }
              if (n.type == 'remove') {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany;
                  n.howMany = 0;
                }
              }
              if (n.type == 'attribute') {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  const e = o - n.offset;
                  n.offset = t.offset;
                  n.howMany -= e;
                } else if (t.offset < i) {
                  if (o <= i) {
                    const o = n.howMany;
                    n.howMany = t.offset - n.offset;
                    const i = o - n.howMany - t.nodesToHandle;
                    e.unshift({
                      type: 'attribute',
                      offset: t.offset,
                      howMany: i,
                      count: this._changeCount++,
                    });
                  } else {
                    n.howMany -= i - t.offset;
                  }
                }
              }
            }
            if (t.type == 'attribute') {
              if (n.type == 'insert') {
                if (t.offset < n.offset && o > n.offset) {
                  if (o > i) {
                    const t = {
                      type: 'attribute',
                      offset: i,
                      howMany: o - i,
                      count: this._changeCount++,
                    };
                    this._handleChange(t, e);
                    e.push(t);
                  }
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                } else if (t.offset >= n.offset && t.offset < i) {
                  if (o > i) {
                    t.nodesToHandle = o - i;
                    t.offset = i;
                  } else {
                    t.nodesToHandle = 0;
                  }
                }
              }
              if (n.type == 'remove') {
                if (t.offset < n.offset && o > n.offset) {
                  const i = {
                    type: 'attribute',
                    offset: n.offset,
                    howMany: o - n.offset,
                    count: this._changeCount++,
                  };
                  this._handleChange(i, e);
                  e.push(i);
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                }
              }
              if (n.type == 'attribute') {
                if (t.offset >= n.offset && o <= i) {
                  t.nodesToHandle = 0;
                  t.howMany = 0;
                  t.offset = 0;
                } else if (t.offset <= n.offset && o >= i) {
                  n.howMany = 0;
                }
              }
            }
          }
          t.howMany = t.nodesToHandle;
          delete t.nodesToHandle;
        }
        _getInsertDiff(t, e, n) {
          return {
            type: 'insert',
            position: Rk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: 'remove',
            position: Rk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getAttributesDiff(t, e, n) {
          const o = [];
          n = new Map(n);
          for (const [i, r] of e) {
            const e = n.has(i) ? n.get(i) : null;
            if (e !== r) {
              o.push({
                type: 'attribute',
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: i,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              });
            }
            n.delete(i);
          }
          for (const [e, i] of n) {
            o.push({
              type: 'attribute',
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: i,
              changeCount: this._changeCount++,
            });
          }
          return o;
        }
        _isInInsertedElement(t) {
          const e = t.parent;
          if (!e) {
            return false;
          }
          const n = this._changesInElement.get(e);
          const o = t.startOffset;
          if (n) {
            for (const t of n) {
              if (
                t.type == 'insert' &&
                o >= t.offset &&
                o < t.offset + t.howMany
              ) {
                return true;
              }
            }
          }
          return this._isInInsertedElement(e);
        }
        _removeAllNestedChanges(t, e, n) {
          const o = new Nk(Rk._createAt(t, e), Rk._createAt(t, e + n));
          for (const t of o.getItems({ shallow: true })) {
            if (t.is('element')) {
              this._elementSnapshots.delete(t);
              this._changesInElement.delete(t);
              this._removeAllNestedChanges(t, 0, t.maxOffset);
            }
          }
        }
      }
      function ev(t) {
        const e = [];
        for (const n of t) {
          if (n.is('$text')) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: '$text', attributes: new Map(n.getAttributes()) });
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
          }
        }
        return e;
      }
      function nv(t, e) {
        const n = [];
        let o = 0;
        let i = 0;
        for (const t of e) {
          if (t.offset > o) {
            for (let e = 0; e < t.offset - o; e++) {
              n.push('e');
            }
            i += t.offset - o;
          }
          if (t.type == 'insert') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('i');
            }
            o = t.offset + t.howMany;
          } else if (t.type == 'remove') {
            for (let e = 0; e < t.howMany; e++) {
              n.push('r');
            }
            o = t.offset;
            i += t.howMany;
          } else {
            n.push(...'a'.repeat(t.howMany).split(''));
            o = t.offset + t.howMany;
            i += t.howMany;
          }
        }
        if (i < t) {
          for (let e = 0; e < t - i - o; e++) {
            n.push('e');
          }
        }
        return n;
      }
      function ov(t) {
        const e = 'position' in t && t.position.root.rootName == '$graveyard';
        const n = 'range' in t && t.range.root.rootName == '$graveyard';
        return !e && !n;
      }
      class iv {
        constructor() {
          this._operations = [];
          this._undoPairs = new Map();
          this._undoneOperations = new Set();
          this._baseVersionToOperationIndex = new Map();
          this._version = 0;
          this._gaps = new Map();
        }
        get version() {
          return this._version;
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t);
          }
          this._version = t;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new B(
              'model-document-history-addoperation-incorrect-version',
              this,
              { operation: t, historyVersion: this.version },
            );
          }
          this._operations.push(t);
          this._version++;
          this._baseVersionToOperationIndex.set(
            t.baseVersion,
            this._operations.length - 1,
          );
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return [];
          }
          const n = this._operations[0];
          if (t === undefined) {
            t = n.baseVersion;
          }
          let o = e - 1;
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n;
            }
            if (o > e && o < n) {
              o = e - 1;
            }
          }
          if (o < n.baseVersion || t > this.lastOperation.baseVersion) {
            return [];
          }
          let i = this._baseVersionToOperationIndex.get(t);
          if (i === undefined) {
            i = 0;
          }
          let r = this._baseVersionToOperationIndex.get(o);
          if (r === undefined) {
            r = this._operations.length - 1;
          }
          return this._operations.slice(i, r + 1);
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t);
          if (e === undefined) {
            return;
          }
          return this._operations[e];
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t);
          this._undoneOperations.add(t);
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t);
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t);
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t);
        }
        reset() {
          this._version = 0;
          this._undoPairs = new Map();
          this._operations = [];
          this._undoneOperations = new Set();
          this._gaps = new Map();
          this._baseVersionToOperationIndex = new Map();
        }
      }
      class rv extends Tk {
        constructor(t, e, n = 'main') {
          super(e);
          this._isAttached = true;
          this._isLoaded = true;
          this._document = t;
          this.rootName = n;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      rv.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === 'rootElement' ||
            t === 'model:rootElement' ||
            t === 'element' ||
            t === 'model:element' ||
            t === 'node' ||
            t === 'model:node'
          );
        }
        return (
          e === this.name &&
          (t === 'rootElement' ||
            t === 'model:rootElement' ||
            t === 'element' ||
            t === 'model:element')
        );
      };
      const sv = '$graveyard';
      class av extends $() {
        constructor(t) {
          super();
          this.model = t;
          this.history = new iv();
          this.selection = new sb(this);
          this.roots = new dl({ idProperty: 'rootName' });
          this.differ = new tv(t.markers);
          this.isReadOnly = false;
          this._postFixers = new Set();
          this._hasSelectionChangedFromTheLastChangeBlock = false;
          this.createRoot('$root', sv);
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n);
              }
            },
            { priority: 'high' },
          );
          this.listenTo(
            t,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.history.addOperation(n);
              }
            },
            { priority: 'low' },
          );
          this.listenTo(this.selection, 'change', () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          });
          this.listenTo(t.markers, 'update', (t, e, n, o, i) => {
            const r = { ...e.getData(), range: o };
            this.differ.bufferMarkerChange(e.name, i, r);
            if (n === null) {
              e.on('change', (t, n) => {
                const o = e.getData();
                this.differ.bufferMarkerChange(e.name, { ...o, range: n }, o);
              });
            }
          });
          this.registerPostFixer(t => {
            let e = false;
            for (const n of this.roots) {
              if (!n.isAttached() && !n.isEmpty) {
                t.remove(t.createRangeIn(n));
                e = true;
              }
            }
            for (const n of this.model.markers) {
              if (!n.getRange().root.isAttached()) {
                t.removeMarker(n);
                e = true;
              }
            }
            return e;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(t) {
          this.history.version = t;
        }
        get graveyard() {
          return this.getRoot(sv);
        }
        createRoot(t = '$root', e = 'main') {
          if (this.roots.get(e)) {
            throw new B('model-document-createroot-name-exists', this, {
              name: e,
            });
          }
          const n = new rv(this, t, e);
          this.roots.add(n);
          return n;
        }
        destroy() {
          this.selection.destroy();
          this.stopListening();
        }
        getRoot(t = 'main') {
          return this.roots.get(t);
        }
        getRootNames(t = false) {
          return this.getRoots(t).map(t => t.rootName);
        }
        getRoots(t = false) {
          return this.roots.filter(
            e => e != this.graveyard && (t || e.isAttached()) && e._isLoaded,
          );
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        toJSON() {
          const t = eu(this);
          t.selection = '[engine.model.DocumentSelection]';
          t.model = '[engine.model.Model]';
          return t;
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t);
            this.selection.refresh();
            if (this.differ.hasDataChanges()) {
              this.fire('change:data', t.batch);
            } else {
              this.fire('change', t.batch);
            }
            this.selection.refresh();
            this.differ.reset();
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return (
            !this.differ.isEmpty ||
            this._hasSelectionChangedFromTheLastChangeBlock
          );
        }
        _getDefaultRoot() {
          const t = this.getRoots();
          return t.length ? t[0] : this.graveyard;
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot();
          const e = this.model;
          const n = e.schema;
          const o = e.createPositionFromPath(t, [0]);
          const i = n.getNearestSelectionRange(o);
          return i || e.createRange(o);
        }
        _validateSelectionRange(t) {
          return cv(t.start) && cv(t.end);
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              this.selection.refresh();
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      function cv(t) {
        const e = t.textNode;
        if (e) {
          const n = e.data;
          const o = t.offset - e.startOffset;
          return !Cl(n, o) && !yl(n, o);
        }
        return true;
      }
      class lv extends $() {
        constructor() {
          super(...arguments);
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t) {
          const e = t instanceof dv ? t.name : t;
          return this._markers.has(e);
        }
        get(t) {
          return this._markers.get(t) || null;
        }
        _set(t, e, n = false, o = false) {
          const i = t instanceof dv ? t.name : t;
          if (i.includes(',')) {
            throw new B('markercollection-incorrect-marker-name', this);
          }
          const r = this._markers.get(i);
          if (r) {
            const t = r.getData();
            const s = r.getRange();
            let a = false;
            if (!s.isEqual(e)) {
              r._attachLiveRange(eb.fromRange(e));
              a = true;
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n;
              a = true;
            }
            if (typeof o === 'boolean' && o != r.affectsData) {
              r._affectsData = o;
              a = true;
            }
            if (a) {
              this.fire(`update:${i}`, r, s, e, t);
            }
            return r;
          }
          const s = eb.fromRange(e);
          const a = new dv(i, s, n, o);
          this._markers.set(i, a);
          this.fire(`update:${i}`, a, null, e, { ...a.getData(), range: null });
          return a;
        }
        _remove(t) {
          const e = t instanceof dv ? t.name : t;
          const n = this._markers.get(e);
          if (n) {
            this._markers.delete(e);
            this.fire(`update:${e}`, n, n.getRange(), null, n.getData());
            this._destroyMarker(n);
            return true;
          }
          return false;
        }
        _refresh(t) {
          const e = t instanceof dv ? t.name : t;
          const n = this._markers.get(e);
          if (!n) {
            throw new B('markercollection-refresh-marker-not-exists', this);
          }
          const o = n.getRange();
          this.fire(`update:${e}`, n, o, o, n.getData());
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e;
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e;
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t);
          }
          this._markers = null;
          this.stopListening();
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ':')) {
              yield e;
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening();
          t._detachLiveRange();
        }
      }
      class dv extends $(Ck) {
        constructor(t, e, n, o) {
          super();
          this.name = t;
          this._liveRange = this._attachLiveRange(e);
          this._managedUsingOperations = n;
          this._affectsData = o;
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new B('marker-destroyed', this);
          }
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new B('marker-destroyed', this);
          }
          return this._affectsData;
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          };
        }
        getStart() {
          if (!this._liveRange) {
            throw new B('marker-destroyed', this);
          }
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) {
            throw new B('marker-destroyed', this);
          }
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) {
            throw new B('marker-destroyed', this);
          }
          return this._liveRange.toRange();
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange();
          }
          t.delegate('change:range').to(this);
          t.delegate('change:content').to(this);
          this._liveRange = t;
          return t;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating('change:range', this);
          this._liveRange.stopDelegating('change:content', this);
          this._liveRange.detach();
          this._liveRange = null;
        }
      }
      dv.prototype.is = function (t) {
        return t === 'marker' || t === 'model:marker';
      };
      class hv extends p_ {
        constructor(t, e) {
          super(null);
          this.sourcePosition = t.clone();
          this.howMany = e;
        }
        get type() {
          return 'detach';
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          return t;
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new B('detach-operation-on-document-node', this);
          }
        }
        _execute() {
          m_(Nk._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return 'DetachOperation';
        }
      }
      class uv extends Ck {
        constructor(t) {
          super();
          this.markers = new Map();
          this._children = new xk();
          if (t) {
            this._insertChild(0, t);
          }
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return false;
        }
        getAncestors() {
          return [];
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        toJSON() {
          const t = [];
          for (const e of this._children) {
            t.push(e.toJSON());
          }
          return t;
        }
        static fromJSON(t) {
          const e = [];
          for (const n of t) {
            if (n.name) {
              e.push(Tk.fromJSON(n));
            } else {
              e.push(Ek.fromJSON(n));
            }
          }
          return new uv(e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = fv(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
      }
      uv.prototype.is = function (t) {
        return t === 'documentFragment' || t === 'model:documentFragment';
      };
      function fv(t) {
        if (typeof t == 'string') {
          return [new Ek(t)];
        }
        if (!yt(t)) {
          t = [t];
        }
        return Array.from(t).map(t => {
          if (typeof t == 'string') {
            return new Ek(t);
          }
          if (t instanceof Dk) {
            return new Ek(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class pv {
        constructor(t, e) {
          this.model = t;
          this.batch = e;
        }
        createText(t, e) {
          return new Ek(t, e);
        }
        createElement(t, e) {
          return new Tk(t, e);
        }
        createDocumentFragment() {
          return new uv();
        }
        cloneElement(t, e = true) {
          return t._clone(e);
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly();
          if (t instanceof Ek && t.data == '') {
            return;
          }
          const o = Rk._createAt(e, n);
          if (t.parent) {
            if (wv(t.root, o.root)) {
              this.move(Nk._createOn(t), o);
              return;
            } else {
              if (t.root.document) {
                throw new B('model-writer-insert-forbidden-move', this);
              } else {
                this.remove(t);
              }
            }
          }
          const i = o.root.document ? o.root.document.version : null;
          const r = new y_(o, t, i);
          if (t instanceof Ek) {
            r.shouldReceiveAttributes = true;
          }
          this.batch.addOperation(r);
          this.model.applyOperation(r);
          if (t instanceof uv) {
            for (const [e, n] of t.markers) {
              const t = Rk._createAt(n.root, 0);
              const i = new Nk(
                n.start._getCombined(t, o),
                n.end._getCombined(t, o),
              );
              const r = { range: i, usingOperation: true, affectsData: true };
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r);
              } else {
                this.addMarker(e, r);
              }
            }
          }
        }
        insertText(t, e, n, o) {
          if (e instanceof uv || e instanceof Tk || e instanceof Rk) {
            this.insert(this.createText(t), e, n);
          } else {
            this.insert(this.createText(t, e), n, o);
          }
        }
        insertElement(t, e, n, o) {
          if (e instanceof uv || e instanceof Tk || e instanceof Rk) {
            this.insert(this.createElement(t), e, n);
          } else {
            this.insert(this.createElement(t, e), n, o);
          }
        }
        append(t, e) {
          this.insert(t, e, 'end');
        }
        appendText(t, e, n) {
          if (e instanceof uv || e instanceof Tk) {
            this.insert(this.createText(t), e, 'end');
          } else {
            this.insert(this.createText(t, e), n, 'end');
          }
        }
        appendElement(t, e, n) {
          if (e instanceof uv || e instanceof Tk) {
            this.insert(this.createElement(t), e, 'end');
          } else {
            this.insert(this.createElement(t, e), n, 'end');
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (n instanceof Nk) {
            const o = n.getMinimalFlatRanges();
            for (const n of o) {
              gv(this, t, e, n);
            }
          } else {
            mv(this, t, e, n);
          }
        }
        setAttributes(t, e) {
          for (const [n, o] of gl(t)) {
            this.setAttribute(n, o, e);
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (e instanceof Nk) {
            const n = e.getMinimalFlatRanges();
            for (const e of n) {
              gv(this, t, null, e);
            }
          } else {
            mv(this, t, null, e);
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly();
          const e = t => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t);
            }
          };
          if (!(t instanceof Nk)) {
            e(t);
          } else {
            for (const n of t.getItems()) {
              e(n);
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Nk)) {
            throw new B('writer-move-invalid-range', this);
          }
          if (!t.isFlat) {
            throw new B('writer-move-range-not-flat', this);
          }
          const o = Rk._createAt(e, n);
          if (o.isEqual(t.start)) {
            return;
          }
          this._addOperationForAffectedMarkers('move', t);
          if (!wv(t.root, o.root)) {
            throw new B('writer-move-different-document', this);
          }
          const i = t.root.document ? t.root.document.version : null;
          const r = new C_(t.start, t.end.offset - t.start.offset, o, i);
          this.batch.addOperation(r);
          this.model.applyOperation(r);
        }
        remove(t) {
          this._assertWriterUsedCorrectly();
          const e = t instanceof Nk ? t : Nk._createOn(t);
          const n = e.getMinimalFlatRanges().reverse();
          for (const t of n) {
            this._addOperationForAffectedMarkers('move', t);
            bv(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly();
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this._addOperationForAffectedMarkers('merge', t);
          if (!(e instanceof Tk)) {
            throw new B('writer-merge-no-element-before', this);
          }
          if (!(n instanceof Tk)) {
            throw new B('writer-merge-no-element-after', this);
          }
          if (!t.root.document) {
            this._mergeDetached(t);
          } else {
            this._merge(t);
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n);
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e);
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t);
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t);
        }
        createRange(t, e) {
          return this.model.createRange(t, e);
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t);
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t);
        }
        createSelection(...t) {
          return this.model.createSelection(...t);
        }
        _mergeDetached(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this.move(Nk._createIn(n), Rk._createAt(e, 'end'));
          this.remove(n);
        }
        _merge(t) {
          const e = Rk._createAt(t.nodeBefore, 'end');
          const n = Rk._createAt(t.nodeAfter, 0);
          const o = t.root.document.graveyard;
          const i = new Rk(o, [0]);
          const r = t.root.document.version;
          const s = new E_(n, t.nodeAfter.maxOffset, e, i, r);
          this.batch.addOperation(s);
          this.model.applyOperation(s);
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Tk)) {
            throw new B('writer-rename-not-element-instance', this);
          }
          const n = t.root.document ? t.root.document.version : null;
          const o = new R_(Rk._createBefore(t), t.name, e, n);
          this.batch.addOperation(o);
          this.model.applyOperation(o);
        }
        split(t, e) {
          this._assertWriterUsedCorrectly();
          let n = t.parent;
          if (!n.parent) {
            throw new B('writer-split-element-no-parent', this);
          }
          if (!e) {
            e = n.parent;
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new B('writer-split-invalid-limit-element', this);
          }
          let o;
          let i;
          do {
            const e = n.root.document ? n.root.document.version : null;
            const r = n.maxOffset - t.offset;
            const s = x_.getInsertionPosition(t);
            const a = new x_(t, r, s, null, e);
            this.batch.addOperation(a);
            this.model.applyOperation(a);
            if (!o && !i) {
              o = n;
              i = t.parent.nextSibling;
            }
            t = this.createPositionAfter(t.parent);
            n = t.parent;
          } while (n !== e);
          return {
            position: t,
            range: new Nk(Rk._createAt(o, 'end'), Rk._createAt(i, 0)),
          };
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly();
          if (!t.isFlat) {
            throw new B('writer-wrap-range-not-flat', this);
          }
          const n = e instanceof Tk ? e : new Tk(e);
          if (n.childCount > 0) {
            throw new B('writer-wrap-element-not-empty', this);
          }
          if (n.parent !== null) {
            throw new B('writer-wrap-element-attached', this);
          }
          this.insert(n, t.start);
          const o = new Nk(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
          this.move(o, Rk._createAt(n, 0));
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly();
          if (t.parent === null) {
            throw new B('writer-unwrap-element-no-parent', this);
          }
          this.move(Nk._createIn(t), this.createPositionAfter(t));
          this.remove(t);
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly();
          if (!e || typeof e.usingOperation != 'boolean') {
            throw new B('writer-addmarker-no-usingoperation', this);
          }
          const n = e.usingOperation;
          const o = e.range;
          const i = e.affectsData === undefined ? false : e.affectsData;
          if (this.model.markers.has(t)) {
            throw new B('writer-addmarker-marker-exists', this);
          }
          if (!o) {
            throw new B('writer-addmarker-no-range', this);
          }
          if (!n) {
            return this.model.markers._set(t, o, n, i);
          }
          kv(this, t, null, o, i);
          return this.model.markers.get(t);
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly();
          const n = typeof t == 'string' ? t : t.name;
          const o = this.model.markers.get(n);
          if (!o) {
            throw new B('writer-updatemarker-marker-not-exists', this);
          }
          if (!e) {
            R('writer-updatemarker-reconvert-using-editingcontroller', {
              markerName: n,
            });
            this.model.markers._refresh(o);
            return;
          }
          const i = typeof e.usingOperation == 'boolean';
          const r = typeof e.affectsData == 'boolean';
          const s = r ? e.affectsData : o.affectsData;
          if (!i && !e.range && !r) {
            throw new B('writer-updatemarker-wrong-options', this);
          }
          const a = o.getRange();
          const c = e.range ? e.range : a;
          if (i && e.usingOperation !== o.managedUsingOperations) {
            if (e.usingOperation) {
              kv(this, n, null, c, s);
            } else {
              kv(this, n, a, null, s);
              this.model.markers._set(n, c, undefined, s);
            }
            return;
          }
          if (o.managedUsingOperations) {
            kv(this, n, a, c, s);
          } else {
            this.model.markers._set(n, c, undefined, s);
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == 'string' ? t : t.name;
          if (!this.model.markers.has(e)) {
            throw new B('writer-removemarker-no-marker', this);
          }
          const n = this.model.markers.get(e);
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e);
            return;
          }
          const o = n.getRange();
          kv(this, e, o, null, n.affectsData);
        }
        addRoot(t, e = '$root') {
          this._assertWriterUsedCorrectly();
          const n = this.model.document.getRoot(t);
          if (n && n.isAttached()) {
            throw new B('writer-addroot-root-exists', this);
          }
          const o = this.model.document;
          const i = new I_(t, e, true, o, o.version);
          this.batch.addOperation(i);
          this.model.applyOperation(i);
          return this.model.document.getRoot(t);
        }
        detachRoot(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == 'string' ? this.model.document.getRoot(t) : t;
          if (!e || !e.isAttached()) {
            throw new B('writer-detachroot-no-root', this);
          }
          for (const t of this.model.markers) {
            if (t.getRange().root === e) {
              this.removeMarker(t);
            }
          }
          for (const t of e.getAttributeKeys()) {
            this.removeAttribute(t, e);
          }
          this.remove(this.createRangeIn(e));
          const n = this.model.document;
          const o = new I_(e.rootName, e.name, false, n, n.version);
          this.batch.addOperation(o);
          this.model.applyOperation(o);
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setTo(...t);
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setFocus(t, e);
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (typeof t === 'string') {
            this._setSelectionAttribute(t, e);
          } else {
            for (const [e, n] of gl(t)) {
              this._setSelectionAttribute(e, n);
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly();
          if (typeof t === 'string') {
            this._removeSelectionAttribute(t);
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e);
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t);
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const o = sb._getStoreAttributeKey(t);
            this.setAttribute(o, e, n.anchor.parent);
          }
          n._setAttribute(t, e);
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection;
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = sb._getStoreAttributeKey(t);
            this.removeAttribute(n, e.anchor.parent);
          }
          e._removeAttribute(t);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new B('writer-incorrect-use', this);
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue;
            }
            const o = n.getRange();
            let i = false;
            if (t === 'move') {
              const t = e;
              i =
                t.containsPosition(o.start) ||
                t.start.isEqual(o.start) ||
                t.containsPosition(o.end) ||
                t.end.isEqual(o.end);
            } else {
              const t = e;
              const n = t.nodeBefore;
              const r = t.nodeAfter;
              const s = o.start.parent == n && o.start.isAtEnd;
              const a = o.end.parent == r && o.end.offset == 0;
              const c = o.end.nodeAfter == r;
              const l = o.start.nodeAfter == r;
              i = s || a || c || l;
            }
            if (i) {
              this.updateMarker(n.name, { range: o });
            }
          }
        }
      }
      function gv(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        let s = o.start;
        let a;
        let c;
        let l;
        for (const t of o.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e);
          if (a && c != l) {
            if (c != n) {
              d();
            }
            s = a;
          }
          a = t.nextPosition;
          c = l;
        }
        if (a instanceof Rk && a != s && c != n) {
          d();
        }
        function d() {
          const o = new Nk(s, a);
          const l = o.root.document ? r.version : null;
          const d = new P_(o, e, c, n, l);
          t.batch.addOperation(d);
          i.applyOperation(d);
        }
      }
      function mv(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        const s = o.getAttribute(e);
        let a, c;
        if (s != n) {
          const l = o.root === o;
          if (l) {
            const t = o.document ? r.version : null;
            c = new O_(o, e, s, n, t);
          } else {
            a = new Nk(Rk._createBefore(o), t.createPositionAfter(o));
            const i = a.root.document ? r.version : null;
            c = new P_(a, e, s, n, i);
          }
          t.batch.addOperation(c);
          i.applyOperation(c);
        }
      }
      function kv(t, e, n, o, i) {
        const r = t.model;
        const s = r.document;
        const a = new D_(e, n, o, r.markers, !!i, s.version);
        t.batch.addOperation(a);
        r.applyOperation(a);
      }
      function bv(t, e, n, o) {
        let i;
        if (t.root.document) {
          const n = o.document;
          const r = new Rk(n.graveyard, [0]);
          i = new C_(t, e, r, n.version);
        } else {
          i = new hv(t, e);
        }
        n.addOperation(i);
        o.applyOperation(i);
      }
      function wv(t, e) {
        if (t === e) {
          return true;
        }
        if (t instanceof rv && e instanceof rv) {
          return true;
        }
        return false;
      }
      function _v(t, e, n = {}) {
        if (e.isCollapsed) {
          return;
        }
        const o = e.getFirstRange();
        if (o.root.rootName == '$graveyard') {
          return;
        }
        const i = t.schema;
        t.change(t => {
          if (!n.doNotResetEntireContent && Ov(i, e)) {
            Rv(t, e);
            return;
          }
          const r = {};
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement();
            if (t) {
              Object.assign(
                r,
                i.getAttributesWithProperty(t, 'copyOnReplace', true),
              );
            }
          }
          const [s, a] = vv(o);
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a));
          }
          if (!n.leaveUnmerged) {
            Cv(t, s, a);
            i.removeDisallowedAttributes(s.parent.getChildren(), t);
          }
          Iv(t, e, s);
          if (!n.doNotAutoparagraph && Sv(i, s)) {
            Bv(t, s, e, r);
          }
          s.detach();
          a.detach();
        });
      }
      function vv(t) {
        const e = t.root.document.model;
        const n = t.start;
        let o = t.end;
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = Av(o);
          if (n && o.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t);
            e.modifySelection(n, { direction: 'backward' });
            const i = n.getLastPosition();
            const r = e.createRange(i, o);
            if (!e.hasContent(r, { ignoreMarkers: true })) {
              o = i;
            }
          }
        }
        return [J_.fromPosition(n, 'toPrevious'), J_.fromPosition(o, 'toNext')];
      }
      function Av(t) {
        const e = t.parent;
        const n = e.root.document.model.schema;
        const o = e.getAncestors({ parentFirst: true, includeSelf: true });
        for (const t of o) {
          if (n.isLimit(t)) {
            return null;
          }
          if (n.isBlock(t)) {
            return t;
          }
        }
      }
      function Cv(t, e, n) {
        const o = t.model;
        if (!Dv(t.model.schema, e, n)) {
          return;
        }
        const [i, r] = Tv(e, n);
        if (!i || !r) {
          return;
        }
        if (
          !o.hasContent(i, { ignoreMarkers: true }) &&
          o.hasContent(r, { ignoreMarkers: true })
        ) {
          xv(t, e, n, i.parent);
        } else {
          yv(t, e, n, i.parent);
        }
      }
      function yv(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(r, e);
        }
        t.merge(e);
        while (n.parent.isEmpty) {
          const e = n.parent;
          n = t.createPositionBefore(e);
          t.remove(e);
        }
        if (!Dv(t.model.schema, e, n)) {
          return;
        }
        yv(t, e, n, o);
      }
      function xv(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(i, n);
        }
        while (e.parent.isEmpty) {
          const n = e.parent;
          e = t.createPositionBefore(n);
          t.remove(n);
        }
        n = t.createPositionBefore(r);
        Ev(t, n);
        if (!Dv(t.model.schema, e, n)) {
          return;
        }
        xv(t, e, n, o);
      }
      function Ev(t, e) {
        const n = e.nodeBefore;
        const o = e.nodeAfter;
        if (n.name != o.name) {
          t.rename(n, o.name);
        }
        t.clearAttributes(n);
        t.setAttributes(Object.fromEntries(o.getAttributes()), n);
        t.merge(e);
      }
      function Dv(t, e, n) {
        const o = e.parent;
        const i = n.parent;
        if (o == i) {
          return false;
        }
        if (t.isLimit(o) || t.isLimit(i)) {
          return false;
        }
        return Pv(e, n, t);
      }
      function Tv(t, e) {
        const n = t.getAncestors();
        const o = e.getAncestors();
        let i = 0;
        while (n[i] && n[i] == o[i]) {
          i++;
        }
        return [n[i], o[i]];
      }
      function Sv(t, e) {
        const n = t.checkChild(e, '$text');
        const o = t.checkChild(e, 'paragraph');
        return !n && o;
      }
      function Pv(t, e, n) {
        const o = new Nk(t, e);
        for (const t of o.getWalker()) {
          if (n.isLimit(t.item)) {
            return false;
          }
        }
        return true;
      }
      function Bv(t, e, n, o = {}) {
        const i = t.createElement('paragraph');
        t.model.schema.setAllowedAttributes(i, o, t);
        t.insert(i, e);
        Iv(t, n, t.createPositionAt(i, 0));
      }
      function Rv(t, e) {
        const n = t.model.schema.getLimitElement(e);
        t.remove(t.createRangeIn(n));
        Bv(t, t.createPositionAt(n, 0), e);
      }
      function Ov(t, e) {
        const n = t.getLimitElement(e);
        if (!e.containsEntireContent(n)) {
          return false;
        }
        const o = e.getFirstRange();
        if (o.start.parent == o.end.parent) {
          return false;
        }
        return t.checkChild(n, 'paragraph');
      }
      function Iv(t, e, n) {
        if (e instanceof sb) {
          t.setSelection(n);
        } else {
          e.setTo(n);
        }
      }
      function Mv(t, e) {
        return t.change(t => {
          const n = t.createDocumentFragment();
          const o = e.getFirstRange();
          if (!o || o.isCollapsed) {
            return n;
          }
          const i = o.start.root;
          const r = o.start.getCommonPath(o.end);
          const s = i.getNodeByPath(r);
          let a;
          if (o.start.parent == o.end.parent) {
            a = o;
          } else {
            a = t.createRange(
              t.createPositionAt(s, o.start.path[r.length]),
              t.createPositionAt(s, o.end.path[r.length] + 1),
            );
          }
          const c = a.end.offset - a.start.offset;
          for (const e of a.getItems({ shallow: true })) {
            if (e.is('$textProxy')) {
              t.appendText(e.data, e.getAttributes(), n);
            } else {
              t.append(t.cloneElement(e, true), n);
            }
          }
          if (a != o) {
            const e = o._getTransformedByMove(
              a.start,
              t.createPositionAt(n, 0),
              c,
            )[0];
            const i = t.createRange(t.createPositionAt(n, 0), e.start);
            const r = t.createRange(e.end, t.createPositionAt(n, 'end'));
            Vv(r, t);
            Vv(i, t);
          }
          return n;
        });
      }
      function Vv(t, e) {
        const n = [];
        Array.from(t.getItems({ direction: 'backward' }))
          .map(t => e.createRangeOn(t))
          .filter(e => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end));
            return n;
          })
          .forEach(t => {
            n.push(t.start.parent);
            e.remove(t);
          });
        n.forEach(t => {
          let n = t;
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n);
            n = n.parent;
            e.remove(t);
          }
        });
      }
      function zv(t, e, n) {
        return t.change(o => {
          const i = n ? n : t.document.selection;
          if (!i.isCollapsed) {
            t.deleteContent(i, { doNotAutoparagraph: true });
          }
          const r = new Fv(t, o, i.anchor);
          const s = [];
          let a;
          if (e.is('documentFragment')) {
            if (e.markers.size) {
              const t = [];
              for (const [n, o] of e.markers) {
                const { start: e, end: i } = o;
                const r = e.isEqual(i);
                t.push(
                  { position: e, name: n, isCollapsed: r },
                  { position: i, name: n, isCollapsed: r },
                );
              }
              t.sort(({ position: t }, { position: e }) =>
                t.isBefore(e) ? 1 : -1,
              );
              for (const { position: n, name: i, isCollapsed: r } of t) {
                let t = null;
                let a = null;
                const c = n.parent === e && n.isAtStart;
                const l = n.parent === e && n.isAtEnd;
                if (!c && !l) {
                  t = o.createElement('$marker');
                  o.insert(t, n);
                } else if (r) {
                  a = c ? 'start' : 'end';
                }
                s.push({ name: i, element: t, collapsed: a });
              }
            }
            a = e.getChildren();
          } else {
            a = [e];
          }
          r.handleNodes(a);
          let c = r.getSelectionRange();
          if (e.is('documentFragment') && s.length) {
            const t = c ? eb.fromRange(c) : null;
            const e = {};
            for (let t = s.length - 1; t >= 0; t--) {
              const { name: n, element: i, collapsed: a } = s[t];
              const c = !e[n];
              if (c) {
                e[n] = [];
              }
              if (i) {
                const t = o.createPositionAt(i, 'before');
                e[n].push(t);
                o.remove(i);
              } else {
                const t = r.getAffectedRange();
                if (!t) {
                  if (a) {
                    e[n].push(r.position);
                  }
                  continue;
                }
                if (a) {
                  e[n].push(t[a]);
                } else {
                  e[n].push(c ? t.start : t.end);
                }
              }
            }
            for (const [t, [n, i]] of Object.entries(e)) {
              if (n && i && n.root === i.root) {
                o.addMarker(t, {
                  usingOperation: true,
                  affectsData: true,
                  range: new Nk(n, i),
                });
              }
            }
            if (t) {
              c = t.toRange();
              t.detach();
            }
          }
          if (c) {
            if (i instanceof sb) {
              o.setSelection(c);
            } else {
              i.setTo(c);
            }
          } else {
          }
          const l = r.getAffectedRange() || t.createRange(i.anchor);
          r.destroy();
          return l;
        });
      }
      class Fv {
        constructor(t, e, n) {
          this._firstNode = null;
          this._lastNode = null;
          this._lastAutoParagraph = null;
          this._filterAttributesOf = [];
          this._affectedStart = null;
          this._affectedEnd = null;
          this._nodeToSelect = null;
          this.model = t;
          this.writer = e;
          this.position = n;
          this.canMergeWith = new Set([this.position.parent]);
          this.schema = t.schema;
          this._documentFragment = e.createDocumentFragment();
          this._documentFragmentPosition = e.createPositionAt(
            this._documentFragment,
            0,
          );
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e);
          }
          this._insertPartialFragment();
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
          }
          this._mergeOnRight();
          this.schema.removeDisallowedAttributes(
            this._filterAttributesOf,
            this.writer,
          );
          this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode);
          const n = this.writer.createPositionAfter(t);
          if (n.isAfter(e)) {
            this._lastNode = t;
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new B('insertcontent-invalid-insertion-position', this);
            }
            this.position = n;
            this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return Nk._createOn(this._nodeToSelect);
          }
          return this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null;
          }
          return new Nk(this._affectedStart, this._affectedEnd);
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach();
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t);
            return;
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t);
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t);
            if (!e) {
              this._handleDisallowedNode(t);
              return;
            }
          }
          this._appendToFragment(t);
          if (!this._firstNode) {
            this._firstNode = t;
          }
          this._lastNode = t;
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return;
          }
          const t = J_.fromPosition(this.position, 'toNext');
          this._setAffectedBoundaries(this.position);
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position);
            this._mergeOnLeft();
            this.position = t.toPosition();
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position);
          }
          this._documentFragmentPosition = this.writer.createPositionAt(
            this._documentFragment,
            0,
          );
          this.position = t.toPosition();
          t.detach();
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t);
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _handleDisallowedNode(t) {
          if (t.is('element')) {
            this.handleNodes(t.getChildren());
          } else {
            this._tryAutoparagraphing(t);
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new B('insertcontent-wrong-position', this, {
              node: t,
              position: this.position,
            });
          }
          this.writer.insert(t, this._documentFragmentPosition);
          this._documentFragmentPosition =
            this._documentFragmentPosition.getShiftedBy(t.offsetSize);
          if (
            this.schema.isObject(t) &&
            !this.schema.checkChild(this.position, '$text')
          ) {
            this._nodeToSelect = t;
          } else {
            this._nodeToSelect = null;
          }
          this._filterAttributesOf.push(t);
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = J_.fromPosition(t, 'toPrevious');
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
            this._affectedEnd = J_.fromPosition(t, 'toNext');
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode;
          if (!(t instanceof Tk)) {
            return;
          }
          if (!this._canMergeLeft(t)) {
            return;
          }
          const e = J_._createBefore(t);
          e.stickiness = 'toNext';
          const n = J_.fromPosition(this.position, 'toNext');
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach();
            this._affectedStart = J_._createAt(
              e.nodeBefore,
              'end',
              'toPrevious',
            );
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.isEqual(this._affectedEnd) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedEnd.detach();
            this._affectedEnd = J_._createAt(e.nodeBefore, 'end', 'toNext');
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _mergeOnRight() {
          const t = this._lastNode;
          if (!(t instanceof Tk)) {
            return;
          }
          if (!this._canMergeRight(t)) {
            return;
          }
          const e = J_._createAfter(t);
          e.stickiness = 'toNext';
          if (!this.position.isEqual(e)) {
            throw new B('insertcontent-invalid-insertion-position', this);
          }
          this.position = Rk._createAt(e.nodeBefore, 'end');
          const n = J_.fromPosition(this.position, 'toPrevious');
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach();
            this._affectedEnd = J_._createAt(e.nodeBefore, 'end', 'toNext');
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore;
            this._lastNode = e.nodeBefore;
          }
          this.writer.merge(e);
          if (
            e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedStart.detach();
            this._affectedStart = J_._createAt(e.nodeBefore, 0, 'toPrevious');
          }
          this.position = n.toPosition();
          n.detach();
          this._filterAttributesOf.push(this.position.parent);
          e.detach();
        }
        _canMergeLeft(t) {
          const e = t.previousSibling;
          return (
            e instanceof Tk &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(e, t)
          );
        }
        _canMergeRight(t) {
          const e = t.nextSibling;
          return (
            e instanceof Tk &&
            this.canMergeWith.has(e) &&
            this.model.schema.checkMerge(t, e)
          );
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement('paragraph');
          if (
            this._getAllowedIn(this.position.parent, e) &&
            this.schema.checkChild(e, t)
          ) {
            e._appendChild(t);
            this._handleNode(e);
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true;
          }
          if (
            !this.schema.checkChild(this.position.parent, 'paragraph') ||
            !this.schema.checkChild('paragraph', t)
          ) {
            return false;
          }
          this._insertPartialFragment();
          const e = this.writer.createElement('paragraph');
          this.writer.insert(e, this.position);
          this._setAffectedBoundaries(this.position);
          this._lastAutoParagraph = e;
          this.position = this.writer.createPositionAt(e, 0);
          return true;
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t);
          if (!e) {
            return false;
          }
          if (e != this.position.parent) {
            this._insertPartialFragment();
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent;
              this.position = this.writer.createPositionBefore(t);
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t);
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(
                this.position.parent,
              );
            } else {
              const t = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position);
              this.writer.split(this.position);
              this.position = t;
              this.canMergeWith.add(this.position.nodeAfter);
            }
          }
          return true;
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t;
          }
          if (this.schema.isLimit(t)) {
            return null;
          }
          return this._getAllowedIn(t.parent, e);
        }
      }
      function Nv(t, e, n = 'auto') {
        const o = t.getSelectedElement();
        if (o && e.schema.isObject(o) && !e.schema.isInline(o)) {
          if (n == 'before' || n == 'after') {
            return e.createRange(e.createPositionAt(o, n));
          }
          return e.createRangeOn(o);
        }
        const i = hl(t.getSelectedBlocks());
        if (!i) {
          return e.createRange(t.focus);
        }
        if (i.isEmpty) {
          return e.createRange(e.createPositionAt(i, 0));
        }
        const r = e.createPositionAfter(i);
        if (t.focus.isTouching(r)) {
          return e.createRange(r);
        }
        return e.createRange(e.createPositionBefore(i));
      }
      function Lv(t, e, n, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new B('insertobject-element-not-an-object', t, { object: e });
        }
        const i = n ? n : t.document.selection;
        let r = i;
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          r = t.createSelection(Nv(i, t, o.findOptimalPosition));
        }
        const s = hl(i.getSelectedBlocks());
        const a = {};
        if (s) {
          Object.assign(
            a,
            t.schema.getAttributesWithProperty(s, 'copyOnReplace', true),
          );
        }
        return t.change(n => {
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true });
          }
          let i = e;
          const s = r.anchor.parent;
          if (
            !t.schema.checkChild(s, e) &&
            t.schema.checkChild(s, 'paragraph') &&
            t.schema.checkChild('paragraph', e)
          ) {
            i = n.createElement('paragraph');
            n.insert(e, i);
          }
          t.schema.setAllowedAttributes(i, a, n);
          const c = t.insertContent(i, r);
          if (c.isCollapsed) {
            return c;
          }
          if (o.setSelection) {
            Hv(n, e, o.setSelection, a);
          }
          return c;
        });
      }
      function Hv(t, e, n, o) {
        const i = t.model;
        if (n == 'on') {
          t.setSelection(e, 'on');
          return;
        }
        if (n != 'after') {
          throw new B('insertobject-invalid-place-parameter-value', i);
        }
        let r = e.nextSibling;
        if (i.schema.isInline(e)) {
          t.setSelection(e, 'after');
          return;
        }
        const s = r && i.schema.checkChild(r, '$text');
        if (!s && i.schema.checkChild(e.parent, 'paragraph')) {
          r = t.createElement('paragraph');
          i.schema.setAllowedAttributes(r, o, t);
          i.insertContent(r, t.createPositionAfter(e));
        }
        if (r) {
          t.setSelection(r, 0);
        }
      }
      const jv = ' ,.?!:;"-()';
      function qv(t, e, n = {}) {
        const o = t.schema;
        const i = n.direction != 'backward';
        const r = n.unit ? n.unit : 'character';
        const s = !!n.treatEmojiAsSingleUnit;
        const a = e.focus;
        const c = new Pk({
          boundaries: Kv(a, i),
          singleCharacters: true,
          direction: i ? 'forward' : 'backward',
        });
        const l = {
          walker: c,
          schema: o,
          isForward: i,
          unit: r,
          treatEmojiAsSingleUnit: s,
        };
        let d;
        while ((d = c.next())) {
          if (d.done) {
            return;
          }
          const n = $v(l, d.value);
          if (n) {
            if (e instanceof sb) {
              t.change(t => {
                t.setSelectionFocus(n);
              });
            } else {
              e.setFocus(n);
            }
            return;
          }
        }
      }
      function $v(t, e) {
        const {
          isForward: n,
          walker: o,
          unit: i,
          schema: r,
          treatEmojiAsSingleUnit: s,
        } = t;
        const { type: a, item: c, nextPosition: l } = e;
        if (a == 'text') {
          if (t.unit === 'word') {
            return Gv(o, n);
          }
          return Wv(o, i, s);
        }
        if (a == (n ? 'elementStart' : 'elementEnd')) {
          if (r.isSelectable(c)) {
            return Rk._createAt(c, n ? 'after' : 'before');
          }
          if (r.checkChild(l, '$text')) {
            return l;
          }
        } else {
          if (r.isLimit(c)) {
            o.skip(() => true);
            return;
          }
          if (r.checkChild(l, '$text')) {
            return l;
          }
        }
      }
      function Wv(t, e, n) {
        const o = t.position.textNode;
        if (o) {
          const i = o.data;
          let r = t.position.offset - o.startOffset;
          while (
            Cl(i, r) ||
            (e == 'character' && yl(i, r)) ||
            (n && El(i, r))
          ) {
            t.next();
            r = t.position.offset - o.startOffset;
          }
        }
        return t.position;
      }
      function Gv(t, e) {
        let n = t.position.textNode;
        if (!n) {
          n = e ? t.position.nodeAfter : t.position.nodeBefore;
        }
        while (n && n.is('$text')) {
          const o = t.position.offset - n.startOffset;
          if (Zv(n, o, e)) {
            n = e ? t.position.nodeAfter : t.position.nodeBefore;
          } else if (Uv(n.data, o, e)) {
            break;
          } else {
            t.next();
          }
        }
        return t.position;
      }
      function Kv(t, e) {
        const n = t.root;
        const o = Rk._createAt(n, e ? 'end' : 0);
        if (e) {
          return new Nk(t, o);
        } else {
          return new Nk(o, t);
        }
      }
      function Uv(t, e, n) {
        const o = e + (n ? 0 : -1);
        return jv.includes(t.charAt(o));
      }
      function Zv(t, e, n) {
        return e === (n ? t.offsetSize : 0);
      }
      class Jv extends dt() {
        constructor() {
          super();
          this.markers = new lv();
          this.document = new av(this);
          this.schema = new Fw();
          this._pendingChanges = [];
          this._currentWriter = null;
          [
            'deleteContent',
            'modifySelection',
            'getSelectedContent',
            'applyOperation',
          ].forEach(t => this.decorate(t));
          this.on(
            'applyOperation',
            (t, e) => {
              const n = e[0];
              n._validate();
            },
            { priority: 'highest' },
          );
          this.schema.register('$root', { isLimit: true });
          this.schema.register('$container', {
            allowIn: ['$root', '$container'],
          });
          this.schema.register('$block', {
            allowIn: ['$root', '$container'],
            isBlock: true,
          });
          this.schema.register('$blockObject', {
            allowWhere: '$block',
            isBlock: true,
            isObject: true,
          });
          this.schema.register('$inlineObject', {
            allowWhere: '$text',
            allowAttributesOf: '$text',
            isInline: true,
            isObject: true,
          });
          this.schema.register('$text', {
            allowIn: '$block',
            isInline: true,
            isContent: true,
          });
          this.schema.register('$clipboardHolder', {
            allowContentOf: '$root',
            allowChildren: '$text',
            isLimit: true,
          });
          this.schema.register('$documentFragment', {
            allowContentOf: '$root',
            allowChildren: '$text',
            isLimit: true,
          });
          this.schema.register('$marker');
          this.schema.addChildCheck((t, e) => {
            if (e.name === '$marker') {
              return true;
            }
          });
          yw(this);
          this.document.registerPostFixer(ew);
          this.on('insertContent', (t, [e, n]) => {
            t.return = zv(this, e, n);
          });
          this.on('insertObject', (t, [e, n, o]) => {
            t.return = Lv(this, e, n, o);
          });
          this.on('canEditAt', t => {
            const e = !this.document.isReadOnly;
            t.return = e;
            if (!e) {
              t.stop();
            }
          });
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new X_(), callback: t });
              return this._runPendingChanges()[0];
            } else {
              return t(this._currentWriter);
            }
          } catch (t) {
            B.rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new X_();
            } else if (typeof t === 'function') {
              e = t;
              t = new X_();
            } else if (!(t instanceof X_)) {
              t = new X_(t);
            }
            this._pendingChanges.push({ batch: t, callback: e });
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges();
            }
          } catch (t) {
            B.rethrowUnexpectedError(t, this);
          }
        }
        applyOperation(t) {
          t._execute();
        }
        insertContent(t, e, n, ...o) {
          const i = Yv(e, n);
          return this.fire('insertContent', [t, i, n, ...o]);
        }
        insertObject(t, e, n, o, ...i) {
          const r = Yv(e, n);
          return this.fire('insertObject', [t, r, o, o, ...i]);
        }
        deleteContent(t, e) {
          _v(this, t, e);
        }
        modifySelection(t, e) {
          qv(this, t, e);
        }
        getSelectedContent(t) {
          return Mv(this, t);
        }
        hasContent(t, e = {}) {
          const n = t instanceof Nk ? t : Nk._createIn(t);
          if (n.isCollapsed) {
            return false;
          }
          const { ignoreWhitespaces: o = false, ignoreMarkers: i = false } = e;
          if (!i) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true;
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is('$textProxy')) {
                if (!o) {
                  return true;
                } else if (t.data.search(/\S/) !== -1) {
                  return true;
                }
              } else {
                return true;
              }
            }
          }
          return false;
        }
        canEditAt(t) {
          const e = Yv(t);
          return this.fire('canEditAt', [e]);
        }
        createPositionFromPath(t, e, n) {
          return new Rk(t, e, n);
        }
        createPositionAt(t, e) {
          return Rk._createAt(t, e);
        }
        createPositionAfter(t) {
          return Rk._createAfter(t);
        }
        createPositionBefore(t) {
          return Rk._createBefore(t);
        }
        createRange(t, e) {
          return new Nk(t, e);
        }
        createRangeIn(t) {
          return Nk._createIn(t);
        }
        createRangeOn(t) {
          return Nk._createOn(t);
        }
        createSelection(...t) {
          return new Kk(...t);
        }
        createBatch(t) {
          return new X_(t);
        }
        createOperationFromJSON(t) {
          return V_.fromJSON(t, this.document);
        }
        destroy() {
          this.document.destroy();
          this.stopListening();
        }
        _runPendingChanges() {
          const t = [];
          this.fire('_beforeChanges');
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch;
              this._currentWriter = new pv(this, e);
              const n = this._pendingChanges[0].callback(this._currentWriter);
              t.push(n);
              this.document._handleChangeBlock(this._currentWriter);
              this._pendingChanges.shift();
              this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0;
            this._currentWriter = null;
            this.fire('_afterChanges');
          }
          return t;
        }
      }
      function Yv(t, e) {
        if (!t) {
          return;
        }
        if (t instanceof Kk || t instanceof sb) {
          return t;
        }
        if (t instanceof yk) {
          if (e || e === 0) {
            return new Kk(t, e);
          } else if (t.is('rootElement')) {
            return new Kk(t, 'in');
          } else {
            return new Kk(t, 'on');
          }
        }
        return new Kk(t);
      }
      class Qv extends (null && DomEventObserver) {
        constructor() {
          super(...arguments);
          this.domEventType = 'click';
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class Xv extends Lg {
        constructor() {
          super(...arguments);
          this.domEventType = ['mousedown', 'mouseup', 'mouseover', 'mouseout'];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class tA {
        constructor(t) {
          this.document = t;
        }
        createDocumentFragment(t) {
          return new DocumentFragment(this.document, t);
        }
        createElement(t, e, n) {
          return new Element(this.document, t, e, n);
        }
        createText(t) {
          return new Text(this.document, t);
        }
        clone(t, e = false) {
          return t._clone(e);
        }
        appendChild(t, e) {
          return e._appendChild(t);
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e);
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e);
        }
        remove(t) {
          const e = t.parent;
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e);
          }
          return [];
        }
        replace(t, e) {
          const n = t.parent;
          if (n) {
            const o = n.getChildIndex(t);
            this.removeChildren(o, 1, n);
            this.insertChild(o, e, n);
            return true;
          }
          return false;
        }
        unwrapElement(t) {
          const e = t.parent;
          if (e) {
            const n = e.getChildIndex(t);
            this.remove(t);
            this.insertChild(n, t.getChildren(), e);
          }
        }
        rename(t, e) {
          const n = new Element(
            this.document,
            t,
            e.getAttributes(),
            e.getChildren(),
          );
          return this.replace(e, n) ? n : null;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (isPlainObject(t) && n === undefined) {
            e._setStyle(t);
          } else {
            n._setStyle(t, e);
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        createPositionAt(t, e) {
          return Position._createAt(t, e);
        }
        createPositionAfter(t) {
          return Position._createAfter(t);
        }
        createPositionBefore(t) {
          return Position._createBefore(t);
        }
        createRange(t, e) {
          return new Range(t, e);
        }
        createRangeOn(t) {
          return Range._createOn(t);
        }
        createRangeIn(t) {
          return Range._createIn(t);
        }
        createSelection(...t) {
          return new Selection(...t);
        }
      }
      const eA = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
      const nA = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
      const oA =
        /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const iA =
        /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
      const rA =
        /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
      const sA = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi;
      const aA = new Set([
        'black',
        'silver',
        'gray',
        'white',
        'maroon',
        'red',
        'purple',
        'fuchsia',
        'green',
        'lime',
        'olive',
        'yellow',
        'navy',
        'blue',
        'teal',
        'aqua',
        'orange',
        'aliceblue',
        'antiquewhite',
        'aquamarine',
        'azure',
        'beige',
        'bisque',
        'blanchedalmond',
        'blueviolet',
        'brown',
        'burlywood',
        'cadetblue',
        'chartreuse',
        'chocolate',
        'coral',
        'cornflowerblue',
        'cornsilk',
        'crimson',
        'cyan',
        'darkblue',
        'darkcyan',
        'darkgoldenrod',
        'darkgray',
        'darkgreen',
        'darkgrey',
        'darkkhaki',
        'darkmagenta',
        'darkolivegreen',
        'darkorange',
        'darkorchid',
        'darkred',
        'darksalmon',
        'darkseagreen',
        'darkslateblue',
        'darkslategray',
        'darkslategrey',
        'darkturquoise',
        'darkviolet',
        'deeppink',
        'deepskyblue',
        'dimgray',
        'dimgrey',
        'dodgerblue',
        'firebrick',
        'floralwhite',
        'forestgreen',
        'gainsboro',
        'ghostwhite',
        'gold',
        'goldenrod',
        'greenyellow',
        'grey',
        'honeydew',
        'hotpink',
        'indianred',
        'indigo',
        'ivory',
        'khaki',
        'lavender',
        'lavenderblush',
        'lawngreen',
        'lemonchiffon',
        'lightblue',
        'lightcoral',
        'lightcyan',
        'lightgoldenrodyellow',
        'lightgray',
        'lightgreen',
        'lightgrey',
        'lightpink',
        'lightsalmon',
        'lightseagreen',
        'lightskyblue',
        'lightslategray',
        'lightslategrey',
        'lightsteelblue',
        'lightyellow',
        'limegreen',
        'linen',
        'magenta',
        'mediumaquamarine',
        'mediumblue',
        'mediumorchid',
        'mediumpurple',
        'mediumseagreen',
        'mediumslateblue',
        'mediumspringgreen',
        'mediumturquoise',
        'mediumvioletred',
        'midnightblue',
        'mintcream',
        'mistyrose',
        'moccasin',
        'navajowhite',
        'oldlace',
        'olivedrab',
        'orangered',
        'orchid',
        'palegoldenrod',
        'palegreen',
        'paleturquoise',
        'palevioletred',
        'papayawhip',
        'peachpuff',
        'peru',
        'pink',
        'plum',
        'powderblue',
        'rosybrown',
        'royalblue',
        'saddlebrown',
        'salmon',
        'sandybrown',
        'seagreen',
        'seashell',
        'sienna',
        'skyblue',
        'slateblue',
        'slategray',
        'slategrey',
        'snow',
        'springgreen',
        'steelblue',
        'tan',
        'thistle',
        'tomato',
        'turquoise',
        'violet',
        'wheat',
        'whitesmoke',
        'yellowgreen',
        'activeborder',
        'activecaption',
        'appworkspace',
        'background',
        'buttonface',
        'buttonhighlight',
        'buttonshadow',
        'buttontext',
        'captiontext',
        'graytext',
        'highlight',
        'highlighttext',
        'inactiveborder',
        'inactivecaption',
        'inactivecaptiontext',
        'infobackground',
        'infotext',
        'menu',
        'menutext',
        'scrollbar',
        'threeddarkshadow',
        'threedface',
        'threedhighlight',
        'threedlightshadow',
        'threedshadow',
        'window',
        'windowframe',
        'windowtext',
        'rebeccapurple',
        'currentcolor',
        'transparent',
      ]);
      function cA(t) {
        if (t.startsWith('#')) {
          return eA.test(t);
        }
        if (t.startsWith('rgb')) {
          return nA.test(t) || oA.test(t);
        }
        if (t.startsWith('hsl')) {
          return iA.test(t) || rA.test(t);
        }
        return aA.has(t.toLowerCase());
      }
      const lA = null && [
        'none',
        'hidden',
        'dotted',
        'dashed',
        'solid',
        'double',
        'groove',
        'ridge',
        'inset',
        'outset',
      ];
      function dA(t) {
        return lA.includes(t);
      }
      const hA =
        /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
      function uA(t) {
        return hA.test(t);
      }
      const fA = /^[+-]?[0-9]*([.][0-9]+)?%$/;
      function pA(t) {
        return fA.test(t);
      }
      const gA = null && [
        'repeat-x',
        'repeat-y',
        'repeat',
        'space',
        'round',
        'no-repeat',
      ];
      function mA(t) {
        return gA.includes(t);
      }
      const kA = null && ['center', 'top', 'bottom', 'left', 'right'];
      function bA(t) {
        return kA.includes(t);
      }
      const wA = null && ['fixed', 'scroll', 'local'];
      function _A(t) {
        return wA.includes(t);
      }
      const vA = /^url\(/;
      function AA(t) {
        return vA.test(t);
      }
      function CA(t = '') {
        if (t === '') {
          return {
            top: undefined,
            right: undefined,
            bottom: undefined,
            left: undefined,
          };
        }
        const e = DA(t);
        const n = e[0];
        const o = e[2] || n;
        const i = e[1] || n;
        const r = e[3] || i;
        return { top: n, bottom: o, right: i, left: r };
      }
      function yA(t) {
        return e => {
          const { top: n, right: o, bottom: i, left: r } = e;
          const s = [];
          if (![n, o, r, i].every(t => !!t)) {
            if (n) {
              s.push([t + '-top', n]);
            }
            if (o) {
              s.push([t + '-right', o]);
            }
            if (i) {
              s.push([t + '-bottom', i]);
            }
            if (r) {
              s.push([t + '-left', r]);
            }
          } else {
            s.push([t, xA(e)]);
          }
          return s;
        };
      }
      function xA({ top: t, right: e, bottom: n, left: o }) {
        const i = [];
        if (o !== e) {
          i.push(t, e, n, o);
        } else if (n !== t) {
          i.push(t, e, n);
        } else if (e !== t) {
          i.push(t, e);
        } else {
          i.push(t);
        }
        return i.join(' ');
      }
      function EA(t) {
        return e => ({ path: t, value: CA(e) });
      }
      function DA(t) {
        const e = t.matchAll(sA);
        return Array.from(e).map(t => t[0]);
      }
      function TA(t) {
        t.setNormalizer('background', SA());
        t.setNormalizer('background-color', PA());
        t.setReducer('background', BA());
        t.setStyleRelation('background', ['background-color']);
      }
      function SA() {
        return t => {
          const e = {};
          const n = getShorthandValues(t);
          for (const t of n) {
            if (isRepeat(t)) {
              e.repeat = e.repeat || [];
              e.repeat.push(t);
            } else if (isPosition(t)) {
              e.position = e.position || [];
              e.position.push(t);
            } else if (isAttachment(t)) {
              e.attachment = t;
            } else if (isColor(t)) {
              e.color = t;
            } else if (isURL(t)) {
              e.image = t;
            }
          }
          return { path: 'background', value: e };
        };
      }
      function PA() {
        return t => ({ path: 'background.color', value: t });
      }
      function BA() {
        return t => {
          const e = [];
          e.push(['background-color', t.color]);
          return e;
        };
      }
      function RA(t) {
        t.setNormalizer('border', OA());
        t.setNormalizer('border-top', IA('top'));
        t.setNormalizer('border-right', IA('right'));
        t.setNormalizer('border-bottom', IA('bottom'));
        t.setNormalizer('border-left', IA('left'));
        t.setNormalizer('border-color', MA('color'));
        t.setNormalizer('border-width', MA('width'));
        t.setNormalizer('border-style', MA('style'));
        t.setNormalizer('border-top-color', zA('color', 'top'));
        t.setNormalizer('border-top-style', zA('style', 'top'));
        t.setNormalizer('border-top-width', zA('width', 'top'));
        t.setNormalizer('border-right-color', zA('color', 'right'));
        t.setNormalizer('border-right-style', zA('style', 'right'));
        t.setNormalizer('border-right-width', zA('width', 'right'));
        t.setNormalizer('border-bottom-color', zA('color', 'bottom'));
        t.setNormalizer('border-bottom-style', zA('style', 'bottom'));
        t.setNormalizer('border-bottom-width', zA('width', 'bottom'));
        t.setNormalizer('border-left-color', zA('color', 'left'));
        t.setNormalizer('border-left-style', zA('style', 'left'));
        t.setNormalizer('border-left-width', zA('width', 'left'));
        t.setExtractor('border-top', FA('top'));
        t.setExtractor('border-right', FA('right'));
        t.setExtractor('border-bottom', FA('bottom'));
        t.setExtractor('border-left', FA('left'));
        t.setExtractor('border-top-color', 'border.color.top');
        t.setExtractor('border-right-color', 'border.color.right');
        t.setExtractor('border-bottom-color', 'border.color.bottom');
        t.setExtractor('border-left-color', 'border.color.left');
        t.setExtractor('border-top-width', 'border.width.top');
        t.setExtractor('border-right-width', 'border.width.right');
        t.setExtractor('border-bottom-width', 'border.width.bottom');
        t.setExtractor('border-left-width', 'border.width.left');
        t.setExtractor('border-top-style', 'border.style.top');
        t.setExtractor('border-right-style', 'border.style.right');
        t.setExtractor('border-bottom-style', 'border.style.bottom');
        t.setExtractor('border-left-style', 'border.style.left');
        t.setReducer('border-color', getBoxSidesValueReducer('border-color'));
        t.setReducer('border-style', getBoxSidesValueReducer('border-style'));
        t.setReducer('border-width', getBoxSidesValueReducer('border-width'));
        t.setReducer('border-top', jA('top'));
        t.setReducer('border-right', jA('right'));
        t.setReducer('border-bottom', jA('bottom'));
        t.setReducer('border-left', jA('left'));
        t.setReducer('border', HA());
        t.setStyleRelation('border', [
          'border-color',
          'border-style',
          'border-width',
          'border-top',
          'border-right',
          'border-bottom',
          'border-left',
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ]);
        t.setStyleRelation('border-color', [
          'border-top-color',
          'border-right-color',
          'border-bottom-color',
          'border-left-color',
        ]);
        t.setStyleRelation('border-style', [
          'border-top-style',
          'border-right-style',
          'border-bottom-style',
          'border-left-style',
        ]);
        t.setStyleRelation('border-width', [
          'border-top-width',
          'border-right-width',
          'border-bottom-width',
          'border-left-width',
        ]);
        t.setStyleRelation('border-top', [
          'border-top-color',
          'border-top-style',
          'border-top-width',
        ]);
        t.setStyleRelation('border-right', [
          'border-right-color',
          'border-right-style',
          'border-right-width',
        ]);
        t.setStyleRelation('border-bottom', [
          'border-bottom-color',
          'border-bottom-style',
          'border-bottom-width',
        ]);
        t.setStyleRelation('border-left', [
          'border-left-color',
          'border-left-style',
          'border-left-width',
        ]);
      }
      function OA() {
        return t => {
          const { color: e, style: n, width: o } = LA(t);
          return {
            path: 'border',
            value: {
              color: getBoxSidesValues(e),
              style: getBoxSidesValues(n),
              width: getBoxSidesValues(o),
            },
          };
        };
      }
      function IA(t) {
        return e => {
          const { color: n, style: o, width: i } = LA(e);
          const r = {};
          if (n !== undefined) {
            r.color = { [t]: n };
          }
          if (o !== undefined) {
            r.style = { [t]: o };
          }
          if (i !== undefined) {
            r.width = { [t]: i };
          }
          return { path: 'border', value: r };
        };
      }
      function MA(t) {
        return e => ({ path: 'border', value: VA(e, t) });
      }
      function VA(t, e) {
        return { [e]: getBoxSidesValues(t) };
      }
      function zA(t, e) {
        return n => ({ path: 'border', value: { [t]: { [e]: n } } });
      }
      function FA(t) {
        return (e, n) => {
          if (n.border) {
            return NA(n.border, t);
          }
        };
      }
      function NA(t, e) {
        const n = {};
        if (t.width && t.width[e]) {
          n.width = t.width[e];
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e];
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e];
        }
        return n;
      }
      function LA(t) {
        const e = {};
        const n = getShorthandValues(t);
        for (const t of n) {
          if (isLength(t) || /thin|medium|thick/.test(t)) {
            e.width = t;
          } else if (isLineStyle(t)) {
            e.style = t;
          } else {
            e.color = t;
          }
        }
        return e;
      }
      function HA() {
        return e => {
          const n = NA(e, 'top');
          const o = NA(e, 'right');
          const i = NA(e, 'bottom');
          const r = NA(e, 'left');
          const s = [n, o, i, r];
          const a = {
            width: t(s, 'width'),
            style: t(s, 'style'),
            color: t(s, 'color'),
          };
          const c = qA(a, 'all');
          if (c.length) {
            return c;
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([`border-${e}`, n]);
              s.forEach(t => delete t[e]);
            }
            return t;
          }, []);
          return [
            ...l,
            ...qA(n, 'top'),
            ...qA(o, 'right'),
            ...qA(i, 'bottom'),
            ...qA(r, 'left'),
          ];
        };
        function t(t, e) {
          return t.map(t => t[e]).reduce((t, e) => (t == e ? t : null));
        }
      }
      function jA(t) {
        return e => qA(e, t);
      }
      function qA(t, e) {
        const n = [];
        if (t && t.width) {
          n.push('width');
        }
        if (t && t.style) {
          n.push('style');
        }
        if (t && t.color) {
          n.push('color');
        }
        if (n.length == 3) {
          const o = n.map(e => t[e]).join(' ');
          return [e == 'all' ? ['border', o] : [`border-${e}`, o]];
        }
        if (e == 'all') {
          return [];
        }
        return n.map(n => [`border-${e}-${n}`, t[n]]);
      }
      function $A(t) {
        t.setNormalizer('margin', getPositionShorthandNormalizer('margin'));
        t.setNormalizer('margin-top', t => ({ path: 'margin.top', value: t }));
        t.setNormalizer('margin-right', t => ({
          path: 'margin.right',
          value: t,
        }));
        t.setNormalizer('margin-bottom', t => ({
          path: 'margin.bottom',
          value: t,
        }));
        t.setNormalizer('margin-left', t => ({
          path: 'margin.left',
          value: t,
        }));
        t.setReducer('margin', getBoxSidesValueReducer('margin'));
        t.setStyleRelation('margin', [
          'margin-top',
          'margin-right',
          'margin-bottom',
          'margin-left',
        ]);
      }
      function WA(t) {
        t.setNormalizer('padding', getPositionShorthandNormalizer('padding'));
        t.setNormalizer('padding-top', t => ({
          path: 'padding.top',
          value: t,
        }));
        t.setNormalizer('padding-right', t => ({
          path: 'padding.right',
          value: t,
        }));
        t.setNormalizer('padding-bottom', t => ({
          path: 'padding.bottom',
          value: t,
        }));
        t.setNormalizer('padding-left', t => ({
          path: 'padding.left',
          value: t,
        }));
        t.setReducer('padding', getBoxSidesValueReducer('padding'));
        t.setStyleRelation('padding', [
          'padding-top',
          'padding-right',
          'padding-bottom',
          'padding-left',
        ]);
      }
      class GA {
        constructor() {
          this._commands = new Map();
        }
        add(t, e) {
          this._commands.set(t, e);
        }
        get(t) {
          return this._commands.get(t);
        }
        execute(t, ...e) {
          const n = this.get(t);
          if (!n) {
            throw new B('commandcollection-command-not-found', this, {
              commandName: t,
            });
          }
          return n.execute(...e);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy();
          }
        }
      }
      class KA extends fl {
        constructor(t) {
          super();
          this.editor = t;
        }
        set(t, e, n = {}) {
          if (typeof e == 'string') {
            const t = e;
            e = (e, n) => {
              this.editor.execute(t);
              n();
            };
          }
          super.set(t, e, n);
        }
      }
      class UA extends dt() {
        constructor(t = {}) {
          super();
          const e = this.constructor;
          const n = t.language || (e.defaultConfig && e.defaultConfig.language);
          this._context = t.context || new Mh({ language: n });
          this._context._addEditor(this, !t.context);
          const o = Array.from(e.builtinPlugins || []);
          this.config = new ja(t, e.defaultConfig);
          this.config.define('plugins', o);
          this.config.define(this._context._getEditorConfig());
          this.plugins = new Ih(this, o, this._context.plugins);
          this.locale = this._context.locale;
          this.t = this.locale.t;
          this._readOnlyLocks = new Set();
          this.commands = new GA();
          this.set('state', 'initializing');
          this.once('ready', () => (this.state = 'ready'), {
            priority: 'high',
          });
          this.once('destroy', () => (this.state = 'destroyed'), {
            priority: 'high',
          });
          this.model = new Jv();
          this.on('change:isReadOnly', () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const i = new tp();
          this.data = new l_(this.model, i);
          this.editing = new Ow(this.model, i);
          this.editing.view.document.bind('isReadOnly').to(this);
          this.conversion = new h_(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher,
          );
          this.conversion.addAlias(
            'dataDowncast',
            this.data.downcastDispatcher,
          );
          this.conversion.addAlias(
            'editingDowncast',
            this.editing.downcastDispatcher,
          );
          this.keystrokes = new KA(this);
          this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(t) {
          throw new B('editor-isreadonly-has-no-setter');
        }
        enableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new B('editor-read-only-lock-id-invalid', null, {
              lockId: t,
            });
          }
          if (this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.add(t);
          if (this._readOnlyLocks.size === 1) {
            this.fire('change:isReadOnly', 'isReadOnly', true, false);
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== 'string' && typeof t !== 'symbol') {
            throw new B('editor-read-only-lock-id-invalid', null, {
              lockId: t,
            });
          }
          if (!this._readOnlyLocks.has(t)) {
            return;
          }
          this._readOnlyLocks.delete(t);
          if (this._readOnlyLocks.size === 0) {
            this.fire('change:isReadOnly', 'isReadOnly', false, true);
          }
        }
        initPlugins() {
          const t = this.config;
          const e = t.get('plugins');
          const n = t.get('removePlugins') || [];
          const o = t.get('extraPlugins') || [];
          const i = t.get('substitutePlugins') || [];
          return this.plugins.init(e.concat(o), n, i);
        }
        destroy() {
          let t = Promise.resolve();
          if (this.state == 'initializing') {
            t = new Promise(t => this.once('ready', t));
          }
          return t
            .then(() => {
              this.fire('destroy');
              this.stopListening();
              this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this));
        }
        execute(t, ...e) {
          try {
            return this.commands.execute(t, ...e);
          } catch (t) {
            B.rethrowUnexpectedError(t, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...t) {
          throw new Error('This is an abstract method.');
        }
      }
      function ZA(t) {
        if (!$e(t.updateSourceElement)) {
          throw new B('attachtoform-missing-elementapi-interface', t);
        }
        const e = t.sourceElement;
        if (JA(e) && e.form) {
          let n;
          const o = e.form;
          const i = () => t.updateSourceElement();
          if ($e(o.submit)) {
            n = o.submit;
            o.submit = () => {
              i();
              n.apply(o);
            };
          }
          o.addEventListener('submit', i);
          t.on('destroy', () => {
            o.removeEventListener('submit', i);
            if (n) {
              o.submit = n;
            }
          });
        }
      }
      function JA(t) {
        return !!t && t.tagName.toLowerCase() === 'textarea';
      }
      function YA(t) {
        class e extends t {
          setData(t) {
            this.data.set(t);
          }
          getData(t) {
            return this.data.get(t);
          }
        }
        return e;
      }
      {
        const t = YA(Object);
        YA.setData = t.prototype.setData;
        YA.getData = t.prototype.getData;
      }
      function QA(t) {
        class e extends t {
          updateSourceElement(t) {
            if (!this.sourceElement) {
              throw new B('editor-missing-sourceelement', this);
            }
            const e = this.config.get('updateSourceElementOnDestroy');
            const n = this.sourceElement instanceof HTMLTextAreaElement;
            if (!e && !n) {
              mc(this.sourceElement, '');
              return;
            }
            const o = typeof t === 'string' ? t : this.data.get();
            mc(this.sourceElement, o);
          }
        }
        return e;
      }
      QA.updateSourceElement = QA(Object).prototype.updateSourceElement;
      function XA(t, e) {
        if (e.ckeditorInstance) {
          throw new CKEditorError('editor-source-element-already-used', t);
        }
        e.ckeditorInstance = t;
        t.once('destroy', () => {
          delete e.ckeditorInstance;
        });
      }
      class tC extends Vh {
        static get pluginName() {
          return 'PendingActions';
        }
        init() {
          this.set('hasAny', false);
          this._actions = new dl({ idProperty: '_id' });
          this._actions.delegate('add', 'remove').to(this);
        }
        add(t) {
          if (typeof t !== 'string') {
            throw new B('pendingactions-add-invalid-message', this);
          }
          const e = new (dt())();
          e.set('message', t);
          this._actions.add(e);
          this.hasAny = true;
          return e;
        }
        remove(t) {
          this._actions.remove(t);
          this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const eC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
      const nC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
      const oC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
      const iC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
      const rC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
      const sC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
      const aC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
      const cC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 10.5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1H1Zm5.006 7.25-.221-.74h-1.84l-.22.74H2l1.915-5.25h1.961l1.916 5.25H6.006Zm-1.71-1.915h1.138l-.55-1.87h-.03l-.557 1.87ZM8.772 12.5h1.686v3.907h2.694v1.343h-4.38V12.5Zm8.067 5.25v-3.907h1.717V12.5h-5.128v1.343h1.725v3.907h1.686Z"/><path d="M8.013 7.326a.577.577 0 0 0-.797-.028L5.214 9.5h5.126L8.013 7.326ZM11.778 9.5h3.098l-1.015-1.197a.58.58 0 0 0-.788 0L11.778 9.5Zm4.364 0V1.83H3.858V9.5H2.5V1.45c0-.525.444-.95.996-.95h13.017c.543 0 .987.425.987.95V9.5h-1.358Zm-4.576-4.623a1.776 1.776 0 1 0 3.522-.462 1.776 1.776 0 0 0-3.522.462Z"/></svg>\n';
      const lC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>';
      const dC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
      const hC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
      const uC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
      const fC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
      const pC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const gC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
      const mC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
      const kC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
      const bC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const wC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
      const _C =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const vC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
      const AC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const CC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
      const yC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
      const xC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
      const EC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
      const DC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
      const TC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
      const SC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
      const PC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
      const BC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
      const RC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      const OC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';
      const IC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
      const MC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
      const VC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
      const zC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>';
      const FC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';
      const NC = {
        bold: IC,
        cancel: eC,
        caption: nC,
        check: oC,
        cog: iC,
        eraser: rC,
        history: sC,
        image: dC,
        lowVision: aC,
        textAlternative: cC,
        loupe: lC,
        importExport: FC,
        paragraph: MC,
        plus: VC,
        text: zC,
        alignBottom: hC,
        alignMiddle: uC,
        alignTop: fC,
        alignLeft: pC,
        alignCenter: gC,
        alignRight: mC,
        alignJustify: kC,
        objectLeft: CC,
        objectCenter: wC,
        objectRight: yC,
        objectFullWidth: vC,
        objectInline: AC,
        objectBlockLeft: bC,
        objectBlockRight: _C,
        objectSizeFull: xC,
        objectSizeLarge: EC,
        objectSizeSmall: DC,
        objectSizeMedium: TC,
        pencil: SC,
        pilcrow: PC,
        quote: BC,
        threeVerticalDots: RC,
        dragIndicator: OC,
      };
      var LC = n(768);
      var HC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      HC.insert = 'head';
      HC.singleton = true;
      var jC = Bl()(LC.Z, HC);
      const qC = LC.Z.locals || {};
      const { threeVerticalDots: $C } = NC;
      const WC = {
        alignLeft: NC.alignLeft,
        bold: NC.bold,
        importExport: NC.importExport,
        paragraph: NC.paragraph,
        plus: NC.plus,
        text: NC.text,
        threeVerticalDots: NC.threeVerticalDots,
        pilcrow: NC.pilcrow,
        dragIndicator: NC.dragIndicator,
      };
      class GC extends Vl {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          const o = this.t;
          this.options = e || {};
          this.set('ariaLabel', o('Editor toolbar'));
          this.set('maxWidth', 'auto');
          this.items = this.createCollection();
          this.focusTracker = new ul();
          this.keystrokes = new fl();
          this.set('class', undefined);
          this.set('isCompact', false);
          this.itemsView = new KC(t);
          this.children = this.createCollection();
          this.children.add(this.itemsView);
          this.focusables = this.createCollection();
          const i = t.uiLanguageDirection === 'rtl';
          this._focusCycler = new Ch({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [i ? 'arrowright' : 'arrowleft', 'arrowup'],
              focusNext: [i ? 'arrowleft' : 'arrowright', 'arrowdown'],
            },
          });
          const r = [
            'ck',
            'ck-toolbar',
            n.to('class'),
            n.if('isCompact', 'ck-toolbar_compact'),
          ];
          if (this.options.shouldGroupWhenFull && this.options.isFloating) {
            r.push('ck-toolbar_floating');
          }
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: r,
              role: 'toolbar',
              'aria-label': n.to('ariaLabel'),
              style: { maxWidth: n.to('maxWidth') },
              tabindex: -1,
            },
            children: this.children,
            on: { mousedown: Dh(this) },
          });
          this._behavior = this.options.shouldGroupWhenFull
            ? new ZC(this)
            : new UC(this);
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on('add', (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on('remove', (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          this._behavior.render(this);
        }
        destroy() {
          this._behavior.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
          return super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t, e, n) {
          this.items.addMany(this._buildItemsFromConfig(t, e, n));
        }
        _buildItemsFromConfig(t, e, n) {
          const o = Th(t);
          const i = n || o.removeItems;
          const r = this._cleanItemsConfiguration(o.items, e, i)
            .map(t => {
              if (ot(t)) {
                return this._createNestedToolbarDropdown(t, e, i);
              } else if (t === '|') {
                return new xh();
              } else if (t === '-') {
                return new Eh();
              }
              return e.create(t);
            })
            .filter(t => !!t);
          return r;
        }
        _cleanItemsConfiguration(t, e, n) {
          const o = t.filter((t, o, i) => {
            if (t === '|') {
              return true;
            }
            if (n.indexOf(t) !== -1) {
              return false;
            }
            if (t === '-') {
              if (this.options.shouldGroupWhenFull) {
                R('toolbarview-line-break-ignored-when-grouping-items', i);
                return false;
              }
              return true;
            }
            if (!ot(t) && !e.has(t)) {
              R('toolbarview-item-unavailable', { item: t });
              return false;
            }
            return true;
          });
          return this._cleanSeparatorsAndLineBreaks(o);
        }
        _cleanSeparatorsAndLineBreaks(t) {
          const e = t => t !== '-' && t !== '|';
          const n = t.length;
          const o = t.findIndex(e);
          if (o === -1) {
            return [];
          }
          const i = n - t.slice().reverse().findIndex(e);
          return t.slice(o, i).filter((t, n, o) => {
            if (e(t)) {
              return true;
            }
            const i = n > 0 && o[n - 1] === t;
            return !i;
          });
        }
        _createNestedToolbarDropdown(t, e, n) {
          let {
            label: o,
            icon: i,
            items: r,
            tooltip: s = true,
            withText: a = false,
          } = t;
          r = this._cleanItemsConfiguration(r, e, n);
          if (!r.length) {
            return null;
          }
          const c = this.locale;
          const l = ky(c);
          if (!o) {
            R('toolbarview-nested-toolbar-dropdown-missing-label', t);
          }
          l.class = 'ck-toolbar__nested-toolbar-dropdown';
          l.buttonView.set({ label: o, tooltip: s, withText: !!a });
          if (i !== false) {
            l.buttonView.icon = WC[i] || i || $C;
          } else {
            l.buttonView.withText = true;
          }
          by(l, () => l.toolbarView._buildItemsFromConfig(r, e, n));
          return l;
        }
      }
      class KC extends Vl {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-toolbar__items'] },
            children: this.children,
          });
        }
      }
      class UC {
        constructor(t) {
          const e = t.bindTemplate;
          t.set('isVertical', false);
          t.itemsView.children.bindTo(t.items).using(t => t);
          t.focusables.bindTo(t.items).using(t => t);
          t.extendTemplate({
            attributes: { class: [e.if('isVertical', 'ck-toolbar_vertical')] },
          });
        }
        render() {}
        destroy() {}
      }
      class ZC {
        constructor(t) {
          this.resizeObserver = null;
          this.cachedPadding = null;
          this.shouldUpdateGroupingOnNextResize = false;
          this.view = t;
          this.viewChildren = t.children;
          this.viewFocusables = t.focusables;
          this.viewItemsView = t.itemsView;
          this.viewFocusTracker = t.focusTracker;
          this.viewLocale = t.locale;
          this.ungroupedItems = t.createCollection();
          this.groupedItems = t.createCollection();
          this.groupedItemsDropdown = this._createGroupedItemsDropdown();
          t.itemsView.children.bindTo(this.ungroupedItems).using(t => t);
          this.ungroupedItems.on(
            'change',
            this._updateFocusCycleableItems.bind(this),
          );
          t.children.on('change', this._updateFocusCycleableItems.bind(this));
          t.items.on('change', (t, e) => {
            const n = e.index;
            const o = Array.from(e.added);
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t);
              } else {
                this.ungroupedItems.remove(t);
              }
            }
            for (let t = n; t < n + o.length; t++) {
              const e = o[t - n];
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(e, t - this.ungroupedItems.length);
              } else {
                this.ungroupedItems.add(e, t);
              }
            }
            this._updateGrouping();
          });
          t.extendTemplate({ attributes: { class: ['ck-toolbar_grouping'] } });
        }
        render(t) {
          this.viewElement = t.element;
          this._enableGroupingOnResize();
          this._enableGroupingOnMaxWidthChange(t);
        }
        destroy() {
          this.groupedItemsDropdown.destroy();
          this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return;
          }
          if (!Ac(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true;
            return;
          }
          const t = this.groupedItems.length;
          let e;
          while (this._areItemsOverflowing) {
            this._groupLastItem();
            e = true;
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem();
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem();
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire('groupedItemsUpdate');
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false;
          }
          const t = this.viewElement;
          const e = this.viewLocale.uiLanguageDirection;
          const n = new cc(t.lastChild);
          const o = new cc(t);
          if (!this.cachedPadding) {
            const n = Xa.window.getComputedStyle(t);
            const o = e === 'ltr' ? 'paddingRight' : 'paddingLeft';
            this.cachedPadding = Number.parseInt(n[o]);
          }
          if (e === 'ltr') {
            return n.right > o.right - this.cachedPadding;
          } else {
            return n.left < o.left + this.cachedPadding;
          }
        }
        _enableGroupingOnResize() {
          let t;
          this.resizeObserver = new gc(this.viewElement, e => {
            if (
              !t ||
              t !== e.contentRect.width ||
              this.shouldUpdateGroupingOnNextResize
            ) {
              this.shouldUpdateGroupingOnNextResize = false;
              this._updateGrouping();
              t = e.contentRect.width;
            }
          });
          this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on('change:maxWidth', () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new xh());
            this.viewChildren.add(this.groupedItemsDropdown);
            this.viewFocusTracker.add(this.groupedItemsDropdown.element);
          }
          this.groupedItems.add(
            this.ungroupedItems.remove(this.ungroupedItems.last),
            0,
          );
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(
            this.groupedItems.remove(this.groupedItems.first),
          );
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown);
            this.viewChildren.remove(this.viewChildren.last);
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale;
          const e = t.t;
          const n = ky(t);
          n.class = 'ck-toolbar__grouped-dropdown';
          n.panelPosition = t.uiLanguageDirection === 'ltr' ? 'sw' : 'se';
          by(n, this.groupedItems);
          n.buttonView.set({
            label: e('Show more items'),
            tooltip: true,
            tooltipPosition: t.uiLanguageDirection === 'rtl' ? 'se' : 'sw',
            icon: $C,
          });
          return n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear();
          this.ungroupedItems.map(t => {
            this.viewFocusables.add(t);
          });
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
      }
      class JC extends Vl {
        constructor(t, e = new Ud()) {
          super(t);
          const n = this.bindTemplate;
          const o = new ey(t);
          this.set({ label: '', isVisible: true });
          this.labelView = e;
          this.labelView.bind('text').to(this, 'label');
          this.children = this.createCollection();
          this.children.addMany([this.labelView, o]);
          o.set({ role: 'group', ariaLabelledBy: e.id });
          o.focusTracker.destroy();
          o.keystrokes.destroy();
          this.items = o.items;
          this.setTemplate({
            tag: 'li',
            attributes: {
              role: 'presentation',
              class: [
                'ck',
                'ck-list__group',
                n.if('isVisible', 'ck-hidden', t => !t),
              ],
            },
            children: this.children,
          });
        }
        focus() {
          if (this.items.first) {
            this.items.first.focus();
          }
        }
      }
      var YC = n(179);
      var QC = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      QC.insert = 'head';
      QC.singleton = true;
      var XC = Bl()(YC.Z, QC);
      const ty = YC.Z.locals || {};
      class ey extends Vl {
        constructor(t) {
          super(t);
          this._listItemGroupToChangeListeners = new WeakMap();
          const e = this.bindTemplate;
          this.focusables = new Tl();
          this.items = this.createCollection();
          this.focusTracker = new ul();
          this.keystrokes = new fl();
          this._focusCycler = new Ch({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'arrowup', focusNext: 'arrowdown' },
          });
          this.set('ariaLabel', undefined);
          this.set('ariaLabelledBy', undefined);
          this.set('role', undefined);
          this.setTemplate({
            tag: 'ul',
            attributes: {
              class: ['ck', 'ck-reset', 'ck-list'],
              role: e.to('role'),
              'aria-label': e.to('ariaLabel'),
              'aria-labelledby': e.to('ariaLabelledBy'),
            },
            children: this.items,
          });
        }
        render() {
          super.render();
          for (const t of this.items) {
            if (t instanceof JC) {
              this._registerFocusableItemsGroup(t);
            } else {
              this._registerFocusableListItem(t);
            }
          }
          this.items.on('change', (t, e) => {
            for (const t of e.removed) {
              if (t instanceof JC) {
                this._deregisterFocusableItemsGroup(t);
              } else {
                this._deregisterFocusableListItem(t);
              }
            }
            for (const t of Array.from(e.added).reverse()) {
              if (t instanceof JC) {
                this._registerFocusableItemsGroup(t, e.index);
              } else {
                this._registerFocusableListItem(t, e.index);
              }
            }
          });
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        _registerFocusableListItem(t, e) {
          this.focusTracker.add(t.element);
          this.focusables.add(t, e);
        }
        _deregisterFocusableListItem(t) {
          this.focusTracker.remove(t.element);
          this.focusables.remove(t);
        }
        _getOnGroupItemsChangeCallback(t) {
          return (e, n) => {
            for (const t of n.removed) {
              this._deregisterFocusableListItem(t);
            }
            for (const e of Array.from(n.added).reverse()) {
              this._registerFocusableListItem(
                e,
                this.items.getIndex(t) + n.index,
              );
            }
          };
        }
        _registerFocusableItemsGroup(t, e) {
          Array.from(t.items).forEach((t, n) => {
            const o = typeof e !== 'undefined' ? e + n : undefined;
            this._registerFocusableListItem(t, o);
          });
          const n = this._getOnGroupItemsChangeCallback(t);
          this._listItemGroupToChangeListeners.set(t, n);
          t.items.on('change', n);
        }
        _deregisterFocusableItemsGroup(t) {
          for (const e of t.items) {
            this._deregisterFocusableListItem(e);
          }
          t.items.off('change', this._listItemGroupToChangeListeners.get(t));
          this._listItemGroupToChangeListeners.delete(t);
        }
      }
      class ny extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isVisible', true);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'li',
            attributes: {
              class: [
                'ck',
                'ck-list__item',
                e.if('isVisible', 'ck-hidden', t => !t),
              ],
              role: 'presentation',
            },
            children: this.children,
          });
        }
        focus() {
          if (this.children.first) {
            this.children.first.focus();
          }
        }
      }
      class oy extends (null && View) {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'li',
            attributes: { class: ['ck', 'ck-list__separator'] },
          });
        }
      }
      var iy = n(791);
      var ry = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      ry.insert = 'head';
      ry.singleton = true;
      var sy = Bl()(iy.Z, ry);
      const ay = iy.Z.locals || {};
      class cy extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('class', undefined);
          this.set('labelStyle', undefined);
          this.set('icon', undefined);
          this.set('isEnabled', true);
          this.set('isOn', false);
          this.set('isToggleable', false);
          this.set('isVisible', true);
          this.set('keystroke', undefined);
          this.set('withKeystroke', false);
          this.set('label', undefined);
          this.set('tabindex', -1);
          this.set('tooltip', false);
          this.set('tooltipPosition', 's');
          this.set('type', 'button');
          this.set('withText', false);
          this.children = this.createCollection();
          this.actionView = this._createActionView();
          this.arrowView = this._createArrowView();
          this.keystrokes = new fl();
          this.focusTracker = new ul();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-splitbutton',
                e.to('class'),
                e.if('isVisible', 'ck-hidden', t => !t),
                this.arrowView.bindTemplate.if('isOn', 'ck-splitbutton_open'),
              ],
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.add(this.actionView);
          this.children.add(this.arrowView);
          this.focusTracker.add(this.actionView.element);
          this.focusTracker.add(this.arrowView.element);
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set('arrowright', (t, e) => {
            if (this.focusTracker.focusedElement === this.actionView.element) {
              this.arrowView.focus();
              e();
            }
          });
          this.keystrokes.set('arrowleft', (t, e) => {
            if (this.focusTracker.focusedElement === this.arrowView.element) {
              this.actionView.focus();
              e();
            }
          });
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const t = new Ad();
          t.bind(
            'icon',
            'isEnabled',
            'isOn',
            'isToggleable',
            'keystroke',
            'label',
            'tabindex',
            'tooltip',
            'tooltipPosition',
            'type',
            'withText',
          ).to(this);
          t.extendTemplate({ attributes: { class: 'ck-splitbutton__action' } });
          t.delegate('execute').to(this);
          return t;
        }
        _createArrowView() {
          const t = new Ad();
          const e = t.bindTemplate;
          t.icon = vh;
          t.extendTemplate({
            attributes: {
              class: ['ck-splitbutton__arrow'],
              'data-cke-tooltip-disabled': e.to('isOn'),
              'aria-haspopup': true,
              'aria-expanded': e.to('isOn', t => String(t)),
            },
          });
          t.bind('isEnabled').to(this);
          t.bind('label').to(this);
          t.bind('tooltip').to(this);
          t.delegate('execute').to(this, 'open');
          return t;
        }
      }
      var ly = n(704);
      var dy = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      dy.insert = 'head';
      dy.singleton = true;
      var hy = Bl()(ly.Z, dy);
      const uy = ly.Z.locals || {};
      var fy = n(883);
      var py = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      py.insert = 'head';
      py.singleton = true;
      var gy = Bl()(fy.Z, py);
      const my = fy.Z.locals || {};
      function ky(t, e = Ah) {
        const n = new e(t);
        const o = new gh(t);
        const i = new _h(t, n, o);
        n.bind('isEnabled').to(i);
        if (n instanceof cy) {
          n.arrowView.bind('isOn').to(i, 'isOpen');
        } else {
          n.bind('isOn').to(i, 'isOpen');
        }
        Cy(i);
        return i;
      }
      function by(t, e, n = {}) {
        t.extendTemplate({ attributes: { class: ['ck-toolbar-dropdown'] } });
        if (t.isOpen) {
          wy(t, e, n);
        } else {
          t.once('change:isOpen', () => wy(t, e, n), { priority: 'highest' });
        }
        if (n.enableActiveItemFocusOnDropdownOpen) {
          Ay(t, () => t.toolbarView.items.find(t => t.isOn));
        }
      }
      function wy(t, e, n) {
        const o = t.locale;
        const i = o.t;
        const r = (t.toolbarView = new GC(o));
        const s = typeof e == 'function' ? e() : e;
        r.ariaLabel = n.ariaLabel || i('Dropdown toolbar');
        if (n.maxWidth) {
          r.maxWidth = n.maxWidth;
        }
        if (n.class) {
          r.class = n.class;
        }
        if (n.isCompact) {
          r.isCompact = n.isCompact;
        }
        if (n.isVertical) {
          r.isVertical = true;
        }
        if (s instanceof Tl) {
          r.items.bindTo(s).using(t => t);
        } else {
          r.items.addMany(s);
        }
        t.panelView.children.add(r);
        r.items.delegate('execute').to(t);
      }
      function _y(t, e, n = {}) {
        if (t.isOpen) {
          vy(t, e, n);
        } else {
          t.once('change:isOpen', () => vy(t, e, n), { priority: 'highest' });
        }
        Ay(t, () =>
          t.listView.items.find(t => {
            if (t instanceof ListItemView) {
              return t.children.first.isOn;
            }
            return false;
          }),
        );
      }
      function vy(t, e, n) {
        const o = t.locale;
        const i = (t.listView = new ListView(o));
        const r = typeof e == 'function' ? e() : e;
        i.ariaLabel = n.ariaLabel;
        i.role = n.role;
        Py(t, i.items, r, o);
        t.panelView.children.add(i);
        i.items.delegate('execute').to(t);
      }
      function Ay(t, e) {
        t.on(
          'change:isOpen',
          () => {
            if (!t.isOpen) {
              return;
            }
            const n = e();
            if (!n) {
              return;
            }
            if (typeof n.focus === 'function') {
              n.focus();
            } else {
              R('ui-dropdown-focus-child-on-open-child-missing-focus', {
                view: n,
              });
            }
          },
          { priority: T.low - 10 },
        );
      }
      function Cy(t) {
        yy(t);
        xy(t);
        Ey(t);
        Dy(t);
        Ty(t);
        Sy(t);
      }
      function yy(e) {
        e.on('render', () => {
          t({
            emitter: e,
            activator: () => e.isOpen,
            callback: () => {
              e.isOpen = false;
            },
            contextElements: () => [e.element, ...e.focusTracker._elements],
          });
        });
      }
      function xy(t) {
        t.on('execute', e => {
          if (e.source instanceof Dd) {
            return;
          }
          t.isOpen = false;
        });
      }
      function Ey(t) {
        t.focusTracker.on('change:isFocused', (e, n, o) => {
          if (t.isOpen && !o) {
            t.isOpen = false;
          }
        });
      }
      function Dy(t) {
        t.keystrokes.set('arrowdown', (e, n) => {
          if (t.isOpen) {
            t.panelView.focus();
            n();
          }
        });
        t.keystrokes.set('arrowup', (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast();
            n();
          }
        });
      }
      function Ty(t) {
        t.on('change:isOpen', (e, n, o) => {
          if (o) {
            return;
          }
          const i = t.panelView.element;
          if (i && i.contains(Xa.document.activeElement)) {
            t.buttonView.focus();
          }
        });
      }
      function Sy(t) {
        t.on(
          'change:isOpen',
          (e, n, o) => {
            if (!o) {
              return;
            }
            t.panelView.focus();
          },
          { priority: 'low' },
        );
      }
      function Py(t, e, n, o) {
        e.bindTo(n).using(e => {
          if (e.type === 'separator') {
            return new ListSeparatorView(o);
          } else if (e.type === 'group') {
            const n = new ListItemGroupView(o);
            n.set({ label: e.label });
            Py(t, n.items, e.items, o);
            n.items.delegate('execute').to(t);
            return n;
          } else if (e.type === 'button' || e.type === 'switchbutton') {
            const t = new ListItemView(o);
            let n;
            if (e.type === 'button') {
              n = new ButtonView(o);
              n.extendTemplate({
                attributes: { 'aria-checked': n.bindTemplate.to('isOn') },
              });
            } else {
              n = new SwitchButtonView(o);
            }
            n.bind(...Object.keys(e.model)).to(e.model);
            n.delegate('execute').to(t);
            t.children.add(n);
            return t;
          }
          return null;
        });
      }
      const By = (t, e, n) => {
        const o = new ah(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind('isReadOnly').to(t, 'isEnabled', t => !t);
        o.bind('hasError').to(t, 'errorText', t => !!t);
        o.on('input', () => {
          t.errorText = null;
        });
        t.bind('isEmpty', 'isFocused', 'placeholder').to(o);
        return o;
      };
      const Ry = (t, e, n) => {
        const o = new InputNumberView(t.locale);
        o.set({ id: e, ariaDescribedById: n, inputMode: 'numeric' });
        o.bind('isReadOnly').to(t, 'isEnabled', t => !t);
        o.bind('hasError').to(t, 'errorText', t => !!t);
        o.on('input', () => {
          t.errorText = null;
        });
        t.bind('isEmpty', 'isFocused', 'placeholder').to(o);
        return o;
      };
      const Oy = (t, e, n) => {
        const o = new TextareaView(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind('isReadOnly').to(t, 'isEnabled', t => !t);
        o.bind('hasError').to(t, 'errorText', t => !!t);
        o.on('input', () => {
          t.errorText = null;
        });
        t.bind('isEmpty', 'isFocused', 'placeholder').to(o);
        return o;
      };
      const Iy = (t, e, n) => {
        const o = createDropdown(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind('isEnabled').to(t);
        return o;
      };
      const My = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t);
      const Vy = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n;
      const zy = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) };
      const Fy = t => rx(Ny(t));
      const Ny = t => {
        if (t[0] === '#') t = t.substring(1);
        if (t.length < 6) {
          return {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: t.length === 4 ? Vy(parseInt(t[3] + t[3], 16) / 255, 2) : 1,
          };
        }
        return {
          r: parseInt(t.substring(0, 2), 16),
          g: parseInt(t.substring(2, 4), 16),
          b: parseInt(t.substring(4, 6), 16),
          a: t.length === 8 ? Vy(parseInt(t.substring(6, 8), 16) / 255, 2) : 1,
        };
      };
      const Ly = (t, e = 'deg') => Number(t) * (zy[e] || 1);
      const Hy = t => {
        const e =
          /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return qy({
          h: Ly(n[1], n[2]),
          s: Number(n[3]),
          l: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        });
      };
      const jy = null && Hy;
      const qy = ({ h: t, s: e, l: n, a: o }) => {
        e *= (n < 50 ? n : 100 - n) / 100;
        return {
          h: t,
          s: e > 0 ? ((2 * e) / (n + e)) * 100 : 0,
          v: n + e,
          a: o,
        };
      };
      const $y = t => ix(Jy(t));
      const Wy = ({ h: t, s: e, v: n, a: o }) => {
        const i = ((200 - e) * n) / 100;
        return {
          h: Vy(t),
          s: Vy(
            i > 0 && i < 200
              ? ((e * n) / 100 / (i <= 100 ? i : 200 - i)) * 100
              : 0,
          ),
          l: Vy(i / 2),
          a: Vy(o, 2),
        };
      };
      const Gy = t => {
        const { h: e, s: n, v: o } = sx(t);
        return `hsv(${e}, ${n}%, ${o}%)`;
      };
      const Ky = t => {
        const { h: e, s: n, v: o, a: i } = sx(t);
        return `hsva(${e}, ${n}%, ${o}%, ${i})`;
      };
      const Uy = t => {
        const { h: e, s: n, l: o } = Wy(t);
        return `hsl(${e}, ${n}%, ${o}%)`;
      };
      const Zy = t => {
        const { h: e, s: n, l: o, a: i } = Wy(t);
        return `hsla(${e}, ${n}%, ${o}%, ${i})`;
      };
      const Jy = ({ h: t, s: e, v: n, a: o }) => {
        t = (t / 360) * 6;
        e = e / 100;
        n = n / 100;
        const i = Math.floor(t),
          r = n * (1 - e),
          s = n * (1 - (t - i) * e),
          a = n * (1 - (1 - t + i) * e),
          c = i % 6;
        return {
          r: Vy([n, s, r, r, a, n][c] * 255),
          g: Vy([a, n, n, s, r, r][c] * 255),
          b: Vy([r, r, a, n, n, s][c] * 255),
          a: Vy(o, 2),
        };
      };
      const Yy = t => {
        const { r: e, g: n, b: o } = Jy(t);
        return `rgb(${e}, ${n}, ${o})`;
      };
      const Qy = t => {
        const { r: e, g: n, b: o, a: i } = Jy(t);
        return `rgba(${e}, ${n}, ${o}, ${i})`;
      };
      const Xy = t => {
        const e =
          /hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return sx({
          h: Ly(n[1], n[2]),
          s: Number(n[3]),
          v: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        });
      };
      const tx = null && Xy;
      const ex = t => {
        const e =
          /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
        const n = e.exec(t);
        if (!n) return { h: 0, s: 0, v: 0, a: 1 };
        return rx({
          r: Number(n[1]) / (n[2] ? 100 / 255 : 1),
          g: Number(n[3]) / (n[4] ? 100 / 255 : 1),
          b: Number(n[5]) / (n[6] ? 100 / 255 : 1),
          a: n[7] === undefined ? 1 : Number(n[7]) / (n[8] ? 100 : 1),
        });
      };
      const nx = null && ex;
      const ox = t => {
        const e = t.toString(16);
        return e.length < 2 ? '0' + e : e;
      };
      const ix = ({ r: t, g: e, b: n, a: o }) => {
        const i = o < 1 ? ox(Vy(o * 255)) : '';
        return '#' + ox(t) + ox(e) + ox(n) + i;
      };
      const rx = ({ r: t, g: e, b: n, a: o }) => {
        const i = Math.max(t, e, n);
        const r = i - Math.min(t, e, n);
        const s = r
          ? i === t
            ? (e - n) / r
            : i === e
            ? 2 + (n - t) / r
            : 4 + (t - e) / r
          : 0;
        return {
          h: Vy(60 * (s < 0 ? s + 6 : s)),
          s: Vy(i ? (r / i) * 100 : 0),
          v: Vy((i / 255) * 100),
          a: o,
        };
      };
      const sx = t => ({
        h: round(t.h),
        s: round(t.s),
        v: round(t.v),
        a: round(t.a, 2),
      });
      const ax = ({ r: t, g: e, b: n }) => ({ r: t, g: e, b: n });
      const cx = ({ h: t, s: e, l: n }) => ({ h: t, s: e, l: n });
      const lx = t => {
        const { h: e, s: n, v: o } = sx(t);
        return { h: e, s: n, v: o };
      };
      const dx = (t, e) => {
        if (t === e) return true;
        for (const n in t) {
          if (t[n] !== e[n]) return false;
        }
        return true;
      };
      const hx = (t, e) => t.replace(/\s/g, '') === e.replace(/\s/g, '');
      const ux = (t, e) => {
        if (t.toLowerCase() === e.toLowerCase()) return true;
        return dx(Ny(t), Ny(e));
      };
      const fx = {};
      const px = t => {
        let e = fx[t];
        if (!e) {
          e = document.createElement('template');
          e.innerHTML = t;
          fx[t] = e;
        }
        return e;
      };
      const gx = (t, e, n) => {
        t.dispatchEvent(new CustomEvent(e, { bubbles: true, detail: n }));
      };
      let mx = false;
      const kx = t => 'touches' in t;
      const bx = t => {
        if (mx && !kx(t)) return false;
        if (!mx) mx = kx(t);
        return true;
      };
      const wx = (t, e) => {
        const n = kx(e) ? e.touches[0] : e;
        const o = t.el.getBoundingClientRect();
        gx(
          t.el,
          'move',
          t.getMove({
            x: My((n.pageX - (o.left + window.pageXOffset)) / o.width),
            y: My((n.pageY - (o.top + window.pageYOffset)) / o.height),
          }),
        );
      };
      const _x = (t, e) => {
        const n = e.keyCode;
        if (n > 40 || (t.xy && n < 37) || n < 33) return;
        e.preventDefault();
        gx(
          t.el,
          'move',
          t.getMove(
            {
              x:
                n === 39
                  ? 0.01
                  : n === 37
                  ? -0.01
                  : n === 34
                  ? 0.05
                  : n === 33
                  ? -0.05
                  : n === 35
                  ? 1
                  : n === 36
                  ? -1
                  : 0,
              y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0,
            },
            true,
          ),
        );
      };
      class vx {
        constructor(t, e, n, o) {
          const i = px(
            `<div role="slider" tabindex="0" part="${e}" ${n}><div part="${e}-pointer"></div></div>`,
          );
          t.appendChild(i.content.cloneNode(true));
          const r = t.querySelector(`[part=${e}]`);
          r.addEventListener('mousedown', this);
          r.addEventListener('touchstart', this);
          r.addEventListener('keydown', this);
          this.el = r;
          this.xy = o;
          this.nodes = [r.firstChild, r];
        }
        set dragging(t) {
          const e = t
            ? document.addEventListener
            : document.removeEventListener;
          e(mx ? 'touchmove' : 'mousemove', this);
          e(mx ? 'touchend' : 'mouseup', this);
        }
        handleEvent(t) {
          switch (t.type) {
            case 'mousedown':
            case 'touchstart':
              t.preventDefault();
              if (!bx(t) || (!mx && t.button != 0)) return;
              this.el.focus();
              wx(this, t);
              this.dragging = true;
              break;
            case 'mousemove':
            case 'touchmove':
              t.preventDefault();
              wx(this, t);
              break;
            case 'mouseup':
            case 'touchend':
              this.dragging = false;
              break;
            case 'keydown':
              _x(this, t);
              break;
          }
        }
        style(t) {
          t.forEach((t, e) => {
            for (const n in t) {
              this.nodes[e].style.setProperty(n, t[n]);
            }
          });
        }
      }
      class Ax extends vx {
        constructor(t) {
          super(
            t,
            'hue',
            'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"',
            false,
          );
        }
        update({ h: t }) {
          this.h = t;
          this.style([
            {
              left: `${(t / 360) * 100}%`,
              color: Uy({ h: t, s: 100, v: 100, a: 1 }),
            },
          ]);
          this.el.setAttribute('aria-valuenow', `${Vy(t)}`);
        }
        getMove(t, e) {
          return { h: e ? My(this.h + t.x * 360, 0, 360) : 360 * t.x };
        }
      }
      class Cx extends vx {
        constructor(t) {
          super(t, 'saturation', 'aria-label="Color"', true);
        }
        update(t) {
          this.hsva = t;
          this.style([
            { top: `${100 - t.v}%`, left: `${t.s}%`, color: Uy(t) },
            { 'background-color': Uy({ h: t.h, s: 100, v: 100, a: 1 }) },
          ]);
          this.el.setAttribute(
            'aria-valuetext',
            `Saturation ${Vy(t.s)}%, Brightness ${Vy(t.v)}%`,
          );
        }
        getMove(t, e) {
          return {
            s: e ? My(this.hsva.s + t.x * 100, 0, 100) : t.x * 100,
            v: e
              ? My(this.hsva.v - t.y * 100, 0, 100)
              : Math.round(100 - t.y * 100),
          };
        }
      }
      const yx = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;
      const xx = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;
      const Ex = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;
      const Dx = Symbol('same');
      const Tx = Symbol('color');
      const Sx = Symbol('hsva');
      const Px = Symbol('update');
      const Bx = Symbol('parts');
      const Rx = Symbol('css');
      const Ox = Symbol('sliders');
      class Ix extends HTMLElement {
        static get observedAttributes() {
          return ['color'];
        }
        get [Rx]() {
          return [yx, xx, Ex];
        }
        get [Ox]() {
          return [Cx, Ax];
        }
        get color() {
          return this[Tx];
        }
        set color(t) {
          if (!this[Dx](t)) {
            const e = this.colorModel.toHsva(t);
            this[Px](e);
            this[Tx] = t;
          }
        }
        constructor() {
          super();
          const t = px(`<style>${this[Rx].join('')}</style>`);
          const e = this.attachShadow({ mode: 'open' });
          e.appendChild(t.content.cloneNode(true));
          e.addEventListener('move', this);
          this[Bx] = this[Ox].map(t => new t(e));
        }
        connectedCallback() {
          if (this.hasOwnProperty('color')) {
            const t = this.color;
            delete this['color'];
            this.color = t;
          } else if (!this.color) {
            this.color = this.colorModel.defaultColor;
          }
        }
        attributeChangedCallback(t, e, n) {
          const o = this.colorModel.fromAttr(n);
          if (!this[Dx](o)) {
            this.color = o;
          }
        }
        handleEvent(t) {
          const e = this[Sx];
          const n = { ...e, ...t.detail };
          this[Px](n);
          let o;
          if (!dx(n, e) && !this[Dx]((o = this.colorModel.fromHsva(n)))) {
            this[Tx] = o;
            gx(this, 'color-changed', { value: o });
          }
        }
        [Dx](t) {
          return this.color && this.colorModel.equal(t, this.color);
        }
        [Px](t) {
          this[Sx] = t;
          this[Bx].forEach(e => e.update(t));
        }
      }
      const Mx = {
        defaultColor: '#000',
        toHsva: Fy,
        fromHsva: ({ h: t, s: e, v: n }) => $y({ h: t, s: e, v: n, a: 1 }),
        equal: ux,
        fromAttr: t => t,
      };
      class Vx extends Ix {
        get colorModel() {
          return Mx;
        }
      }
      class zx extends Vx {}
      customElements.define('hex-color-picker', zx);
      var Fx = n(257);
      var Nx = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Nx.insert = 'head';
      Nx.singleton = true;
      var Lx = Bl()(Fx.Z, Nx);
      const Hx = Fx.Z.locals || {};
      const jx = 150;
      class qx extends (null && View) {
        constructor(t, e = {}) {
          super(t);
          this.set({ color: '', _hexColor: '' });
          this.hexInputRow = this._createInputRow();
          const n = this.createCollection();
          if (!e.hideInput) {
            n.add(this.hexInputRow);
          }
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-picker'], tabindex: -1 },
            children: n,
          });
          this._config = e;
          this._debounceColorPickerEvent = debounce(
            t => {
              this.set('color', t);
              this.fire('colorSelected', { color: this.color });
            },
            jx,
            { leading: true },
          );
          this.on('set:color', (t, e, n) => {
            t.return = convertColor(n, this._config.format || 'hsl');
          });
          this.on('change:color', () => {
            this._hexColor = $x(this.color);
          });
          this.on('change:_hexColor', () => {
            if (document.activeElement !== this.picker) {
              this.picker.setAttribute('color', this._hexColor);
            }
            if ($x(this.color) != $x(this._hexColor)) {
              this.color = this._hexColor;
            }
          });
        }
        render() {
          super.render();
          this.picker = global.document.createElement('hex-color-picker');
          this.picker.setAttribute('class', 'hex-color-picker');
          this.picker.setAttribute('tabindex', '-1');
          this._createSlidersView();
          if (this.element) {
            if (this.hexInputRow.element) {
              this.element.insertBefore(this.picker, this.hexInputRow.element);
            } else {
              this.element.appendChild(this.picker);
            }
            const t = document.createElement('style');
            t.textContent =
              '[role="slider"]:focus [part$="pointer"] {' +
              'border: 1px solid #fff;' +
              'outline: 1px solid var(--ck-color-focus-border);' +
              'box-shadow: 0 0 0 2px #fff;' +
              '}';
            this.picker.shadowRoot.appendChild(t);
          }
          this.picker.addEventListener('color-changed', t => {
            const e = t;
            const n = e.detail.value;
            this._debounceColorPickerEvent(n);
          });
        }
        focus() {
          if (
            !this._config.hideInput &&
            (env.isGecko || env.isiOS || env.isSafari)
          ) {
            const t = this.hexInputRow.children.get(1);
            t.focus();
          }
          const t = this.slidersView.first;
          t.focus();
        }
        _createSlidersView() {
          const t = [...this.picker.shadowRoot.children];
          const e = t.filter(t => t.getAttribute('role') === 'slider');
          const n = e.map(t => {
            const e = new Wx(t);
            return e;
          });
          this.slidersView = this.createCollection();
          n.forEach(t => {
            this.slidersView.add(t);
          });
        }
        _createInputRow() {
          const t = new Gx();
          const e = this._createColorInput();
          return new Kx(this.locale, [t, e]);
        }
        _createColorInput() {
          const t = new LabeledFieldView(this.locale, createLabeledInputText);
          const { t: e } = this.locale;
          t.set({ label: e('HEX'), class: 'color-picker-hex-input' });
          t.fieldView.bind('value').to(this, '_hexColor', e => {
            if (t.isFocused) {
              return t.fieldView.value;
            } else {
              return e.startsWith('#') ? e.substring(1) : e;
            }
          });
          t.fieldView.on('input', () => {
            const e = t.fieldView.element.value;
            if (e) {
              const t = e.trim();
              const n = t.startsWith('#') ? t.substring(1) : t;
              const o =
                [3, 4, 6, 8].includes(n.length) &&
                /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n);
              if (o) {
                this._debounceColorPickerEvent('#' + n);
              }
            }
          });
          return t;
        }
      }
      function $x(t) {
        let e = convertToHex(t);
        if (!e) {
          e = '#000';
        }
        if (e.length === 4) {
          e = '#' + [e[1], e[1], e[2], e[2], e[3], e[3]].join('');
        }
        return e.toLowerCase();
      }
      class Wx extends (null && View) {
        constructor(t) {
          super();
          this.element = t;
        }
        focus() {
          this.element.focus();
        }
      }
      class Gx extends (null && View) {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-picker__hash-view'] },
            children: '#',
          });
        }
      }
      class Kx extends (null && View) {
        constructor(t, e) {
          super(t);
          this.children = this.createCollection(e);
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-picker__row'] },
            children: this.children,
          });
        }
      }
      class Ux extends dt(dl) {
        constructor(t) {
          super(t);
          this.set('isEmpty', true);
          this.on('change', () => {
            this.set('isEmpty', this.length === 0);
          });
        }
        add(t, e) {
          if (this.find(e => e.color === t.color)) {
            return this;
          }
          return super.add(t, e);
        }
        hasColor(t) {
          return !!this.find(e => e.color === t);
        }
      }
      class Zx extends (null && View) {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: a,
            focusables: c,
          },
        ) {
          super(t);
          const l = this.bindTemplate;
          this.set('isVisible', true);
          this.focusTracker = a;
          this.items = this.createCollection();
          this.colorDefinitions = e;
          this.columns = n;
          this.documentColors = new DocumentColorCollection();
          this.documentColorsCount = r;
          this._focusables = c;
          this._removeButtonLabel = o;
          this._colorPickerLabel = s;
          this._documentColorsLabel = i;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck-color-grids-fragment',
                l.if('isVisible', 'ck-hidden', t => !t),
              ],
            },
            children: this.items,
          });
          this.removeColorButtonView = this._createRemoveColorButton();
          this.items.add(this.removeColorButtonView);
        }
        updateDocumentColors(t, e) {
          const n = t.document;
          const o = this.documentColorsCount;
          this.documentColors.clear();
          for (const i of n.getRoots()) {
            const n = t.createRangeIn(i);
            for (const t of n.getItems()) {
              if (t.is('$textProxy') && t.hasAttribute(e)) {
                this._addColorToDocumentColors(t.getAttribute(e));
                if (this.documentColors.length >= o) {
                  return;
                }
              }
            }
          }
        }
        updateSelectedColors() {
          const t = this.documentColorsGrid;
          const e = this.staticColorsGrid;
          const n = this.selectedColor;
          e.selectedColor = n;
          if (t) {
            t.selectedColor = n;
          }
        }
        render() {
          super.render();
          this.staticColorsGrid = this._createStaticColorsGrid();
          this.items.add(this.staticColorsGrid);
          if (this.documentColorsCount) {
            const t = Template.bind(this.documentColors, this.documentColors);
            const e = new LabelView(this.locale);
            e.text = this._documentColorsLabel;
            e.extendTemplate({
              attributes: {
                class: [
                  'ck',
                  'ck-color-grid__label',
                  t.if('isEmpty', 'ck-hidden'),
                ],
              },
            });
            this.items.add(e);
            this.documentColorsGrid = this._createDocumentColorsGrid();
            this.items.add(this.documentColorsGrid);
          }
          this._createColorPickerButton();
          this._addColorSelectorElementsToFocusTracker();
          this.focus();
        }
        focus() {
          this.removeColorButtonView.focus();
        }
        destroy() {
          super.destroy();
        }
        addColorPickerButton() {
          if (this.colorPickerButtonView) {
            this.items.add(this.colorPickerButtonView);
            this.focusTracker.add(this.colorPickerButtonView.element);
            this._focusables.add(this.colorPickerButtonView);
          }
        }
        _addColorSelectorElementsToFocusTracker() {
          this.focusTracker.add(this.removeColorButtonView.element);
          this._focusables.add(this.removeColorButtonView);
          if (this.staticColorsGrid) {
            this.focusTracker.add(this.staticColorsGrid.element);
            this._focusables.add(this.staticColorsGrid);
          }
          if (this.documentColorsGrid) {
            this.focusTracker.add(this.documentColorsGrid.element);
            this._focusables.add(this.documentColorsGrid);
          }
        }
        _createColorPickerButton() {
          this.colorPickerButtonView = new ButtonView();
          this.colorPickerButtonView.set({
            label: this._colorPickerLabel,
            withText: true,
            icon: colorPaletteIcon,
            class: 'ck-color-selector__color-picker',
          });
          this.colorPickerButtonView.on('execute', () => {
            this.fire('colorPicker:show');
          });
        }
        _createRemoveColorButton() {
          const t = new ButtonView();
          t.set({
            withText: true,
            icon: removeButtonIcon,
            label: this._removeButtonLabel,
          });
          t.class = 'ck-color-selector__remove-color';
          t.on('execute', () => {
            this.fire('execute', { value: null, source: 'removeColorButton' });
          });
          t.render();
          return t;
        }
        _createStaticColorsGrid() {
          const t = new ColorGridView(this.locale, {
            colorDefinitions: this.colorDefinitions,
            columns: this.columns,
          });
          t.on('execute', (t, e) => {
            this.fire('execute', {
              value: e.value,
              source: 'staticColorsGrid',
            });
          });
          return t;
        }
        _createDocumentColorsGrid() {
          const t = Template.bind(this.documentColors, this.documentColors);
          const e = new ColorGridView(this.locale, { columns: this.columns });
          e.extendTemplate({
            attributes: { class: t.if('isEmpty', 'ck-hidden') },
          });
          e.items.bindTo(this.documentColors).using(t => {
            const e = new ColorTileView();
            e.set({
              color: t.color,
              hasBorder: t.options && t.options.hasBorder,
            });
            if (t.label) {
              e.set({ label: t.label, tooltip: true });
            }
            e.on('execute', () => {
              this.fire('execute', {
                value: t.color,
                source: 'documentColorsGrid',
              });
            });
            return e;
          });
          this.documentColors.on('change:isEmpty', (t, n, o) => {
            if (o) {
              e.selectedColor = null;
            }
          });
          return e;
        }
        _addColorToDocumentColors(t) {
          const e = this.colorDefinitions.find(e => e.color === t);
          if (!e) {
            this.documentColors.add({
              color: t,
              label: t,
              options: { hasBorder: false },
            });
          } else {
            this.documentColors.add(Object.assign({}, e));
          }
        }
      }
      class Jx extends (null && View) {
        constructor(
          t,
          {
            focusTracker: e,
            focusables: n,
            keystrokes: o,
            colorPickerViewConfig: i,
          },
        ) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = e;
          this.keystrokes = o;
          this.set('isVisible', false);
          this.set('selectedColor', undefined);
          this._focusables = n;
          this._colorPickerViewConfig = i;
          const r = this.bindTemplate;
          const { saveButtonView: s, cancelButtonView: a } =
            this._createActionButtons();
          this.saveButtonView = s;
          this.cancelButtonView = a;
          this.actionBarView = this._createActionBarView({
            saveButtonView: s,
            cancelButtonView: a,
          });
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck-color-picker-fragment',
                r.if('isVisible', 'ck-hidden', t => !t),
              ],
            },
            children: this.items,
          });
        }
        render() {
          super.render();
          const t = new ColorPickerView(this.locale, {
            ...this._colorPickerViewConfig,
          });
          this.colorPickerView = t;
          this.colorPickerView.render();
          if (this.selectedColor) {
            t.color = this.selectedColor;
          }
          this.listenTo(this, 'change:selectedColor', (e, n, o) => {
            t.color = o;
          });
          this.items.add(this.colorPickerView);
          this.items.add(this.actionBarView);
          this._addColorPickersElementsToFocusTracker();
          this._stopPropagationOnArrowsKeys();
          this._executeOnEnterPress();
          this._executeUponColorChange();
        }
        destroy() {
          super.destroy();
        }
        focus() {
          this.colorPickerView.focus();
        }
        _executeOnEnterPress() {
          this.keystrokes.set('enter', t => {
            if (
              this.isVisible &&
              this.focusTracker.focusedElement !== this.cancelButtonView.element
            ) {
              this.fire('execute', { value: this.selectedColor });
              t.stopPropagation();
              t.preventDefault();
            }
          });
        }
        _stopPropagationOnArrowsKeys() {
          const t = t => t.stopPropagation();
          this.keystrokes.set('arrowright', t);
          this.keystrokes.set('arrowleft', t);
          this.keystrokes.set('arrowup', t);
          this.keystrokes.set('arrowdown', t);
        }
        _addColorPickersElementsToFocusTracker() {
          for (const t of this.colorPickerView.slidersView) {
            this.focusTracker.add(t.element);
            this._focusables.add(t);
          }
          const t = this.colorPickerView.hexInputRow.children.get(1);
          if (t.element) {
            this.focusTracker.add(t.element);
            this._focusables.add(t);
          }
          this.focusTracker.add(this.saveButtonView.element);
          this._focusables.add(this.saveButtonView);
          this.focusTracker.add(this.cancelButtonView.element);
          this._focusables.add(this.cancelButtonView);
        }
        _createActionBarView({ saveButtonView: t, cancelButtonView: e }) {
          const n = new View();
          const o = this.createCollection();
          o.add(t);
          o.add(e);
          n.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-selector_action-bar'] },
            children: o,
          });
          return n;
        }
        _createActionButtons() {
          const t = this.locale;
          const e = t.t;
          const n = new ButtonView(t);
          const o = new ButtonView(t);
          n.set({
            icon: checkButtonIcon,
            class: 'ck-button-save',
            type: 'button',
            withText: false,
            label: e('Accept'),
          });
          o.set({
            icon: cancelButtonIcon,
            class: 'ck-button-cancel',
            type: 'button',
            withText: false,
            label: e('Cancel'),
          });
          n.on('execute', () => {
            this.fire('execute', {
              source: 'colorPickerSaveButton',
              value: this.selectedColor,
            });
          });
          o.on('execute', () => {
            this.fire('colorPicker:cancel');
          });
          return { saveButtonView: n, cancelButtonView: o };
        }
        _executeUponColorChange() {
          this.colorPickerView.on('colorSelected', (t, e) => {
            this.fire('execute', { value: e.color, source: 'colorPicker' });
            this.set('selectedColor', e.color);
          });
        }
      }
      var Yx = n(306);
      var Qx = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      Qx.insert = 'head';
      Qx.singleton = true;
      var Xx = Bl()(Yx.Z, Qx);
      const tE = Yx.Z.locals || {};
      class eE extends (null && View) {
        constructor(
          t,
          {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            colorPickerViewConfig: a,
          },
        ) {
          super(t);
          this.items = this.createCollection();
          this.focusTracker = new FocusTracker();
          this.keystrokes = new KeystrokeHandler();
          this._focusables = new ViewCollection();
          this._colorPickerViewConfig = a;
          this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          });
          this.colorGridsFragmentView = new ColorGridsFragmentView(t, {
            colors: e,
            columns: n,
            removeButtonLabel: o,
            documentColorsLabel: i,
            documentColorsCount: r,
            colorPickerLabel: s,
            focusTracker: this.focusTracker,
            focusables: this._focusables,
          });
          this.colorPickerFragmentView = new ColorPickerFragmentView(t, {
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokes: this.keystrokes,
            colorPickerViewConfig: a,
          });
          this.set('_isColorGridsFragmentVisible', true);
          this.set('_isColorPickerFragmentVisible', false);
          this.set('selectedColor', undefined);
          this.colorGridsFragmentView
            .bind('isVisible')
            .to(this, '_isColorGridsFragmentVisible');
          this.colorPickerFragmentView
            .bind('isVisible')
            .to(this, '_isColorPickerFragmentVisible');
          this.on('change:selectedColor', (t, e, n) => {
            this.colorGridsFragmentView.set('selectedColor', n);
            this.colorPickerFragmentView.set('selectedColor', n);
          });
          this.colorGridsFragmentView.on('change:selectedColor', (t, e, n) => {
            this.set('selectedColor', n);
          });
          this.colorPickerFragmentView.on('change:selectedColor', (t, e, n) => {
            this.set('selectedColor', n);
          });
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-color-selector'] },
            children: this.items,
          });
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
          this.keystrokes.destroy();
        }
        appendUI() {
          this._appendColorGridsFragment();
          if (this._colorPickerViewConfig) {
            this._appendColorPickerFragment();
          }
        }
        showColorPickerFragment() {
          if (
            !this.colorPickerFragmentView.colorPickerView ||
            this._isColorPickerFragmentVisible
          ) {
            return;
          }
          this._isColorPickerFragmentVisible = true;
          this.colorPickerFragmentView.focus();
          this._isColorGridsFragmentVisible = false;
        }
        showColorGridsFragment() {
          if (this._isColorGridsFragmentVisible) {
            return;
          }
          this._isColorGridsFragmentVisible = true;
          this.colorGridsFragmentView.focus();
          this._isColorPickerFragmentVisible = false;
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        updateDocumentColors(t, e) {
          this.colorGridsFragmentView.updateDocumentColors(t, e);
        }
        updateSelectedColors() {
          this.colorGridsFragmentView.updateSelectedColors();
        }
        _appendColorGridsFragment() {
          if (this.items.length) {
            return;
          }
          this.items.add(this.colorGridsFragmentView);
          this.colorGridsFragmentView.delegate('execute').to(this);
          this.colorGridsFragmentView.delegate('colorPicker:show').to(this);
        }
        _appendColorPickerFragment() {
          if (this.items.length === 2) {
            return;
          }
          this.items.add(this.colorPickerFragmentView);
          if (this.colorGridsFragmentView.colorPickerButtonView) {
            this.colorGridsFragmentView.colorPickerButtonView.on(
              'execute',
              () => {
                this.showColorPickerFragment();
              },
            );
          }
          this.colorGridsFragmentView.addColorPickerButton();
          this.colorPickerFragmentView.delegate('execute').to(this);
          this.colorPickerFragmentView.delegate('colorPicker:cancel').to(this);
        }
      }
      class nE {
        constructor(t) {
          this._components = new Map();
          this.editor = t;
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName;
          }
        }
        add(t, e) {
          this._components.set(oE(t), { callback: e, originalName: t });
        }
        create(t) {
          if (!this.has(t)) {
            throw new B('componentfactory-item-missing', this, { name: t });
          }
          return this._components.get(oE(t)).callback(this.editor.locale);
        }
        has(t) {
          return this._components.has(oE(t));
        }
      }
      function oE(t) {
        return String(t).toLowerCase();
      }
      var iE = n(460);
      var rE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      rE.insert = 'head';
      rE.singleton = true;
      var sE = Bl()(iE.Z, rE);
      const aE = iE.Z.locals || {};
      const cE = kc('px');
      const lE = Xa.document.body;
      const dE = {
        top: -99999,
        left: -99999,
        name: 'arrowless',
        config: { withArrow: false },
      };
      class hE extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('top', 0);
          this.set('left', 0);
          this.set('position', 'arrow_nw');
          this.set('isVisible', false);
          this.set('withArrow', true);
          this.set('class', undefined);
          this._pinWhenIsVisibleCallback = null;
          this.content = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-balloon-panel',
                e.to('position', t => `ck-balloon-panel_${t}`),
                e.if('isVisible', 'ck-balloon-panel_visible'),
                e.if('withArrow', 'ck-balloon-panel_with-arrow'),
                e.to('class'),
              ],
              style: { top: e.to('top', cE), left: e.to('left', cE) },
            },
            children: this.content,
          });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t) {
          this.show();
          const e = hE.defaultPositions;
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: lE,
              fitInViewport: true,
            },
            t,
          );
          const o = hE._getOptimalPosition(n) || dE;
          const i = parseInt(o.left);
          const r = parseInt(o.top);
          const s = o.name;
          const a = o.config || {};
          const { withArrow: c = true } = a;
          this.top = r;
          this.left = i;
          this.position = s;
          this.withArrow = c;
        }
        pin(t) {
          this.unpin();
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t);
            } else {
              this._stopPinning();
            }
          };
          this._startPinning(t);
          this.listenTo(
            this,
            'change:isVisible',
            this._pinWhenIsVisibleCallback,
          );
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning();
            this.stopListening(
              this,
              'change:isVisible',
              this._pinWhenIsVisibleCallback,
            );
            this._pinWhenIsVisibleCallback = null;
            this.hide();
          }
        }
        _startPinning(t) {
          this.attachTo(t);
          const e = uE(t.target);
          const n = t.limiter ? uE(t.limiter) : lE;
          this.listenTo(
            Xa.document,
            'scroll',
            (o, i) => {
              const r = i.target;
              const s = e && r.contains(e);
              const a = n && r.contains(n);
              if (s || a || !e || !n) {
                this.attachTo(t);
              }
            },
            { useCapture: true },
          );
          this.listenTo(Xa.window, 'resize', () => {
            this.attachTo(t);
          });
        }
        _stopPinning() {
          this.stopListening(Xa.document, 'scroll');
          this.stopListening(Xa.window, 'resize');
        }
      }
      hE.arrowSideOffset = 25;
      hE.arrowHeightOffset = 10;
      hE.stickyVerticalOffset = 20;
      hE._getOptimalPosition = Cc;
      hE.defaultPositions = fE();
      function uE(t) {
        if (Ha(t)) {
          return t;
        }
        if (ic(t)) {
          return t.commonAncestorContainer;
        }
        if (typeof t == 'function') {
          return uE(t());
        }
        return null;
      }
      function fE(t = {}) {
        const {
          sideOffset: e = hE.arrowSideOffset,
          heightOffset: n = hE.arrowHeightOffset,
          stickyVerticalOffset: o = hE.stickyVerticalOffset,
          config: i,
        } = t;
        return {
          northWestArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northWestArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northWestArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.left + t.width / 2 - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          northEastArrowSouthWest: (t, n) => ({
            top: r(t, n),
            left: t.right - e,
            name: 'arrow_sw',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleWest: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.25 - e,
            name: 'arrow_smw',
            ...(i && { config: i }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: r(t, e),
            left: t.right - e.width / 2,
            name: 'arrow_s',
            ...(i && { config: i }),
          }),
          northEastArrowSouthMiddleEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width * 0.75 + e,
            name: 'arrow_sme',
            ...(i && { config: i }),
          }),
          northEastArrowSouthEast: (t, n) => ({
            top: r(t, n),
            left: t.right - n.width + e,
            name: 'arrow_se',
            ...(i && { config: i }),
          }),
          southWestArrowNorthWest: t => ({
            top: s(t),
            left: t.left - e,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southWestArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southWestArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southArrowNorthWest: t => ({
            top: s(t),
            left: t.left + t.width / 2 - e,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left + t.width / 2 - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          southEastArrowNorthWest: t => ({
            top: s(t),
            left: t.right - e,
            name: 'arrow_nw',
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.25 - e,
            name: 'arrow_nmw',
            ...(i && { config: i }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: s(t),
            left: t.right - e.width / 2,
            name: 'arrow_n',
            ...(i && { config: i }),
          }),
          southEastArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.75 + e,
            name: 'arrow_nme',
            ...(i && { config: i }),
          }),
          southEastArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width + e,
            name: 'arrow_ne',
            ...(i && { config: i }),
          }),
          westArrowEast: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.left - e.width - n,
            name: 'arrow_e',
            ...(i && { config: i }),
          }),
          eastArrowWest: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.right + n,
            name: 'arrow_w',
            ...(i && { config: i }),
          }),
          viewportStickyNorth: (t, e, n, r) => {
            const s = r || n;
            if (!t.getIntersection(s)) {
              return null;
            }
            if (s.height - t.height > o) {
              return null;
            }
            return {
              top: s.top + o,
              left: t.left + t.width / 2 - e.width / 2,
              name: 'arrowless',
              config: { withArrow: false, ...i },
            };
          },
        };
        function r(t, e) {
          return t.top - e.height - n;
        }
        function s(t) {
          return t.bottom + n;
        }
      }
      var pE = n(888);
      var gE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      gE.insert = 'head';
      gE.singleton = true;
      var mE = Bl()(pE.Z, gE);
      const kE = pE.Z.locals || {};
      const bE = 'ck-tooltip';
      class wE extends Ua() {
        constructor(t) {
          super();
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          this._resizeObserver = null;
          wE._editors.add(t);
          if (wE._instance) {
            return wE._instance;
          }
          wE._instance = this;
          this.tooltipTextView = new Vl(t.locale);
          this.tooltipTextView.set('text', '');
          this.tooltipTextView.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-tooltip__text'] },
            children: [{ text: this.tooltipTextView.bindTemplate.to('text') }],
          });
          this.balloonPanelView = new hE(t.locale);
          this.balloonPanelView.class = bE;
          this.balloonPanelView.content.add(this.tooltipTextView);
          this._pinTooltipDebounced = am(this._pinTooltip, 600);
          this.listenTo(
            Xa.document,
            'mouseenter',
            this._onEnterOrFocus.bind(this),
            { useCapture: true },
          );
          this.listenTo(
            Xa.document,
            'mouseleave',
            this._onLeaveOrBlur.bind(this),
            { useCapture: true },
          );
          this.listenTo(Xa.document, 'focus', this._onEnterOrFocus.bind(this), {
            useCapture: true,
          });
          this.listenTo(Xa.document, 'blur', this._onLeaveOrBlur.bind(this), {
            useCapture: true,
          });
          this.listenTo(Xa.document, 'scroll', this._onScroll.bind(this), {
            useCapture: true,
          });
          this._watchdogExcluded = true;
        }
        destroy(t) {
          const e = t.ui.view && t.ui.view.body;
          wE._editors.delete(t);
          this.stopListening(t.ui);
          if (e && e.has(this.balloonPanelView)) {
            e.remove(this.balloonPanelView);
          }
          if (!wE._editors.size) {
            this._unpinTooltip();
            this.balloonPanelView.destroy();
            this.stopListening();
            wE._instance = null;
          }
        }
        static getPositioningFunctions(t) {
          const e = wE.defaultBalloonPositions;
          return {
            s: [
              e.southArrowNorth,
              e.southArrowNorthEast,
              e.southArrowNorthWest,
            ],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t];
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = _E(e);
          if (!n) {
            return;
          }
          if (n === this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltip();
          this._pinTooltipDebounced(n, vE(n));
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === 'mouseleave') {
            if (!Ha(e)) {
              return;
            }
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            const t = _E(e);
            const o = _E(n);
            if (t && t !== o) {
              this._unpinTooltip();
            }
          } else {
            if (
              this._currentElementWithTooltip &&
              e !== this._currentElementWithTooltip
            ) {
              return;
            }
            this._unpinTooltip();
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return;
          }
          if (
            e.contains(this.balloonPanelView.element) &&
            e.contains(this._currentElementWithTooltip)
          ) {
            return;
          }
          this._unpinTooltip();
        }
        _pinTooltip(t, { text: e, position: n, cssClass: o }) {
          const i = hl(wE._editors.values()).ui.view.body;
          if (!i.has(this.balloonPanelView)) {
            i.add(this.balloonPanelView);
          }
          this.tooltipTextView.text = e;
          this.balloonPanelView.pin({
            target: t,
            positions: wE.getPositioningFunctions(n),
          });
          this._resizeObserver = new gc(t, () => {
            if (!Ac(t)) {
              this._unpinTooltip();
            }
          });
          this.balloonPanelView.class = [bE, o].filter(t => t).join(' ');
          for (const t of wE._editors) {
            this.listenTo(
              t.ui,
              'update',
              this._updateTooltipPosition.bind(this),
              { priority: 'low' },
            );
          }
          this._currentElementWithTooltip = t;
          this._currentTooltipPosition = n;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel();
          this.balloonPanelView.unpin();
          for (const t of wE._editors) {
            this.stopListening(t.ui, 'update');
          }
          this._currentElementWithTooltip = null;
          this._currentTooltipPosition = null;
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _updateTooltipPosition() {
          if (!Ac(this._currentElementWithTooltip)) {
            this._unpinTooltip();
            return;
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: wE.getPositioningFunctions(this._currentTooltipPosition),
          });
        }
      }
      wE.defaultBalloonPositions = fE({ heightOffset: 5, sideOffset: 13 });
      wE._editors = new Set();
      wE._instance = null;
      function _E(t) {
        if (!Ha(t)) {
          return null;
        }
        return t.closest(
          '[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])',
        );
      }
      function vE(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || 's',
          cssClass: t.dataset.ckeTooltipClass || '',
        };
      }
      var AE = 'Expected a function';
      function CE(t, e, n) {
        var o = true,
          i = true;
        if (typeof t != 'function') {
          throw new TypeError(AE);
        }
        if (ot(n)) {
          o = 'leading' in n ? !!n.leading : o;
          i = 'trailing' in n ? !!n.trailing : i;
        }
        return am(t, e, { leading: o, maxWait: e, trailing: i });
      }
      const yE = CE;
      const xE =
        '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';
      const EE = 53;
      const DE = 10;
      const TE = 50;
      const SE = 350;
      const PE = 'Powered by';
      class BE extends Ua() {
        constructor(t) {
          super();
          this.editor = t;
          this._balloonView = null;
          this._lastFocusedEditableElement = null;
          this._showBalloonThrottled = yE(this._showBalloon.bind(this), 50, {
            leading: true,
          });
          t.on('ready', this._handleEditorReady.bind(this));
        }
        destroy() {
          const t = this._balloonView;
          if (t) {
            t.unpin();
            this._balloonView = null;
          }
          this._showBalloonThrottled.cancel();
          this.stopListening();
        }
        _handleEditorReady() {
          const t = this.editor;
          const e = !!t.config.get('ui.poweredBy.forceVisible');
          if (!e && wl(t.config.get('licenseKey')) === 'VALID') {
            return;
          }
          if (!t.ui.view) {
            return;
          }
          t.ui.focusTracker.on('change:isFocused', (t, e, n) => {
            this._updateLastFocusedEditableElement();
            if (n) {
              this._showBalloon();
            } else {
              this._hideBalloon();
            }
          });
          t.ui.focusTracker.on('change:focusedElement', (t, e, n) => {
            this._updateLastFocusedEditableElement();
            if (n) {
              this._showBalloon();
            }
          });
          t.ui.on('update', () => {
            this._showBalloonThrottled();
          });
        }
        _createBalloonView() {
          const t = this.editor;
          const e = (this._balloonView = new hE());
          const n = zE(t);
          const o = new RE(t.locale, n.label);
          e.content.add(o);
          e.set({ class: 'ck-powered-by-balloon' });
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this._balloonView = e;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement) {
            return;
          }
          const t = OE(this.editor, this._lastFocusedEditableElement);
          if (t) {
            if (!this._balloonView) {
              this._createBalloonView();
            }
            this._balloonView.pin(t);
          }
        }
        _hideBalloon() {
          if (this._balloonView) {
            this._balloonView.unpin();
          }
        }
        _updateLastFocusedEditableElement() {
          const t = this.editor;
          const e = t.ui.focusTracker.isFocused;
          const n = t.ui.focusTracker.focusedElement;
          if (!e || !n) {
            this._lastFocusedEditableElement = null;
            return;
          }
          const o = Array.from(t.ui.getEditableElementsNames()).map(e =>
            t.ui.getEditableElement(e),
          );
          if (o.includes(n)) {
            this._lastFocusedEditableElement = n;
          } else {
            this._lastFocusedEditableElement = o[0];
          }
        }
      }
      class RE extends Vl {
        constructor(t, e) {
          super(t);
          const n = new md();
          const o = this.bindTemplate;
          n.set({ content: xE, isColorInherited: false });
          n.extendTemplate({
            attributes: { style: { width: EE + 'px', height: DE + 'px' } },
          });
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-powered-by'], 'aria-hidden': true },
            children: [
              {
                tag: 'a',
                attributes: {
                  href:
                    'https://ckeditor.com/?utm_source=ckeditor&' +
                    'utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo',
                  target: '_blank',
                  tabindex: '-1',
                },
                children: [
                  ...(e
                    ? [
                        {
                          tag: 'span',
                          attributes: { class: ['ck', 'ck-powered-by__label'] },
                          children: [e],
                        },
                      ]
                    : []),
                  n,
                ],
                on: { dragstart: o.to(t => t.preventDefault()) },
              },
            ],
          });
        }
      }
      function OE(t, e) {
        const n = zE(t);
        const o = n.side === 'right' ? IE(e, n) : ME(e, n);
        return { target: e, positions: [o] };
      }
      function IE(t, e) {
        return VE(
          t,
          e,
          (t, n) => t.left + t.width - n.width - e.horizontalOffset,
        );
      }
      function ME(t, e) {
        return VE(t, e, t => t.left + e.horizontalOffset);
      }
      function VE(t, e, n) {
        return (o, i) => {
          const r = new cc(t);
          if (r.width < SE || r.height < TE) {
            return null;
          }
          let s;
          if (e.position === 'inside') {
            s = r.bottom - i.height;
          } else {
            s = r.bottom - i.height / 2;
          }
          s -= e.verticalOffset;
          const a = n(r, i);
          const c = o
            .clone()
            .moveTo(a, s)
            .getIntersection(i.clone().moveTo(a, s));
          const l = c.getVisible();
          if (!l || l.getArea() < i.getArea()) {
            return null;
          }
          return {
            top: s,
            left: a,
            name: `position_${e.position}-side_${e.side}`,
            config: { withArrow: false },
          };
        };
      }
      function zE(t) {
        const e = t.config.get('ui.poweredBy');
        const n = (e && e.position) || 'border';
        return {
          position: n,
          label: PE,
          verticalOffset: n === 'inside' ? 5 : 0,
          horizontalOffset: 5,
          side: t.locale.contentLanguageDirection === 'ltr' ? 'right' : 'left',
          ...e,
        };
      }
      var FE = n(290);
      var NE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      NE.insert = 'head';
      NE.singleton = true;
      var LE = Bl()(FE.Z, NE);
      const HE = FE.Z.locals || {};
      var jE;
      (function (t) {
        t['POLITE'] = 'polite';
        t['ASSERTIVE'] = 'assertive';
      })(jE || (jE = {}));
      class qE {
        constructor(t) {
          this.editor = t;
        }
        announce(t, e, n = jE.POLITE) {
          const o = this.editor;
          if (!this.view) {
            this.view = new $E(o.locale);
            o.ui.view.body.add(this.view);
          }
          let i = this.view.regionViews.find(e => e.regionName === t);
          if (!i) {
            i = new WE(this.view.locale);
            this.view.regionViews.add(i);
          }
          i.set({ regionName: t, text: e, politeness: n });
        }
      }
      class $E extends Vl {
        constructor(t) {
          super(t);
          this.regionViews = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-aria-live-announcer'] },
            children: this.regionViews,
          });
        }
      }
      class WE extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('regionName', '');
          this.set('text', '');
          this.set('politeness', jE.POLITE);
          this.setTemplate({
            tag: 'div',
            attributes: {
              role: 'region',
              'data-region': e.to('regionName'),
              'aria-live': e.to('politeness'),
            },
            children: [{ text: e.to('text') }],
          });
        }
      }
      class GE extends dt() {
        constructor(t) {
          super();
          this.isReady = false;
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
          const e = t.editing.view;
          this.editor = t;
          this.componentFactory = new nE(t);
          this.focusTracker = new ul();
          this.tooltipManager = new wE(t);
          this.poweredBy = new BE(t);
          this.ariaLiveAnnouncer = new qE(t);
          this.set('viewportOffset', this._readViewportOffsetFromConfig());
          this.once('ready', () => {
            this.isReady = true;
          });
          this.listenTo(e.document, 'layoutChanged', this.update.bind(this));
          this.listenTo(
            e,
            'scrollToTheSelection',
            this._handleScrollToTheSelection.bind(this),
          );
          this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire('update');
        }
        destroy() {
          this.stopListening();
          this.focusTracker.destroy();
          this.tooltipManager.destroy(this.editor);
          this.poweredBy.destroy();
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null;
            this.editor.keystrokes.stopListening(t);
          }
          this._editableElementsMap = new Map();
          this._focusableToolbarDefinitions = [];
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e);
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor;
          }
          this.focusTracker.add(e);
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return;
            }
            this.editor.keystrokes.listenTo(e);
          };
          if (this.isReady) {
            n();
          } else {
            this.once('ready', n);
          }
        }
        removeEditableElement(t) {
          const e = this._editableElementsMap.get(t);
          if (!e) {
            return;
          }
          this._editableElementsMap.delete(t);
          this.editor.keystrokes.stopListening(e);
          this.focusTracker.remove(e);
          e.ckeditorInstance = null;
        }
        getEditableElement(t = 'main') {
          return this._editableElementsMap.get(t);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element);
            this.editor.keystrokes.listenTo(t.element);
          } else {
            t.once('render', () => {
              this.focusTracker.add(t.element);
              this.editor.keystrokes.listenTo(t.element);
            });
          }
          this._focusableToolbarDefinitions.push({
            toolbarView: t,
            options: e,
          });
        }
        get _editableElements() {
          console.warn(
            'editor-ui-deprecated-editable-elements: ' +
              'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.',
            { editorUI: this },
          );
          return this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor;
          const e = t.config.get('ui.viewportOffset');
          if (e) {
            return e;
          }
          const n = t.config.get('toolbar.viewportTopOffset');
          if (n) {
            console.warn(
              'editor-ui-deprecated-viewport-offset-config: ' +
                'The `toolbar.vieportTopOffset` configuration option is deprecated. ' +
                'It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.',
            );
            return { top: n };
          }
          return { top: 0 };
        }
        _initFocusTracking() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let o;
          t.keystrokes.set('Alt+F10', (t, i) => {
            const r = this.focusTracker.focusedElement;
            if (
              Array.from(this._editableElementsMap.values()).includes(r) &&
              !Array.from(e.domRoots.values()).includes(r)
            ) {
              n = r;
            }
            const s = this._getCurrentFocusedToolbarDefinition();
            if (!s || !o) {
              o = this._getFocusableCandidateToolbarDefinitions();
            }
            for (let t = 0; t < o.length; t++) {
              const t = o.shift();
              o.push(t);
              if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur();
                }
                break;
              }
            }
            i();
          });
          t.keystrokes.set('Esc', (e, o) => {
            const i = this._getCurrentFocusedToolbarDefinition();
            if (!i) {
              return;
            }
            if (n) {
              n.focus();
              n = null;
            } else {
              t.editing.view.focus();
            }
            if (i.options.afterBlur) {
              i.options.afterBlur();
            }
            o();
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = [];
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: o } = e;
            if (Ac(n.element) || o.beforeFocus) {
              t.push(e);
            }
          }
          t.sort((t, e) => KE(t) - KE(e));
          return t;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (
              t.toolbarView.element &&
              t.toolbarView.element.contains(this.focusTracker.focusedElement)
            ) {
              return t;
            }
          }
          return null;
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t;
          if (n) {
            n();
          }
          if (!Ac(e.element)) {
            return false;
          }
          e.focus();
          return true;
        }
        _handleScrollToTheSelection(t, e) {
          const n = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            ...this.viewportOffset,
          };
          e.viewportOffset.top += n.top;
          e.viewportOffset.bottom += n.bottom;
          e.viewportOffset.left += n.left;
          e.viewportOffset.right += n.right;
        }
      }
      function KE(t) {
        const { toolbarView: e, options: n } = t;
        let o = 10;
        if (Ac(e.element)) {
          o--;
        }
        if (n.isContextual) {
          o--;
        }
        return o;
      }
      var UE = n(847);
      var ZE = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      ZE.insert = 'head';
      ZE.singleton = true;
      var JE = Bl()(UE.Z, ZE);
      const YE = UE.Z.locals || {};
      class QE extends Vl {
        constructor(t) {
          super(t);
          this.body = new hd(t);
        }
        render() {
          super.render();
          this.body.attachToDom();
        }
        destroy() {
          this.body.detachFromDom();
          return super.destroy();
        }
      }
      class XE extends QE {
        constructor(t) {
          super(t);
          this.top = this.createCollection();
          this.main = this.createCollection();
          this._voiceLabelView = this._createVoiceLabel();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-reset', 'ck-editor', 'ck-rounded-corners'],
              role: 'application',
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              'aria-labelledby': this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-editor__top', 'ck-reset_all'],
                  role: 'presentation',
                },
                children: this.top,
              },
              {
                tag: 'div',
                attributes: {
                  class: ['ck', 'ck-editor__main'],
                  role: 'presentation',
                },
                children: this.main,
              },
            ],
          });
        }
        _createVoiceLabel() {
          const t = this.t;
          const e = new Ud();
          e.text = t('Rich Text Editor');
          e.extendTemplate({ attributes: { class: 'ck-voice-label' } });
          return e;
        }
      }
      class tD extends Vl {
        constructor(t, e, n) {
          super(t);
          this.name = null;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-content',
                'ck-editor__editable',
                'ck-rounded-corners',
              ],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          });
          this.set('isFocused', false);
          this._editableElement = n;
          this._hasExternalElement = !!this._editableElement;
          this._editingView = e;
        }
        render() {
          super.render();
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement));
          } else {
            this._editableElement = this.element;
          }
          this.on('change:isFocused', () => this._updateIsFocusedClasses());
          this._updateIsFocusedClasses();
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement);
          }
          super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const t = this._editingView;
          if (t.isRenderingInProgress) {
            n(this);
          } else {
            e(this);
          }
          function e(e) {
            t.change(n => {
              const o = t.document.getRoot(e.name);
              n.addClass(e.isFocused ? 'ck-focused' : 'ck-blurred', o);
              n.removeClass(e.isFocused ? 'ck-blurred' : 'ck-focused', o);
            });
          }
          function n(o) {
            t.once('change:isRenderingInProgress', (t, i, r) => {
              if (!r) {
                e(o);
              } else {
                n(o);
              }
            });
          }
        }
      }
      class eD extends tD {
        constructor(t, e, n, o = {}) {
          super(t, e, n);
          const i = t.t;
          this.extendTemplate({
            attributes: {
              role: 'textbox',
              class: 'ck-editor__editable_inline',
            },
          });
          this._generateLabel =
            o.label || (() => i('Editor editing area: %0', this.name));
        }
        render() {
          super.render();
          const t = this._editingView;
          t.change(e => {
            const n = t.document.getRoot(this.name);
            e.setAttribute('aria-label', this._generateLabel(this), n);
          });
        }
      }
      var nD = n(668);
      var oD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      oD.insert = 'head';
      oD.singleton = true;
      var iD = Bl()(nD.Z, oD);
      const rD = nD.Z.locals || {};
      class sD extends (null && View) {
        constructor(t, e = {}) {
          super(t);
          const n = this.bindTemplate;
          this.set('label', e.label || '');
          this.set('class', e.class || null);
          this.children = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-form__header', n.to('class')] },
            children: this.children,
          });
          if (e.icon) {
            this.iconView = new IconView();
            this.iconView.content = e.icon;
            this.children.add(this.iconView);
          }
          const o = new View(t);
          o.setTemplate({
            tag: 'h2',
            attributes: { class: ['ck', 'ck-form__header__label'] },
            children: [{ text: n.to('label') }],
          });
          this.children.add(o);
        }
      }
      class aD extends (null && View) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: 'iframe',
            attributes: {
              class: ['ck', 'ck-reset_all'],
              sandbox: 'allow-same-origin allow-scripts',
            },
            on: { load: e.to('loaded') },
          });
        }
        render() {
          return new Promise(t => {
            this.on('loaded', t);
            return super.render();
          });
        }
      }
      class cD extends (null && ContextPlugin) {
        static get pluginName() {
          return 'Notification';
        }
        init() {
          this.on(
            'show:warning',
            (t, e) => {
              window.alert(e.message);
            },
            { priority: 'lowest' },
          );
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'success',
            namespace: e.namespace,
            title: e.title,
          });
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'info',
            namespace: e.namespace,
            title: e.title,
          });
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: 'warning',
            namespace: e.namespace,
            title: e.title,
          });
        }
        _showNotification(t) {
          const e = t.namespace
            ? `show:${t.type}:${t.namespace}`
            : `show:${t.type}`;
          this.fire(e, {
            message: t.message,
            type: t.type,
            title: t.title || '',
          });
        }
      }
      class lD extends dt() {
        constructor(t, e) {
          super();
          if (e) {
            Fg(this, e);
          }
          if (t) {
            this.set(t);
          }
        }
      }
      const dD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
      const hD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
      var uD = n(592);
      var fD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      fD.insert = 'head';
      fD.singleton = true;
      var pD = Bl()(uD.Z, fD);
      const gD = uD.Z.locals || {};
      var mD = n(356);
      var kD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      kD.insert = 'head';
      kD.singleton = true;
      var bD = Bl()(mD.Z, kD);
      const wD = mD.Z.locals || {};
      const _D = kc('px');
      class vD extends Sh {
        static get pluginName() {
          return 'ContextualBalloon';
        }
        constructor(t) {
          super(t);
          this._viewToStack = new Map();
          this._idToStack = new Map();
          this._view = null;
          this._rotatorView = null;
          this._fakePanelsView = null;
          this.positionLimiter = () => {
            const t = this.editor.editing.view;
            const e = t.document;
            const n = e.selection.editableElement;
            if (n) {
              return t.domConverter.mapViewToDom(n.root);
            }
            return null;
          };
          this.set('visibleView', null);
          this.set('_numberOfStacks', 0);
          this.set('_singleViewMode', false);
        }
        destroy() {
          super.destroy();
          if (this._view) {
            this._view.destroy();
          }
          if (this._rotatorView) {
            this._rotatorView.destroy();
          }
          if (this._fakePanelsView) {
            this._fakePanelsView.destroy();
          }
        }
        get view() {
          if (!this._view) {
            this._createPanelView();
          }
          return this._view;
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t);
        }
        add(t) {
          if (!this._view) {
            this._createPanelView();
          }
          if (this.hasView(t.view)) {
            throw new B('contextualballoon-add-view-exist', [this, t]);
          }
          const e = t.stackId || 'main';
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]));
            this._viewToStack.set(t.view, this._idToStack.get(e));
            this._numberOfStacks = this._idToStack.size;
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e);
            }
            return;
          }
          const n = this._idToStack.get(e);
          if (t.singleViewMode) {
            this.showStack(e);
          }
          n.set(t.view, t);
          this._viewToStack.set(t.view, n);
          if (n === this._visibleStack) {
            this._showView(t);
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new B('contextualballoon-remove-view-not-exist', [this, t]);
          }
          const e = this._viewToStack.get(t);
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false;
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack();
              } else {
                this.view.hide();
                this.visibleView = null;
                this._rotatorView.hideView();
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2]);
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e));
            this._numberOfStacks = this._idToStack.size;
          } else {
            e.delete(t);
          }
          this._viewToStack.delete(t);
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t;
          }
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
        }
        showStack(t) {
          this.visibleStack = t;
          const e = this._idToStack.get(t);
          if (!e) {
            throw new B('contextualballoon-showstack-stack-not-exist', this);
          }
          if (this._visibleStack === e) {
            return;
          }
          this._showView(Array.from(e.values()).pop());
        }
        _createPanelView() {
          this._view = new hE(this.editor.locale);
          this.editor.ui.view.body.add(this._view);
          this.editor.ui.focusTracker.add(this._view.element);
          this._rotatorView = this._createRotatorView();
          this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find(e => e[1] === t);
          return e[0];
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) + 1;
          if (!t[e]) {
            e = 0;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) - 1;
          if (!t[e]) {
            e = t.length - 1;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _createRotatorView() {
          const t = new AD(this.editor.locale);
          const e = this.editor.locale.t;
          this.view.content.add(t);
          t.bind('isNavigationVisible').to(
            this,
            '_numberOfStacks',
            this,
            '_singleViewMode',
            (t, e) => !e && t > 1,
          );
          t.on('change:isNavigationVisible', () => this.updatePosition(), {
            priority: 'low',
          });
          t.bind('counter').to(
            this,
            'visibleView',
            this,
            '_numberOfStacks',
            (t, n) => {
              if (n < 2) {
                return '';
              }
              const o =
                Array.from(this._idToStack.values()).indexOf(
                  this._visibleStack,
                ) + 1;
              return e('%0 of %1', [o, n]);
            },
          );
          t.buttonNextView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showNextStack();
          });
          t.buttonPrevView.on('execute', () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showPrevStack();
          });
          return t;
        }
        _createFakePanelsView() {
          const t = new CD(this.editor.locale, this.view);
          t.bind('numberOfPanels').to(
            this,
            '_numberOfStacks',
            this,
            '_singleViewMode',
            (t, e) => {
              const n = !e && t >= 2;
              return n ? Math.min(t - 1, 2) : 0;
            },
          );
          t.listenTo(this.view, 'change:top', () => t.updatePosition());
          t.listenTo(this.view, 'change:left', () => t.updatePosition());
          this.editor.ui.view.body.add(t);
          return t;
        }
        _showView({
          view: t,
          balloonClassName: e = '',
          withArrow: n = true,
          singleViewMode: o = false,
        }) {
          this.view.class = e;
          this.view.withArrow = n;
          this._rotatorView.showView(t);
          this.visibleView = t;
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
          if (o) {
            this._singleViewMode = true;
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position;
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, { limiter: this.positionLimiter });
            }
            t = Object.assign({}, t, {
              viewportOffsetConfig: this.editor.ui.viewportOffset,
            });
          }
          return t;
        }
      }
      class AD extends Vl {
        constructor(t) {
          super(t);
          const e = t.t;
          const n = this.bindTemplate;
          this.set('isNavigationVisible', true);
          this.focusTracker = new ul();
          this.buttonPrevView = this._createButtonView(e('Previous'), dD);
          this.buttonNextView = this._createButtonView(e('Next'), hD);
          this.content = this.createCollection();
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-balloon-rotator'],
              'z-index': '-1',
            },
            children: [
              {
                tag: 'div',
                attributes: {
                  class: [
                    'ck-balloon-rotator__navigation',
                    n.to('isNavigationVisible', t => (t ? '' : 'ck-hidden')),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: 'span',
                    attributes: { class: ['ck-balloon-rotator__counter'] },
                    children: [{ text: n.to('counter') }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: 'div',
                attributes: { class: 'ck-balloon-rotator__content' },
                children: this.content,
              },
            ],
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy();
          this.focusTracker.destroy();
        }
        showView(t) {
          this.hideView();
          this.content.add(t);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t, e) {
          const n = new Ad(this.locale);
          n.set({ label: t, icon: e, tooltip: true });
          return n;
        }
      }
      class CD extends Vl {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          this.set('top', 0);
          this.set('left', 0);
          this.set('height', 0);
          this.set('width', 0);
          this.set('numberOfPanels', 0);
          this.content = this.createCollection();
          this._balloonPanelView = e;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck-fake-panel',
                n.to('numberOfPanels', t => (t ? '' : 'ck-hidden')),
              ],
              style: {
                top: n.to('top', _D),
                left: n.to('left', _D),
                width: n.to('width', _D),
                height: n.to('height', _D),
              },
            },
            children: this.content,
          });
          this.on('change:numberOfPanels', (t, e, n, o) => {
            if (n > o) {
              this._addPanels(n - o);
            } else {
              this._removePanels(o - n);
            }
            this.updatePosition();
          });
        }
        _addPanels(t) {
          while (t--) {
            const t = new Vl();
            t.setTemplate({ tag: 'div' });
            this.content.add(t);
            this.registerChild(t);
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last;
            this.content.remove(t);
            this.deregisterChild(t);
            t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView;
            const { width: n, height: o } = new cc(
              this._balloonPanelView.element,
            );
            Object.assign(this, { top: t, left: e, width: n, height: o });
          }
        }
      }
      var yD = n(707);
      var xD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      xD.insert = 'head';
      xD.singleton = true;
      var ED = Bl()(yD.Z, xD);
      const DD = yD.Z.locals || {};
      const TD = kc('px');
      class SD extends Vl {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set('isActive', false);
          this.set('isSticky', false);
          this.set('limiterElement', null);
          this.set('limiterBottomOffset', 50);
          this.set('viewportTopOffset', 0);
          this.set('_marginLeft', null);
          this.set('_isStickyToTheBottomOfLimiter', false);
          this.set('_stickyTopOffset', null);
          this.set('_stickyBottomOffset', null);
          this.content = this.createCollection();
          this._contentPanelPlaceholder = new Fl({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-sticky-panel__placeholder'],
              style: {
                display: e.to('isSticky', t => (t ? 'block' : 'none')),
                height: e.to('isSticky', t =>
                  t ? TD(this._contentPanelRect.height) : null,
                ),
              },
            },
          }).render();
          this._contentPanel = new Fl({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-sticky-panel__content',
                e.if('isSticky', 'ck-sticky-panel__content_sticky'),
                e.if(
                  '_isStickyToTheBottomOfLimiter',
                  'ck-sticky-panel__content_sticky_bottom-limit',
                ),
              ],
              style: {
                width: e.to('isSticky', t =>
                  t
                    ? TD(
                        this._contentPanelPlaceholder.getBoundingClientRect()
                          .width,
                      )
                    : null,
                ),
                top: e.to('_stickyTopOffset', t => (t ? TD(t) : t)),
                bottom: e.to('_stickyBottomOffset', t => (t ? TD(t) : t)),
                marginLeft: e.to('_marginLeft'),
              },
            },
            children: this.content,
          }).render();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-sticky-panel'] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          });
        }
        render() {
          super.render();
          this.checkIfShouldBeSticky();
          this.listenTo(
            Xa.document,
            'scroll',
            () => {
              this.checkIfShouldBeSticky();
            },
            { useCapture: true },
          );
          this.listenTo(this, 'change:isActive', () => {
            this.checkIfShouldBeSticky();
          });
        }
        checkIfShouldBeSticky() {
          if (!this.limiterElement || !this.isActive) {
            this._unstick();
            return;
          }
          const t = new cc(this.limiterElement);
          let e = t.getVisible();
          if (e) {
            const t = new cc(Xa.window);
            t.top += this.viewportTopOffset;
            t.height -= this.viewportTopOffset;
            e = e.getIntersection(t);
          }
          if (e && t.top < e.top) {
            const n = e.top;
            if (
              n + this._contentPanelRect.height + this.limiterBottomOffset >
              e.bottom
            ) {
              const n =
                Math.max(t.bottom - e.bottom, 0) + this.limiterBottomOffset;
              if (t.bottom - n > t.top + this._contentPanelRect.height) {
                this._stickToBottomOfLimiter(n);
              } else {
                this._unstick();
              }
            } else {
              if (
                this._contentPanelRect.height + this.limiterBottomOffset <
                t.height
              ) {
                this._stickToTopOfAncestors(n);
              } else {
                this._unstick();
              }
            }
          } else {
            this._unstick();
          }
        }
        _stickToTopOfAncestors(t) {
          this.isSticky = true;
          this._isStickyToTheBottomOfLimiter = false;
          this._stickyTopOffset = t;
          this._stickyBottomOffset = null;
          this._marginLeft = TD(-Xa.window.scrollX);
        }
        _stickToBottomOfLimiter(t) {
          this.isSticky = true;
          this._isStickyToTheBottomOfLimiter = true;
          this._stickyTopOffset = null;
          this._stickyBottomOffset = t;
          this._marginLeft = TD(-Xa.window.scrollX);
        }
        _unstick() {
          this.isSticky = false;
          this._isStickyToTheBottomOfLimiter = false;
          this._stickyTopOffset = null;
          this._stickyBottomOffset = null;
          this._marginLeft = null;
        }
        get _contentPanelRect() {
          return new cc(this._contentPanel);
        }
      }
      class PD extends Xd {
        constructor(t, e) {
          const n = t.t;
          const o = Object.assign(
            {},
            { showResetButton: true, showIcon: true, creator: By },
            e,
          );
          super(t, o.creator);
          this.label = e.label;
          this._viewConfig = o;
          if (this._viewConfig.showIcon) {
            this.iconView = new md();
            this.iconView.content = NC.loupe;
            this.fieldWrapperChildren.add(this.iconView, 0);
            this.extendTemplate({
              attributes: { class: 'ck-search__query_with-icon' },
            });
          }
          if (this._viewConfig.showResetButton) {
            this.resetButtonView = new Ad(t);
            this.resetButtonView.set({
              label: n('Clear'),
              icon: NC.cancel,
              class: 'ck-search__reset',
              isVisible: false,
              tooltip: true,
            });
            this.resetButtonView.on('execute', () => {
              this.reset();
              this.focus();
              this.fire('reset');
            });
            this.resetButtonView
              .bind('isVisible')
              .to(this.fieldView, 'isEmpty', t => !t);
            this.fieldWrapperChildren.add(this.resetButtonView);
            this.extendTemplate({
              attributes: { class: 'ck-search__query_with-reset' },
            });
          }
        }
        reset() {
          this.fieldView.reset();
          if (this._viewConfig.showResetButton) {
            this.resetButtonView.isVisible = false;
          }
        }
      }
      class BD extends Vl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set({ isVisible: false, primaryText: '', secondaryText: '' });
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-search__info',
                t.if('isVisible', 'ck-hidden', t => !t),
              ],
              tabindex: -1,
            },
            children: [
              { tag: 'span', children: [{ text: [t.to('primaryText')] }] },
              { tag: 'span', children: [{ text: [t.to('secondaryText')] }] },
            ],
          });
        }
        focus() {
          this.element.focus();
        }
      }
      class RD extends Vl {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.focusTracker = new ul();
          this.setTemplate({
            tag: 'div',
            attributes: { class: ['ck', 'ck-search__results'], tabindex: -1 },
            children: this.children,
          });
          this._focusCycler = new Ch({
            focusables: this.children,
            focusTracker: this.focusTracker,
          });
        }
        render() {
          super.render();
          for (const t of this.children) {
            this.focusTracker.add(t.element);
          }
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      var OD = /[\\^$.*+?()[\]{}|]/g,
        ID = RegExp(OD.source);
      function MD(t) {
        t = Lu(t);
        return t && ID.test(t) ? t.replace(OD, '\\$&') : t;
      }
      const VD = MD;
      var zD = n(332);
      var FD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      FD.insert = 'head';
      FD.singleton = true;
      var ND = Bl()(zD.Z, FD);
      const LD = zD.Z.locals || {};
      class HD extends Vl {
        constructor(t, e) {
          super(t);
          this._config = e;
          this.filteredView = e.filteredView;
          this.queryView = this._createSearchTextQueryView();
          this.focusTracker = new ul();
          this.keystrokes = new fl();
          this.resultsView = new RD(t);
          this.children = this.createCollection();
          this.focusableChildren = this.createCollection([
            this.queryView,
            this.resultsView,
          ]);
          this.set('isEnabled', true);
          this.set('resultsCount', 0);
          this.set('totalItemsCount', 0);
          if (e.infoView && e.infoView.instance) {
            this.infoView = e.infoView.instance;
          } else {
            this.infoView = new BD();
            this._enableDefaultInfoViewBehavior();
            this.on('render', () => {
              this.search('');
            });
          }
          this.resultsView.children.addMany([this.infoView, this.filteredView]);
          this.focusCycler = new Ch({
            focusables: this.focusableChildren,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: 'shift + tab', focusNext: 'tab' },
          });
          this.on('search', (t, { resultsCount: e, totalItemsCount: n }) => {
            this.resultsCount = e;
            this.totalItemsCount = n;
          });
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: ['ck', 'ck-search', e.class || null],
              tabindex: '-1',
            },
            children: this.children,
          });
        }
        render() {
          super.render();
          this.children.addMany([this.queryView, this.resultsView]);
          const t = t => t.stopPropagation();
          for (const t of this.focusableChildren) {
            this.focusTracker.add(t.element);
          }
          this.keystrokes.listenTo(this.element);
          this.keystrokes.set('arrowright', t);
          this.keystrokes.set('arrowleft', t);
          this.keystrokes.set('arrowup', t);
          this.keystrokes.set('arrowdown', t);
        }
        focus() {
          this.queryView.focus();
        }
        reset() {
          this.queryView.reset();
          this.search('');
        }
        search(t) {
          const e = t ? new RegExp(VD(t), 'ig') : null;
          const n = this.filteredView.filter(e);
          this.fire('search', { query: t, ...n });
        }
        _createSearchTextQueryView() {
          const t = new PD(this.locale, this._config.queryView);
          this.listenTo(t.fieldView, 'input', () => {
            this.search(t.fieldView.element.value);
          });
          t.on('reset', () => this.reset());
          t.bind('isEnabled').to(this);
          return t;
        }
        _enableDefaultInfoViewBehavior() {
          const t = this.locale.t;
          const e = this.infoView;
          this.on('search', (o, i) => {
            if (!i.resultsCount) {
              const o = this._config.infoView && this._config.infoView.text;
              let r, s;
              if (i.totalItemsCount) {
                if (o && o.notFound) {
                  r = o.notFound.primary;
                  s = o.notFound.secondary;
                } else {
                  r = t('No results found');
                  s = '';
                }
              } else {
                if (o && o.noSearchableItems) {
                  r = o.noSearchableItems.primary;
                  s = o.noSearchableItems.secondary;
                } else {
                  r = t('No searchable items');
                  s = '';
                }
              }
              e.set({
                primaryText: n(r, i),
                secondaryText: n(s, i),
                isVisible: true,
              });
            } else {
              e.set({ isVisible: false });
            }
          });
          function n(t, { query: e, resultsCount: n, totalItemsCount: o }) {
            return typeof t === 'function' ? t(e, n, o) : t;
          }
        }
      }
      var jD = n(29);
      var qD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      qD.insert = 'head';
      qD.singleton = true;
      var $D = Bl()(jD.Z, qD);
      const WD = jD.Z.locals || {};
      class GD extends HD {
        constructor(t, e) {
          super(t, e);
          this._config = e;
          const n = kc('px');
          this.extendTemplate({ attributes: { class: ['ck-autocomplete'] } });
          const o = this.resultsView.bindTemplate;
          this.resultsView.set('isVisible', false);
          this.resultsView.set('_position', 's');
          this.resultsView.set('_width', 0);
          this.resultsView.extendTemplate({
            attributes: {
              class: [
                o.if('isVisible', 'ck-hidden', t => !t),
                o.to('_position', t => `ck-search__results_${t}`),
              ],
              style: { width: o.to('_width', n) },
            },
          });
          this.focusTracker.on('change:isFocused', (t, n, o) => {
            this._updateResultsVisibility();
            if (o) {
              this.resultsView.element.scrollTop = 0;
            } else if (e.resetOnBlur) {
              this.queryView.reset();
            }
          });
          this.on('search', () => {
            this._updateResultsVisibility();
            this._updateResultsViewWidthAndPosition();
          });
          this.keystrokes.set('esc', (t, e) => {
            if (!this.resultsView.isVisible) {
              return;
            }
            this.queryView.focus();
            this.resultsView.isVisible = false;
            e();
          });
          this.listenTo(Xa.document, 'scroll', () => {
            this._updateResultsViewWidthAndPosition();
          });
          this.on('change:isEnabled', () => {
            this._updateResultsVisibility();
          });
          this.filteredView.on('execute', (t, { value: e }) => {
            this.focus();
            this.reset();
            this.queryView.fieldView.value =
              this.queryView.fieldView.element.value = e;
            this.resultsView.isVisible = false;
          });
          this.resultsView.on('change:isVisible', () => {
            this._updateResultsViewWidthAndPosition();
          });
        }
        _updateResultsViewWidthAndPosition() {
          if (!this.resultsView.isVisible) {
            return;
          }
          this.resultsView._width = new cc(
            this.queryView.fieldView.element,
          ).width;
          const t = GD._getOptimalPosition({
            element: this.resultsView.element,
            target: this.queryView.element,
            fitInViewport: true,
            positions: GD.defaultResultsPositions,
          });
          this.resultsView._position = t ? t.name : 's';
        }
        _updateResultsVisibility() {
          const t =
            typeof this._config.queryMinChars === 'undefined'
              ? 0
              : this._config.queryMinChars;
          const e = this.queryView.fieldView.element.value.length;
          this.resultsView.isVisible =
            this.focusTracker.isFocused && this.isEnabled && e >= t;
        }
      }
      GD.defaultResultsPositions = [
        t => ({ top: t.bottom, left: t.left, name: 's' }),
        (t, e) => ({ top: t.top - e.height, left: t.left, name: 'n' }),
      ];
      GD._getOptimalPosition = Cc;
      var KD = n(746);
      var UD = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      UD.insert = 'head';
      UD.singleton = true;
      var ZD = Bl()(KD.Z, UD);
      const JD = KD.Z.locals || {};
      class YD extends (null && View) {
        constructor() {
          super();
          this.set('text', undefined);
          this.setTemplate({
            tag: 'span',
            attributes: { class: ['ck', 'ck-highlighted-text'] },
          });
          this.on('render', () => {
            this.on('change:text', () => {
              this._updateInnerHTML(this.text);
            });
            this._updateInnerHTML(this.text);
          });
        }
        highlightText(t) {
          this._updateInnerHTML(QD(this.text || '', t));
        }
        _updateInnerHTML(t) {
          this.element.innerHTML = t || '';
        }
      }
      function QD(t, e) {
        if (!e) {
          return escape(t);
        }
        const n = [];
        let o = 0;
        let i = e.exec(t);
        while (i !== null) {
          const r = i.index;
          if (r !== o) {
            n.push({ text: t.substring(o, r), isMatch: false });
          }
          n.push({ text: i[0], isMatch: true });
          o = e.lastIndex;
          i = e.exec(t);
        }
        if (o !== t.length) {
          n.push({ text: t.substring(o), isMatch: false });
        }
        const r = n
          .map(t => {
            t.text = escape(t.text);
            return t;
          })
          .map(t => (t.isMatch ? `<mark>${t.text}</mark>` : t.text))
          .join('');
        return r;
      }
      var XD = n(446);
      var tT = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      tT.insert = 'head';
      tT.singleton = true;
      var eT = Bl()(XD.Z, tT);
      const nT = XD.Z.locals || {};
      class oT extends (null && View) {
        constructor() {
          super();
          this.set('isVisible', false);
          const t = this.bindTemplate;
          this.setTemplate({
            tag: 'span',
            attributes: {
              class: [
                'ck',
                'ck-spinner-container',
                t.if('isVisible', 'ck-hidden', t => !t),
              ],
            },
            children: [
              { tag: 'span', attributes: { class: ['ck', 'ck-spinner'] } },
            ],
          });
        }
      }
      const iT = kc('px');
      class rT extends (null && Plugin) {
        static get pluginName() {
          return 'BalloonToolbar';
        }
        static get requires() {
          return [ContextualBalloon];
        }
        constructor(t) {
          super(t);
          this._resizeObserver = null;
          this._balloonConfig = normalizeToolbarConfig(
            t.config.get('balloonToolbar'),
          );
          this.toolbarView = this._createToolbarView();
          this.focusTracker = new FocusTracker();
          t.ui.once('ready', () => {
            this.focusTracker.add(t.ui.getEditableElement());
            this.focusTracker.add(this.toolbarView.element);
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          });
          this._balloon = t.plugins.get(ContextualBalloon);
          this._fireSelectionChangeDebounced = debounce(
            () => this.fire('_selectionChangeDebounced'),
            200,
          );
          this.decorate('show');
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          this.listenTo(this.focusTracker, 'change:isFocused', (t, e, n) => {
            const o = this._balloon.visibleView === this.toolbarView;
            if (!n && o) {
              this.hide();
            } else if (n) {
              this.show();
            }
          });
          this.listenTo(e, 'change:range', (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide();
            }
            this._fireSelectionChangeDebounced();
          });
          this.listenTo(this, '_selectionChangeDebounced', () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show();
            }
          });
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, 'ready', () => {
              const e = t.ui.view.editable.element;
              this._resizeObserver = new ResizeObserver(e, t => {
                this.toolbarView.maxWidth = iT(t.contentRect.width * 0.9);
              });
            });
          }
          this.listenTo(this.toolbarView, 'groupedItemsUpdate', () => {
            this._updatePosition();
          });
        }
        afterInit() {
          const t = this.editor.ui.componentFactory;
          this.toolbarView.fillFromConfig(this._balloonConfig, t);
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._balloonConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t('Editor contextual toolbar');
          n.render();
          return n;
        }
        show(t = false) {
          const e = this.editor;
          const n = e.model.document.selection;
          const o = e.model.schema;
          if (this._balloon.hasView(this.toolbarView)) {
            return;
          }
          if (n.isCollapsed && !t) {
            return;
          }
          if (sT(n, o)) {
            return;
          }
          if (
            Array.from(this.toolbarView.items).every(
              t => t.isEnabled !== undefined && !t.isEnabled,
            )
          ) {
            return;
          }
          this.listenTo(this.editor.ui, 'update', () => {
            this._updatePosition();
          });
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: 'ck-toolbar-container',
          });
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, 'update');
            this._balloon.remove(this.toolbarView);
          }
        }
        _getBalloonPositionData() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = n.selection;
          const i = n.selection.isBackward;
          return {
            target: () => {
              const t = i ? o.getFirstRange() : o.getLastRange();
              const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t));
              if (i) {
                return n[0];
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop();
                }
                return n[n.length - 1];
              }
            },
            positions: this._getBalloonPositions(i),
          };
        }
        _updatePosition() {
          this._balloon.updatePosition(this._getBalloonPositionData());
        }
        destroy() {
          super.destroy();
          this.stopListening();
          this._fireSelectionChangeDebounced.cancel();
          this.toolbarView.destroy();
          this.focusTracker.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _getBalloonPositions(t) {
          const e = env.isSafari && env.isiOS;
          const n = e
            ? generatePositions({
                heightOffset: Math.max(
                  BalloonPanelView.arrowHeightOffset,
                  Math.round(20 / global.window.visualViewport.scale),
                ),
              })
            : BalloonPanelView.defaultPositions;
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ];
        }
      }
      function sT(t, e) {
        if (t.rangeCount === 1) {
          return false;
        }
        return [...t.getRanges()].every(t => {
          const n = t.getContainedElement();
          return n && e.isSelectable(n);
        });
      }
      var aT = n(176);
      var cT = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      cT.insert = 'head';
      cT.singleton = true;
      var lT = Bl()(aT.Z, cT);
      const dT = aT.Z.locals || {};
      const hT = kc('px');
      class uT extends (null && ButtonView) {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.isVisible = false;
          this.isToggleable = true;
          this.set('top', 0);
          this.set('left', 0);
          this.extendTemplate({
            attributes: {
              class: 'ck-block-toolbar-button',
              style: {
                top: e.to('top', t => hT(t)),
                left: e.to('left', t => hT(t)),
              },
            },
          });
        }
      }
      const fT = kc('px');
      class pT extends (null && Plugin) {
        static get pluginName() {
          return 'BlockToolbar';
        }
        constructor(t) {
          super(t);
          this._resizeObserver = null;
          this._blockToolbarConfig = normalizeToolbarConfig(
            this.editor.config.get('blockToolbar'),
          );
          this.toolbarView = this._createToolbarView();
          this.panelView = this._createPanelView();
          this.buttonView = this._createButtonView();
          clickOutsideHandler({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          });
        }
        init() {
          const t = this.editor;
          const e = t.t;
          const n = e('Click to edit block');
          const o = e('Drag to move');
          const i = e('Edit block');
          const r = t.plugins.has('DragDropBlockToolbar');
          const s = r ? `${n}\n${o}` : i;
          this.buttonView.label = s;
          if (r) {
            this.buttonView.element.dataset.ckeTooltipClass =
              'ck-tooltip_multi-line';
          }
          this.listenTo(t.model.document.selection, 'change:range', (t, e) => {
            if (e.directChange) {
              this._hidePanel();
            }
          });
          this.listenTo(t.ui, 'update', () => this._updateButton());
          this.listenTo(t, 'change:isReadOnly', () => this._updateButton(), {
            priority: 'low',
          });
          this.listenTo(t.ui.focusTracker, 'change:isFocused', () =>
            this._updateButton(),
          );
          this.listenTo(this.buttonView, 'change:isVisible', (t, e, n) => {
            if (n) {
              this.buttonView.listenTo(window, 'resize', () =>
                this._updateButton(),
              );
            } else {
              this.buttonView.stopListening(window, 'resize');
              this._hidePanel();
            }
          });
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          });
        }
        afterInit() {
          this.toolbarView.fillFromConfig(
            this._blockToolbarConfig,
            this.editor.ui.componentFactory,
          );
          for (const t of this.toolbarView.items) {
            t.on('execute', () => this._hidePanel(true), { priority: 'high' });
          }
        }
        destroy() {
          super.destroy();
          this.panelView.destroy();
          this.buttonView.destroy();
          this.toolbarView.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t;
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull;
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          });
          n.ariaLabel = t('Editor block content toolbar');
          return n;
        }
        _createPanelView() {
          const t = this.editor;
          const e = new BalloonPanelView(t.locale);
          e.content.add(this.toolbarView);
          e.class = 'ck-toolbar-container';
          t.ui.view.body.add(e);
          t.ui.focusTracker.add(e.element);
          this.toolbarView.keystrokes.set('Esc', (t, e) => {
            this._hidePanel(true);
            e();
          });
          return e;
        }
        _createButtonView() {
          const t = this.editor;
          const e = t.t;
          const n = new BlockButtonView(t.locale);
          const o = this._blockToolbarConfig.icon;
          const i =
            NESTED_TOOLBAR_ICONS[o] || o || NESTED_TOOLBAR_ICONS.dragIndicator;
          n.set({ label: e('Edit block'), icon: i, withText: false });
          n.bind('isOn').to(this.panelView, 'isVisible');
          n.bind('tooltip').to(this.panelView, 'isVisible', t => !t);
          this.listenTo(n, 'execute', () => {
            if (!this.panelView.isVisible) {
              this._showPanel();
            } else {
              this._hidePanel(true);
            }
          });
          t.ui.view.body.add(n);
          t.ui.focusTracker.add(n.element);
          return n;
        }
        _updateButton() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton();
            return;
          }
          if (!t.model.canEditAt(t.model.document.selection)) {
            this._hideButton();
            return;
          }
          const o = Array.from(e.document.selection.getSelectedBlocks())[0];
          if (
            !o ||
            Array.from(this.toolbarView.items).every(t => !t.isEnabled)
          ) {
            this._hideButton();
            return;
          }
          const i = n.domConverter.mapViewToDom(
            t.editing.mapper.toViewElement(o),
          );
          this.buttonView.isVisible = true;
          this._setupToolbarResize();
          this._attachButtonToElement(i);
          if (this.panelView.isVisible) {
            this._showPanel();
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false;
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return;
          }
          const t = this.panelView.isVisible;
          this.panelView.show();
          const e = this._getSelectedEditableElement();
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(e);
          this.panelView.pin({ target: this.buttonView.element, limiter: e });
          if (!t) {
            this.toolbarView.items.get(0).focus();
          }
        }
        _getSelectedEditableElement() {
          const t =
            this.editor.model.document.selection.getFirstRange().root.rootName;
          return this.editor.ui.getEditableElement(t);
        }
        _hidePanel(t) {
          this.panelView.isVisible = false;
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t);
          const n = new Rect(this._getSelectedEditableElement());
          const o = parseInt(e.paddingTop, 10);
          const i =
            parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2;
          const r = new Rect(this.buttonView.element);
          const s = new Rect(t);
          let a;
          if (this.editor.locale.uiLanguageDirection === 'ltr') {
            a = n.left - r.width;
          } else {
            a = n.right;
          }
          const c = s.top + o + (i - r.height) / 2;
          r.moveTo(a, c);
          const l = r.toAbsoluteRect();
          this.buttonView.top = l.top;
          this.buttonView.left = l.left;
        }
        _setupToolbarResize() {
          const t = this._getSelectedEditableElement();
          if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
            if (this._resizeObserver && this._resizeObserver.element !== t) {
              this._resizeObserver.destroy();
              this._resizeObserver = null;
            }
            if (!this._resizeObserver) {
              this._resizeObserver = new ResizeObserver(t, () => {
                this.toolbarView.maxWidth = this._getToolbarMaxWidth(t);
              });
            }
          }
        }
        _getToolbarMaxWidth(t) {
          const e = new Rect(t);
          const n = new Rect(this.buttonView.element);
          const o = this.editor.locale.uiLanguageDirection === 'rtl';
          const i = o ? n.left - e.right + n.width : e.left - n.left;
          return fT(e.width + i);
        }
      }
      const gT =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
      const mT = { colorPaletteIcon: gT };
      class kT extends GE {
        constructor(t, e) {
          super(t);
          this.view = e;
          this._toolbarConfig = Th(t.config.get('toolbar'));
          this._elementReplacer = new vt();
          this.listenTo(
            t.editing.view,
            'scrollToTheSelection',
            this._handleScrollToTheSelectionWithStickyPanel.bind(this),
          );
        }
        get element() {
          return this.view.element;
        }
        init(t) {
          const e = this.editor;
          const n = this.view;
          const o = e.editing.view;
          const i = n.editable;
          const r = o.document.getRoot();
          i.name = r.rootName;
          n.render();
          const s = i.element;
          this.setEditableElement(i.name, s);
          n.editable.bind('isFocused').to(this.focusTracker);
          o.attachDomRoot(s);
          if (t) {
            this._elementReplacer.replace(t, this.element);
          }
          this._initPlaceholder();
          this._initToolbar();
          this.fire('ready');
        }
        destroy() {
          super.destroy();
          const t = this.view;
          const e = this.editor.editing.view;
          this._elementReplacer.restore();
          e.detachDomRoot(t.editable.name);
          t.destroy();
        }
        _initToolbar() {
          const t = this.view;
          t.stickyPanel.bind('isActive').to(this.focusTracker, 'isFocused');
          t.stickyPanel.limiterElement = t.element;
          t.stickyPanel
            .bind('viewportTopOffset')
            .to(this, 'viewportOffset', ({ top: t }) => t || 0);
          t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
          this.addToolbar(t.toolbar);
        }
        _initPlaceholder() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document.getRoot();
          const o = t.sourceElement;
          let i;
          const r = t.config.get('placeholder');
          if (r) {
            i = typeof r === 'string' ? r : r[this.view.editable.name];
          }
          if (!i && o && o.tagName.toLowerCase() === 'textarea') {
            i = o.getAttribute('placeholder');
          }
          if (i) {
            n.placeholder = i;
          }
          qh({ view: e, element: n, isDirectHost: false, keepOnFocus: true });
        }
        _handleScrollToTheSelectionWithStickyPanel(t, e, n) {
          const o = this.view.stickyPanel;
          if (o.isSticky) {
            const t = new cc(o.element).height;
            e.viewportOffset.top += t;
          } else {
            const t = () => {
              this.editor.editing.view.scrollToTheSelection(n);
            };
            this.listenTo(o, 'change:isSticky', t);
            setTimeout(() => {
              this.stopListening(o, 'change:isSticky', t);
            }, 20);
          }
        }
      }
      var bT = n(624);
      var wT = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      wT.insert = 'head';
      wT.singleton = true;
      var _T = Bl()(bT.Z, wT);
      const vT = bT.Z.locals || {};
      class AT extends XE {
        constructor(t, e, n = {}) {
          super(t);
          this.stickyPanel = new SD(t);
          this.toolbar = new GC(t, {
            shouldGroupWhenFull: n.shouldToolbarGroupWhenFull,
          });
          this.editable = new eD(t, e);
        }
        render() {
          super.render();
          this.stickyPanel.content.add(this.toolbar);
          this.top.add(this.stickyPanel);
          this.main.add(this.editable);
        }
      }
      class CT {
        constructor(t) {
          this.crashes = [];
          this.state = 'initializing';
          this._now = Date.now;
          this.crashes = [];
          this._crashNumberLimit =
            typeof t.crashNumberLimit === 'number' ? t.crashNumberLimit : 3;
          this._minimumNonErrorTimePeriod =
            typeof t.minimumNonErrorTimePeriod === 'number'
              ? t.minimumNonErrorTimePeriod
              : 5e3;
          this._boundErrorHandler = t => {
            const e = 'error' in t ? t.error : t.reason;
            if (e instanceof Error) {
              this._handleError(e, t);
            }
          };
          this._listeners = {};
          if (!this._restart) {
            throw new Error(
              'The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. ' +
                'Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.',
            );
          }
        }
        destroy() {
          this._stopErrorHandling();
          this._listeners = {};
        }
        on(t, e) {
          if (!this._listeners[t]) {
            this._listeners[t] = [];
          }
          this._listeners[t].push(e);
        }
        off(t, e) {
          this._listeners[t] = this._listeners[t].filter(t => t !== e);
        }
        _fire(t, ...e) {
          const n = this._listeners[t] || [];
          for (const t of n) {
            t.apply(this, [null, ...e]);
          }
        }
        _startErrorHandling() {
          window.addEventListener('error', this._boundErrorHandler);
          window.addEventListener(
            'unhandledrejection',
            this._boundErrorHandler,
          );
        }
        _stopErrorHandling() {
          window.removeEventListener('error', this._boundErrorHandler);
          window.removeEventListener(
            'unhandledrejection',
            this._boundErrorHandler,
          );
        }
        _handleError(t, e) {
          if (this._shouldReactToError(t)) {
            this.crashes.push({
              message: t.message,
              stack: t.stack,
              filename: e instanceof ErrorEvent ? e.filename : undefined,
              lineno: e instanceof ErrorEvent ? e.lineno : undefined,
              colno: e instanceof ErrorEvent ? e.colno : undefined,
              date: this._now(),
            });
            const n = this._shouldRestart();
            this.state = 'crashed';
            this._fire('stateChange');
            this._fire('error', { error: t, causesRestart: n });
            if (n) {
              this._restart();
            } else {
              this.state = 'crashedPermanently';
              this._fire('stateChange');
            }
          }
        }
        _shouldReactToError(t) {
          return (
            t.is &&
            t.is('CKEditorError') &&
            t.context !== undefined &&
            t.context !== null &&
            this.state === 'ready' &&
            this._isErrorComingFromThisItem(t)
          );
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit) {
            return true;
          }
          const t = this.crashes[this.crashes.length - 1].date;
          const e =
            this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
          const n = (t - e) / this._crashNumberLimit;
          return n > this._minimumNonErrorTimePeriod;
        }
      }
      function yT(t, e = new Set()) {
        const n = [t];
        const o = new Set();
        let i = 0;
        while (n.length > i) {
          const t = n[i++];
          if (o.has(t) || !xT(t) || e.has(t)) {
            continue;
          }
          o.add(t);
          if (Symbol.iterator in t) {
            try {
              for (const e of t) {
                n.push(e);
              }
            } catch (t) {}
          } else {
            for (const e in t) {
              if (e === 'defaultValue') {
                continue;
              }
              n.push(t[e]);
            }
          }
        }
        return o;
      }
      function xT(t) {
        const e = Object.prototype.toString.call(t);
        const n = typeof t;
        return !(
          n === 'number' ||
          n === 'boolean' ||
          n === 'string' ||
          n === 'symbol' ||
          n === 'function' ||
          e === '[object Date]' ||
          e === '[object RegExp]' ||
          e === '[object Module]' ||
          t === undefined ||
          t === null ||
          t._watchdogExcluded ||
          t instanceof EventTarget ||
          t instanceof Event
        );
      }
      function ET(t, e, n = new Set()) {
        if (t === e && TT(t)) {
          return true;
        }
        const o = yT(t, n);
        const i = yT(e, n);
        for (const t of o) {
          if (i.has(t)) {
            return true;
          }
        }
        return false;
      }
      function DT(t, e, n) {
        const { subNodes: o, prevNodeMap: i } = getSubNodes(t, n.subNodes);
        const { subNodes: r, prevNodeMap: s } = getSubNodes(e, n.subNodes);
        for (const n of o) {
          if (r.has(n)) {
            const o = [];
            o.push(n);
            let r = i.get(n);
            while (r && r !== t) {
              o.push(r);
              r = i.get(r);
            }
            r = s.get(n);
            while (r && r !== e) {
              o.unshift(r);
              r = s.get(r);
            }
            console.log('--------');
            console.log({ target1: t });
            console.log({ sharedNode: n });
            console.log({ target2: e });
            console.log({ connection: o });
            return true;
          }
        }
        return false;
      }
      function TT(t) {
        return typeof t === 'object' && t !== null;
      }
      class ST extends CT {
        constructor(t, e = {}) {
          super(e);
          this._editor = null;
          this._initUsingData = true;
          this._editables = {};
          this._throttledSave = yE(
            this._save.bind(this),
            typeof e.saveInterval === 'number' ? e.saveInterval : 5e3,
          );
          if (t) {
            this._creator = (e, n) => t.create(e, n);
          }
          this._destructor = t => t.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(t) {
          this._creator = t;
        }
        setDestructor(t) {
          this._destructor = t;
        }
        _restart() {
          return Promise.resolve()
            .then(() => {
              this.state = 'initializing';
              this._fire('stateChange');
              return this._destroy();
            })
            .catch(t => {
              console.error(
                'An error happened during the editor destroying.',
                t,
              );
            })
            .then(() => {
              const t = {};
              const e = [];
              const n = this._config.rootsAttributes || {};
              const o = {};
              for (const [i, r] of Object.entries(this._data.roots)) {
                if (r.isLoaded) {
                  t[i] = '';
                  o[i] = n[i] || {};
                } else {
                  e.push(i);
                }
              }
              const i = {
                ...this._config,
                extraPlugins: this._config.extraPlugins || [],
                lazyRoots: e,
                rootsAttributes: o,
                _watchdogInitialData: this._data,
              };
              delete i.initialData;
              i.extraPlugins.push(PT);
              if (this._initUsingData) {
                return this.create(t, i, i.context);
              } else {
                if (Ha(this._elementOrData)) {
                  return this.create(this._elementOrData, i, i.context);
                } else {
                  return this.create(this._editables, i, i.context);
                }
              }
            })
            .then(() => {
              this._fire('restart');
            });
        }
        create(t = this._elementOrData, e = this._config, n) {
          return Promise.resolve()
            .then(() => {
              super._startErrorHandling();
              this._elementOrData = t;
              this._initUsingData =
                typeof t == 'string' ||
                (Object.keys(t).length > 0 &&
                  typeof Object.values(t)[0] == 'string');
              this._config = this._cloneEditorConfiguration(e) || {};
              this._config.context = n;
              return this._creator(t, this._config);
            })
            .then(t => {
              this._editor = t;
              t.model.document.on('change:data', this._throttledSave);
              this._lastDocumentVersion = t.model.document.version;
              this._data = this._getData();
              if (!this._initUsingData) {
                this._editables = this._getEditables();
              }
              this.state = 'ready';
              this._fire('stateChange');
            });
        }
        destroy() {
          return Promise.resolve().then(() => {
            this.state = 'destroyed';
            this._fire('stateChange');
            super.destroy();
            return this._destroy();
          });
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            this._throttledSave.cancel();
            const t = this._editor;
            this._editor = null;
            t.model.document.off('change:data', this._throttledSave);
            return this._destructor(t);
          });
        }
        _save() {
          const t = this._editor.model.document.version;
          try {
            this._data = this._getData();
            if (!this._initUsingData) {
              this._editables = this._getEditables();
            }
            this._lastDocumentVersion = t;
          } catch (t) {
            console.error(
              t,
              'An error happened during restoring editor data. ' +
                'Editor will be restored from the previously saved data.',
            );
          }
        }
        _setExcludedProperties(t) {
          this._excludedProps = t;
        }
        _getData() {
          const t = this._editor;
          const e = t.model.document.roots.filter(
            t => t.isAttached() && t.rootName != '$graveyard',
          );
          const { plugins: n } = t;
          const o = n.has('CommentsRepository') && n.get('CommentsRepository');
          const i = n.has('TrackChanges') && n.get('TrackChanges');
          const r = {
            roots: {},
            markers: {},
            commentThreads: JSON.stringify([]),
            suggestions: JSON.stringify([]),
          };
          e.forEach(t => {
            r.roots[t.rootName] = {
              content: JSON.stringify(Array.from(t.getChildren())),
              attributes: JSON.stringify(Array.from(t.getAttributes())),
              isLoaded: t._isLoaded,
            };
          });
          for (const e of t.model.markers) {
            if (!e._affectsData) {
              continue;
            }
            r.markers[e.name] = {
              rangeJSON: e.getRange().toJSON(),
              usingOperation: e._managedUsingOperations,
              affectsData: e._affectsData,
            };
          }
          if (o) {
            r.commentThreads = JSON.stringify(
              o.getCommentThreads({ toJSON: true, skipNotAttached: true }),
            );
          }
          if (i) {
            r.suggestions = JSON.stringify(
              i.getSuggestions({ toJSON: true, skipNotAttached: true }),
            );
          }
          return r;
        }
        _getEditables() {
          const t = {};
          for (const e of this.editor.model.document.getRootNames()) {
            const n = this.editor.ui.getEditableElement(e);
            if (n) {
              t[e] = n;
            }
          }
          return t;
        }
        _isErrorComingFromThisItem(t) {
          return ET(this._editor, t.context, this._excludedProps);
        }
        _cloneEditorConfiguration(t) {
          return Na(t, (t, e) => {
            if (Ha(t)) {
              return t;
            }
            if (e === 'context') {
              return t;
            }
          });
        }
      }
      class PT {
        constructor(t) {
          this.editor = t;
          this._data = t.config.get('_watchdogInitialData');
        }
        init() {
          this.editor.data.on(
            'init',
            t => {
              t.stop();
              this.editor.model.enqueueChange({ isUndoable: false }, t => {
                this._restoreCollaborationData();
                this._restoreEditorData(t);
              });
              this.editor.data.fire('ready');
            },
            { priority: 1e3 - 1 },
          );
        }
        _createNode(t, e) {
          if ('name' in e) {
            const n = t.createElement(e.name, e.attributes);
            if (e.children) {
              for (const o of e.children) {
                n._appendChild(this._createNode(t, o));
              }
            }
            return n;
          } else {
            return t.createText(e.data, e.attributes);
          }
        }
        _restoreEditorData(t) {
          const e = this.editor;
          Object.entries(this._data.roots).forEach(
            ([n, { content: o, attributes: i }]) => {
              const r = JSON.parse(o);
              const s = JSON.parse(i);
              const a = e.model.document.getRoot(n);
              for (const [e, n] of s) {
                t.setAttribute(e, n, a);
              }
              for (const e of r) {
                const n = this._createNode(t, e);
                t.insert(n, a, 'end');
              }
            },
          );
          Object.entries(this._data.markers).forEach(([n, o]) => {
            const { document: i } = e.model;
            const {
              rangeJSON: { start: r, end: s },
              ...a
            } = o;
            const c = i.getRoot(r.root);
            const l = t.createPositionFromPath(c, r.path, r.stickiness);
            const d = t.createPositionFromPath(c, s.path, s.stickiness);
            const h = t.createRange(l, d);
            t.addMarker(n, { range: h, ...a });
          });
        }
        _restoreCollaborationData() {
          const t = JSON.parse(this._data.commentThreads);
          const e = JSON.parse(this._data.suggestions);
          t.forEach(t => {
            const e = this.editor.config.get('collaboration.channelId');
            const n = this.editor.plugins.get('CommentsRepository');
            if (n.hasCommentThread(t.threadId)) {
              const e = n.getCommentThread(t.threadId);
              e.remove();
            }
            n.addCommentThread({ channelId: e, ...t });
          });
          e.forEach(t => {
            const e = this.editor.plugins.get('TrackChangesEditing');
            if (e.hasSuggestion(t.id)) {
              const n = e.getSuggestion(t.id);
              n.attributes = t.attributes;
            } else {
              e.addSuggestionData(t);
            }
          });
        }
      }
      const BT = Symbol('MainQueueId');
      class RT extends CT {
        constructor(t, e = {}) {
          super(e);
          this._watchdogs = new Map();
          this._context = null;
          this._contextProps = new Set();
          this._actionQueues = new OT();
          this._watchdogConfig = e;
          this._creator = e => t.create(e);
          this._destructor = t => t.destroy();
          this._actionQueues.onEmpty(() => {
            if (this.state === 'initializing') {
              this.state = 'ready';
              this._fire('stateChange');
            }
          });
        }
        setCreator(t) {
          this._creator = t;
        }
        setDestructor(t) {
          this._destructor = t;
        }
        get context() {
          return this._context;
        }
        create(t = {}) {
          return this._actionQueues.enqueue(BT, () => {
            this._contextConfig = t;
            return this._create();
          });
        }
        getItem(t) {
          const e = this._getWatchdog(t);
          return e._item;
        }
        getItemState(t) {
          const e = this._getWatchdog(t);
          return e.state;
        }
        add(t) {
          const e = IT(t);
          return Promise.all(
            e.map(t =>
              this._actionQueues.enqueue(t.id, () => {
                if (this.state === 'destroyed') {
                  throw new Error('Cannot add items to destroyed watchdog.');
                }
                if (!this._context) {
                  throw new Error(
                    'Context was not created yet. You should call the `ContextWatchdog#create()` method first.',
                  );
                }
                let e;
                if (this._watchdogs.has(t.id)) {
                  throw new Error(
                    `Item with the given id is already added: '${t.id}'.`,
                  );
                }
                if (t.type === 'editor') {
                  e = new ST(null, this._watchdogConfig);
                  e.setCreator(t.creator);
                  e._setExcludedProperties(this._contextProps);
                  if (t.destructor) {
                    e.setDestructor(t.destructor);
                  }
                  this._watchdogs.set(t.id, e);
                  e.on('error', (n, { error: o, causesRestart: i }) => {
                    this._fire('itemError', { itemId: t.id, error: o });
                    if (!i) {
                      return;
                    }
                    this._actionQueues.enqueue(
                      t.id,
                      () =>
                        new Promise(n => {
                          const o = () => {
                            e.off('restart', o);
                            this._fire('itemRestart', { itemId: t.id });
                            n();
                          };
                          e.on('restart', o);
                        }),
                    );
                  });
                  return e.create(
                    t.sourceElementOrData,
                    t.config,
                    this._context,
                  );
                } else {
                  throw new Error(`Not supported item type: '${t.type}'.`);
                }
              }),
            ),
          );
        }
        remove(t) {
          const e = IT(t);
          return Promise.all(
            e.map(t =>
              this._actionQueues.enqueue(t, () => {
                const e = this._getWatchdog(t);
                this._watchdogs.delete(t);
                return e.destroy();
              }),
            ),
          );
        }
        destroy() {
          return this._actionQueues.enqueue(BT, () => {
            this.state = 'destroyed';
            this._fire('stateChange');
            super.destroy();
            return this._destroy();
          });
        }
        _restart() {
          return this._actionQueues.enqueue(BT, () => {
            this.state = 'initializing';
            this._fire('stateChange');
            return this._destroy()
              .catch(t => {
                console.error(
                  'An error happened during destroying the context or items.',
                  t,
                );
              })
              .then(() => this._create())
              .then(() => this._fire('restart'));
          });
        }
        _create() {
          return Promise.resolve()
            .then(() => {
              this._startErrorHandling();
              return this._creator(this._contextConfig);
            })
            .then(t => {
              this._context = t;
              this._contextProps = yT(this._context);
              return Promise.all(
                Array.from(this._watchdogs.values()).map(t => {
                  t._setExcludedProperties(this._contextProps);
                  return t.create(undefined, undefined, this._context);
                }),
              );
            });
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const t = this._context;
            this._context = null;
            this._contextProps = new Set();
            return Promise.all(
              Array.from(this._watchdogs.values()).map(t => t.destroy()),
            ).then(() => this._destructor(t));
          });
        }
        _getWatchdog(t) {
          const e = this._watchdogs.get(t);
          if (!e) {
            throw new Error(`Item with the given id was not registered: ${t}.`);
          }
          return e;
        }
        _isErrorComingFromThisItem(t) {
          for (const e of this._watchdogs.values()) {
            if (e._isErrorComingFromThisItem(t)) {
              return false;
            }
          }
          return ET(this._context, t.context);
        }
      }
      class OT {
        constructor() {
          this._onEmptyCallbacks = [];
          this._queues = new Map();
          this._activeActions = 0;
        }
        onEmpty(t) {
          this._onEmptyCallbacks.push(t);
        }
        enqueue(t, e) {
          const n = t === BT;
          this._activeActions++;
          if (!this._queues.get(t)) {
            this._queues.set(t, Promise.resolve());
          }
          const o = n
            ? Promise.all(this._queues.values())
            : Promise.all([this._queues.get(BT), this._queues.get(t)]);
          const i = o.then(e);
          const r = i.catch(() => {});
          this._queues.set(t, r);
          return i.finally(() => {
            this._activeActions--;
            if (this._queues.get(t) === r && this._activeActions === 0) {
              this._onEmptyCallbacks.forEach(t => t());
            }
          });
        }
      }
      function IT(t) {
        return Array.isArray(t) ? t : [t];
      }
      class MT extends YA(QA(UA)) {
        constructor(t, e = {}) {
          if (!zT(t) && e.initialData !== undefined) {
            throw new B('editor-create-initial-data', null);
          }
          super(e);
          if (this.config.get('initialData') === undefined) {
            this.config.set('initialData', VT(t));
          }
          if (zT(t)) {
            this.sourceElement = t;
          }
          this.model.document.createRoot();
          const n = !this.config.get('toolbar.shouldNotGroupWhenFull');
          const o = new AT(this.locale, this.editing.view, {
            shouldToolbarGroupWhenFull: n,
          });
          this.ui = new kT(this, o);
          ZA(this);
        }
        destroy() {
          if (this.sourceElement) {
            this.updateSourceElement();
          }
          this.ui.destroy();
          return super.destroy();
        }
        static create(t, e = {}) {
          return new Promise(n => {
            const o = new this(t, e);
            n(
              o
                .initPlugins()
                .then(() => o.ui.init(zT(t) ? t : null))
                .then(() => o.data.init(o.config.get('initialData')))
                .then(() => o.fire('ready'))
                .then(() => o),
            );
          });
        }
      }
      MT.Context = Mh;
      MT.EditorWatchdog = ST;
      MT.ContextWatchdog = RT;
      function VT(t) {
        return zT(t) ? nc(t) : t;
      }
      function zT(t) {
        return Ha(t);
      }
      class FT extends Lg {
        constructor(t) {
          super(t);
          this.domEventType = [
            'paste',
            'copy',
            'cut',
            'drop',
            'dragover',
            'dragstart',
            'dragend',
            'dragenter',
            'dragleave',
          ];
          const e = this.document;
          this.listenTo(e, 'paste', n('clipboardInput'), { priority: 'low' });
          this.listenTo(e, 'drop', n('clipboardInput'), { priority: 'low' });
          this.listenTo(e, 'dragover', n('dragging'), { priority: 'low' });
          function n(t) {
            return (n, o) => {
              o.preventDefault();
              const i = o.dropRange ? [o.dropRange] : null;
              const r = new y(e, t);
              e.fire(r, {
                dataTransfer: o.dataTransfer,
                method: n.name,
                targetRanges: i,
                target: o.target,
                domEvent: o.domEvent,
              });
              if (r.stop.called) {
                o.stopPropagation();
              }
            };
          }
        }
        onDomEvent(t) {
          const e = 'clipboardData' in t ? t.clipboardData : t.dataTransfer;
          const n = t.type == 'drop' || t.type == 'paste';
          const o = { dataTransfer: new fk(e, { cacheFiles: n }) };
          if (t.type == 'drop' || t.type == 'dragover') {
            o.dropRange = NT(this.view, t);
          }
          this.fire(t.type, t, o);
        }
      }
      function NT(t, e) {
        const n = e.target.ownerDocument;
        const o = e.clientX;
        const i = e.clientY;
        let r;
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)) {
          r = n.caretRangeFromPoint(o, i);
        } else if (e.rangeParent) {
          r = n.createRange();
          r.setStart(e.rangeParent, e.rangeOffset);
          r.collapse(true);
        }
        if (r) {
          return t.domConverter.domRangeToView(r);
        }
        return null;
      }
      function LT(t) {
        t = t
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\r?\n\r?\n/g, '</p><p>')
          .replace(/\r?\n/g, '<br>')
          .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
          .replace(/^\s/, '&nbsp;')
          .replace(/\s$/, '&nbsp;')
          .replace(/\s\s/g, ' &nbsp;');
        if (t.includes('</p><p>') || t.includes('<br>')) {
          t = `<p>${t}</p>`;
        }
        return t;
      }
      function HT(t) {
        return t
          .replace(
            /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
            (t, e) => {
              if (e.length == 1) {
                return ' ';
              }
              return e;
            },
          )
          .replace(/<!--[\s\S]*?-->/g, '');
      }
      const jT = ['figcaption', 'li'];
      const qT = ['ol', 'ul'];
      function $T(t) {
        if (t.is('$text') || t.is('$textProxy')) {
          return t.data;
        }
        if (t.is('element', 'img') && t.hasAttribute('alt')) {
          return t.getAttribute('alt');
        }
        if (t.is('element', 'br')) {
          return '\n';
        }
        let e = '';
        let n = null;
        for (const o of t.getChildren()) {
          e += WT(o, n) + $T(o);
          n = o;
        }
        return e;
      }
      function WT(t, e) {
        if (!e) {
          return '';
        }
        if (
          t.is('element', 'li') &&
          !t.isEmpty &&
          t.getChild(0).is('containerElement')
        ) {
          return '\n\n';
        }
        if (qT.includes(t.name) && qT.includes(e.name)) {
          return '\n\n';
        }
        if (!t.is('containerElement') && !e.is('containerElement')) {
          return '';
        }
        if (jT.includes(t.name) || jT.includes(e.name)) {
          return '\n';
        }
        return '\n\n';
      }
      class GT extends Sh {
        static get pluginName() {
          return 'ClipboardPipeline';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          e.addObserver(FT);
          this._setupPasteDrop();
          this._setupCopyCut();
        }
        _fireOutputTransformationEvent(t, e, n) {
          const o = this.editor.model.getSelectedContent(e);
          this.fire('outputTransformation', {
            dataTransfer: t,
            content: o,
            method: n,
          });
        }
        _setupPasteDrop() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          this.listenTo(
            o,
            'clipboardInput',
            (e, n) => {
              if (
                n.method == 'paste' &&
                !t.model.canEditAt(t.model.document.selection)
              ) {
                e.stop();
              }
            },
            { priority: 'highest' },
          );
          this.listenTo(
            o,
            'clipboardInput',
            (t, e) => {
              const o = e.dataTransfer;
              let i;
              if (e.content) {
                i = e.content;
              } else {
                let t = '';
                if (o.getData('text/html')) {
                  t = HT(o.getData('text/html'));
                } else if (o.getData('text/plain')) {
                  t = LT(o.getData('text/plain'));
                }
                i = this.editor.data.htmlProcessor.toView(t);
              }
              const r = new y(this, 'inputTransformation');
              this.fire(r, {
                content: i,
                dataTransfer: o,
                targetRanges: e.targetRanges,
                method: e.method,
              });
              if (r.stop.called) {
                t.stop();
              }
              n.scrollToTheSelection();
            },
            { priority: 'low' },
          );
          this.listenTo(
            this,
            'inputTransformation',
            (t, n) => {
              if (n.content.isEmpty) {
                return;
              }
              const o = this.editor.data;
              const i = o.toModel(n.content, '$clipboardHolder');
              if (i.childCount == 0) {
                return;
              }
              t.stop();
              e.change(() => {
                this.fire('contentInsertion', {
                  content: i,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                });
              });
            },
            { priority: 'low' },
          );
          this.listenTo(
            this,
            'contentInsertion',
            (t, n) => {
              n.resultRange = e.insertContent(n.content);
            },
            { priority: 'low' },
          );
        }
        _setupCopyCut() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.editing.view;
          const o = n.document;
          const i = (t, n) => {
            const o = n.dataTransfer;
            n.preventDefault();
            this._fireOutputTransformationEvent(o, e.selection, t.name);
          };
          this.listenTo(o, 'copy', i, { priority: 'low' });
          this.listenTo(
            o,
            'cut',
            (e, n) => {
              if (!t.model.canEditAt(t.model.document.selection)) {
                n.preventDefault();
              } else {
                i(e, n);
              }
            },
            { priority: 'low' },
          );
          this.listenTo(
            this,
            'outputTransformation',
            (e, n) => {
              const i = t.data.toView(n.content);
              o.fire('clipboardOutput', {
                dataTransfer: n.dataTransfer,
                content: i,
                method: n.method,
              });
            },
            { priority: 'low' },
          );
          this.listenTo(
            o,
            'clipboardOutput',
            (n, o) => {
              if (!o.content.isEmpty) {
                o.dataTransfer.setData(
                  'text/html',
                  this.editor.data.htmlProcessor.toData(o.content),
                );
                o.dataTransfer.setData('text/plain', $T(o.content));
              }
              if (o.method == 'cut') {
                t.model.deleteContent(e.selection);
              }
            },
            { priority: 'low' },
          );
        }
      }
      class KT {
        constructor(t, e = 20) {
          this._batch = null;
          this.model = t;
          this._size = 0;
          this.limit = e;
          this._isLocked = false;
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true);
            }
          };
          this._selectionChangeCallback = () => {
            this._reset();
          };
          this.model.document.on('change', this._changeCallback);
          this.model.document.selection.on(
            'change:range',
            this._selectionChangeCallback,
          );
          this.model.document.selection.on(
            'change:attribute',
            this._selectionChangeCallback,
          );
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true });
          }
          return this._batch;
        }
        get size() {
          return this._size;
        }
        input(t) {
          this._size += t;
          if (this._size >= this.limit) {
            this._reset(true);
          }
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = true;
        }
        unlock() {
          this._isLocked = false;
        }
        destroy() {
          this.model.document.off('change', this._changeCallback);
          this.model.document.selection.off(
            'change:range',
            this._selectionChangeCallback,
          );
          this.model.document.selection.off(
            'change:attribute',
            this._selectionChangeCallback,
          );
        }
        _reset(t = false) {
          if (!this.isLocked || t) {
            this._batch = null;
            this._size = 0;
          }
        }
      }
      class UT extends Bh {
        constructor(t, e) {
          super(t);
          this._buffer = new KT(t.model, e);
          this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy();
          this._buffer.destroy();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.text || '';
          const i = o.length;
          let r = n.selection;
          if (t.selection) {
            r = t.selection;
          } else if (t.range) {
            r = e.createSelection(t.range);
          }
          if (!e.canEditAt(r)) {
            return;
          }
          const s = t.resultRange;
          e.enqueueChange(this._buffer.batch, t => {
            this._buffer.lock();
            e.deleteContent(r);
            if (o) {
              e.insertContent(t.createText(o, n.selection.getAttributes()), r);
            }
            if (s) {
              t.setSelection(s);
            } else if (!r.is('documentSelection')) {
              t.setSelection(r);
            }
            this._buffer.unlock();
            this._buffer.input(i);
          });
        }
      }
      const ZT = ['insertText', 'insertReplacementText'];
      class JT extends Vg {
        constructor(t) {
          super(t);
          this.focusObserver = t.getObserver(dk);
          if (s.isAndroid) {
            ZT.push('insertCompositionText');
          }
          const e = t.document;
          e.on('beforeinput', (n, o) => {
            if (!this.isEnabled) {
              return;
            }
            const { data: i, targetRanges: r, inputType: s, domEvent: a } = o;
            if (!ZT.includes(s)) {
              return;
            }
            this.focusObserver.flush();
            const c = new y(e, 'insertText');
            e.fire(
              c,
              new Ng(t, a, { text: i, selection: t.createSelection(r) }),
            );
            if (c.stop.called) {
              n.stop();
            }
          });
          e.on(
            'compositionend',
            (n, { data: o, domEvent: i }) => {
              if (!this.isEnabled || s.isAndroid) {
                return;
              }
              if (!o) {
                return;
              }
              e.fire(
                'insertText',
                new Ng(t, i, { text: o, selection: e.selection }),
              );
            },
            { priority: 'lowest' },
          );
        }
        observe() {}
        stopObserving() {}
      }
      class YT extends Sh {
        static get pluginName() {
          return 'Input';
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = e.document.selection;
          n.addObserver(JT);
          const i = new UT(t, t.config.get('typing.undoStep') || 20);
          t.commands.add('insertText', i);
          t.commands.add('input', i);
          this.listenTo(n.document, 'insertText', (o, i) => {
            if (!n.document.isComposing) {
              i.preventDefault();
            }
            const { text: r, selection: a, resultRange: c } = i;
            const l = Array.from(a.getRanges()).map(e =>
              t.editing.mapper.toModelRange(e),
            );
            let d = r;
            if (s.isAndroid) {
              const t = Array.from(l[0].getItems()).reduce(
                (t, e) => t + (e.is('$textProxy') ? e.data : ''),
                '',
              );
              if (t) {
                if (t.length <= d.length) {
                  if (d.startsWith(t)) {
                    d = d.substring(t.length);
                    l[0].start = l[0].start.getShiftedBy(t.length);
                  }
                } else {
                  if (t.startsWith(d)) {
                    l[0].start = l[0].start.getShiftedBy(d.length);
                    d = '';
                  }
                }
              }
            }
            const h = { text: d, selection: e.createSelection(l) };
            if (c) {
              h.resultRange = t.editing.mapper.toModelRange(c);
            }
            t.execute('insertText', h);
            n.scrollToTheSelection();
          });
          if (s.isAndroid) {
            this.listenTo(n.document, 'keydown', (t, r) => {
              if (
                o.isCollapsed ||
                r.keyCode != 229 ||
                !n.document.isComposing
              ) {
                return;
              }
              QT(e, i);
            });
          } else {
            this.listenTo(n.document, 'compositionstart', () => {
              if (o.isCollapsed) {
                return;
              }
              QT(e, i);
            });
          }
        }
      }
      function QT(t, e) {
        if (!e.isEnabled) {
          return;
        }
        const n = e.buffer;
        n.lock();
        t.enqueueChange(n.batch, () => {
          t.deleteContent(t.document.selection);
        });
        n.unlock();
      }
      class XT extends Bh {
        constructor(t, e) {
          super(t);
          this.direction = e;
          this._buffer = new KT(t.model, t.config.get('typing.undoStep'));
          this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.enqueueChange(this._buffer.batch, o => {
            this._buffer.lock();
            const i = o.createSelection(t.selection || n.selection);
            if (!e.canEditAt(i)) {
              return;
            }
            const r = t.sequence || 1;
            const s = i.isCollapsed;
            if (i.isCollapsed) {
              e.modifySelection(i, {
                direction: this.direction,
                unit: t.unit,
                treatEmojiAsSingleUnit: true,
              });
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(r)) {
              this._replaceEntireContentWithParagraph(o);
              return;
            }
            if (this._shouldReplaceFirstBlockWithParagraph(i, r)) {
              this.editor.execute('paragraph', { selection: i });
              return;
            }
            if (i.isCollapsed) {
              return;
            }
            let a = 0;
            i.getFirstRange()
              .getMinimalFlatRanges()
              .forEach(t => {
                a += At(
                  t.getWalker({
                    singleCharacters: true,
                    ignoreElementEnd: true,
                    shallow: true,
                  }),
                );
              });
            e.deleteContent(i, {
              doNotResetEntireContent: s,
              direction: this.direction,
            });
            this._buffer.input(a);
            o.setSelection(i);
            this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false;
          }
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = o.isCollapsed && o.containsEntireContent(i);
          if (!r) {
            return false;
          }
          if (!e.schema.checkChild(i, 'paragraph')) {
            return false;
          }
          const s = i.getChild(0);
          if (s && s.is('element', 'paragraph')) {
            return false;
          }
          return true;
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = t.createElement('paragraph');
          t.remove(t.createRangeIn(i));
          t.insert(r, i);
          t.setSelection(r, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model;
          if (e > 1 || this.direction != 'backward') {
            return false;
          }
          if (!t.isCollapsed) {
            return false;
          }
          const o = t.getFirstPosition();
          const i = n.schema.getLimitElement(o);
          const r = i.getChild(0);
          if (o.parent != r) {
            return false;
          }
          if (!t.containsEntireContent(r)) {
            return false;
          }
          if (!n.schema.checkChild(i, 'paragraph')) {
            return false;
          }
          if (r.name == 'paragraph') {
            return false;
          }
          return true;
        }
      }
      const tS = 'character';
      const eS = 'word';
      const nS = 'codePoint';
      const oS = 'selection';
      const iS = 'backward';
      const rS = 'forward';
      const sS = {
        deleteContent: { unit: oS, direction: iS },
        deleteContentBackward: { unit: nS, direction: iS },
        deleteWordBackward: { unit: eS, direction: iS },
        deleteHardLineBackward: { unit: oS, direction: iS },
        deleteSoftLineBackward: { unit: oS, direction: iS },
        deleteContentForward: { unit: tS, direction: rS },
        deleteWordForward: { unit: eS, direction: rS },
        deleteHardLineForward: { unit: oS, direction: rS },
        deleteSoftLineForward: { unit: oS, direction: rS },
      };
      class aS extends Vg {
        constructor(t) {
          super(t);
          const e = t.document;
          let n = 0;
          e.on('keydown', () => {
            n++;
          });
          e.on('keyup', () => {
            n = 0;
          });
          e.on('beforeinput', (o, i) => {
            if (!this.isEnabled) {
              return;
            }
            const { targetRanges: r, domEvent: a, inputType: c } = i;
            const l = sS[c];
            if (!l) {
              return;
            }
            const d = { direction: l.direction, unit: l.unit, sequence: n };
            if (d.unit == oS) {
              d.selectionToRemove = t.createSelection(r[0]);
            }
            if (c === 'deleteContentBackward') {
              if (s.isAndroid) {
                d.sequence = 1;
              }
              if (lS(r)) {
                d.unit = oS;
                d.selectionToRemove = t.createSelection(r);
              }
            }
            const h = new wp(e, 'delete', r[0]);
            e.fire(h, new Ng(t, a, d));
            if (h.stop.called) {
              o.stop();
            }
          });
          if (s.isBlink) {
            cS(this);
          }
        }
        observe() {}
        stopObserving() {}
      }
      function cS(t) {
        const e = t.view;
        const n = e.document;
        let o = null;
        let i = false;
        n.on('keydown', (t, { keyCode: e }) => {
          o = e;
          i = false;
        });
        n.on('keyup', (a, { keyCode: c, domEvent: l }) => {
          const d = n.selection;
          const h = t.isEnabled && c == o && r(c) && !d.isCollapsed && !i;
          o = null;
          if (h) {
            const t = d.getFirstRange();
            const o = new wp(n, 'delete', t);
            const i = { unit: oS, direction: s(c), selectionToRemove: d };
            n.fire(o, new Ng(e, l, i));
          }
        });
        n.on(
          'beforeinput',
          (t, { inputType: e }) => {
            const n = sS[e];
            const a = r(o) && n && n.direction == s(o);
            if (a) {
              i = true;
            }
          },
          { priority: 'high' },
        );
        n.on(
          'beforeinput',
          (t, { inputType: e, data: n }) => {
            const i = o == qc.delete && e == 'insertText' && n == '';
            if (i) {
              t.stop();
            }
          },
          { priority: 'high' },
        );
        function r(t) {
          return t == qc.backspace || t == qc.delete;
        }
        function s(t) {
          return t == qc.backspace ? iS : rS;
        }
      }
      function lS(t) {
        if (t.length != 1 || t[0].isCollapsed) {
          return false;
        }
        const e = t[0].getWalker({
          direction: 'backward',
          singleCharacters: true,
          ignoreElementEnd: true,
        });
        let n = 0;
        for (const { nextPosition: t } of e) {
          if (!t.parent.is('$text')) {
            n++;
          } else {
            const e = t.parent.data;
            const o = t.offset;
            if (Cl(e, o) || yl(e, o) || El(e, o)) {
              continue;
            }
            n++;
          }
          if (n > 1) {
            return true;
          }
        }
        return false;
      }
      class dS extends Sh {
        static get pluginName() {
          return 'Delete';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = t.model.document;
          e.addObserver(aS);
          this._undoOnBackspace = false;
          const i = new XT(t, 'forward');
          t.commands.add('deleteForward', i);
          t.commands.add('forwardDelete', i);
          t.commands.add('delete', new XT(t, 'backward'));
          this.listenTo(
            n,
            'delete',
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault();
              }
              const {
                direction: r,
                sequence: s,
                selectionToRemove: a,
                unit: c,
              } = i;
              const l = r === 'forward' ? 'deleteForward' : 'delete';
              const d = { sequence: s };
              if (c == 'selection') {
                const e = Array.from(a.getRanges()).map(e =>
                  t.editing.mapper.toModelRange(e),
                );
                d.selection = t.model.createSelection(e);
              } else {
                d.unit = c;
              }
              t.execute(l, d);
              e.scrollToTheSelection();
            },
            { priority: 'low' },
          );
          if (this.editor.plugins.has('UndoEditing')) {
            this.listenTo(
              n,
              'delete',
              (e, n) => {
                if (
                  this._undoOnBackspace &&
                  n.direction == 'backward' &&
                  n.sequence == 1 &&
                  n.unit == 'codePoint'
                ) {
                  this._undoOnBackspace = false;
                  t.execute('undo');
                  n.preventDefault();
                  e.stop();
                }
              },
              { context: '$capture' },
            );
            this.listenTo(o, 'change', () => {
              this._undoOnBackspace = false;
            });
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has('UndoEditing')) {
            this._undoOnBackspace = true;
          }
        }
      }
      class hS extends Sh {
        static get requires() {
          return [YT, dS];
        }
        static get pluginName() {
          return 'Typing';
        }
      }
      function uS(t, e) {
        let n = t.start;
        const o = Array.from(t.getWalker({ ignoreElementEnd: false })).reduce(
          (t, { item: o }) => {
            if (!(o.is('$text') || o.is('$textProxy'))) {
              n = e.createPositionAfter(o);
              return '';
            }
            return t + o.data;
          },
          '',
        );
        return { text: o, range: e.createRange(n, t.end) };
      }
      class fS extends dt() {
        constructor(t, e) {
          super();
          this.model = t;
          this.testCallback = e;
          this._hasMatch = false;
          this.set('isEnabled', true);
          this.on('change:isEnabled', () => {
            if (this.isEnabled) {
              this._startListening();
            } else {
              this.stopListening(t.document.selection);
              this.stopListening(t.document);
            }
          });
          this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const t = this.model;
          const e = t.document;
          this.listenTo(
            e.selection,
            'change:range',
            (t, { directChange: n }) => {
              if (!n) {
                return;
              }
              if (!e.selection.isCollapsed) {
                if (this.hasMatch) {
                  this.fire('unmatched');
                  this._hasMatch = false;
                }
                return;
              }
              this._evaluateTextBeforeSelection('selection');
            },
          );
          this.listenTo(e, 'change:data', (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return;
            }
            this._evaluateTextBeforeSelection('data', { batch: e });
          });
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model;
          const o = n.document;
          const i = o.selection;
          const r = n.createRange(
            n.createPositionAt(i.focus.parent, 0),
            i.focus,
          );
          const { text: s, range: a } = uS(r, n);
          const c = this.testCallback(s);
          if (!c && this.hasMatch) {
            this.fire('unmatched');
          }
          this._hasMatch = !!c;
          if (c) {
            const n = Object.assign(e, { text: s, range: a });
            if (typeof c == 'object') {
              Object.assign(n, c);
            }
            this.fire(`matched:${t}`, n);
          }
        }
      }
      class pS extends (null && Plugin) {
        static get pluginName() {
          return 'TwoStepCaretMovement';
        }
        constructor(t) {
          super(t);
          this.attributes = new Set();
          this._overrideUid = null;
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = t.locale;
          const i = e.document.selection;
          this.listenTo(
            n.document,
            'arrowKey',
            (t, e) => {
              if (!i.isCollapsed) {
                return;
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return;
              }
              const n = e.keyCode == keyCodes.arrowright;
              const r = e.keyCode == keyCodes.arrowleft;
              if (!n && !r) {
                return;
              }
              const s = o.contentLanguageDirection;
              let a = false;
              if ((s === 'ltr' && n) || (s === 'rtl' && r)) {
                a = this._handleForwardMovement(e);
              } else {
                a = this._handleBackwardMovement(e);
              }
              if (a === true) {
                t.stop();
              }
            },
            { context: '$text', priority: 'highest' },
          );
          this._isNextGravityRestorationSkipped = false;
          this.listenTo(i, 'change:range', (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false;
              return;
            }
            if (!this._isGravityOverridden) {
              return;
            }
            if (!e.directChange && wS(i.getFirstPosition(), this.attributes)) {
              return;
            }
            this._restoreGravity();
          });
        }
        registerAttribute(t) {
          this.attributes.add(t);
        }
        _handleForwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            return false;
          }
          if (i.isAtStart && gS(o, e)) {
            return false;
          }
          if (wS(i, e)) {
            kS(t);
            this._overrideGravity();
            return true;
          }
          return false;
        }
        _handleBackwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            kS(t);
            this._restoreGravity();
            mS(n, e, i);
            return true;
          } else {
            if (i.isAtStart) {
              if (gS(o, e)) {
                kS(t);
                mS(n, e, i);
                return true;
              }
              return false;
            }
            if (bS(i, e)) {
              if (i.isAtEnd && !gS(o, e) && wS(i, e)) {
                kS(t);
                mS(n, e, i);
                return true;
              }
              this._isNextGravityRestorationSkipped = true;
              this._overrideGravity();
              return false;
            }
          }
          return false;
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change(t =>
            t.overrideSelectionGravity(),
          );
        }
        _restoreGravity() {
          this.editor.model.change(t => {
            t.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
          });
        }
      }
      function gS(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true;
          }
        }
        return false;
      }
      function mS(t, e, n) {
        const o = n.nodeBefore;
        t.change(n => {
          if (o) {
            const e = [];
            const i = t.schema.isObject(o) && t.schema.isInline(o);
            for (const [n, r] of o.getAttributes()) {
              if (
                t.schema.checkAttribute('$text', n) &&
                (!i ||
                  t.schema.getAttributeProperties(n).copyFromObject !== false)
              ) {
                e.push([n, r]);
              }
            }
            n.setSelectionAttribute(e);
          } else {
            n.removeSelectionAttribute(e);
          }
        });
      }
      function kS(t) {
        t.preventDefault();
      }
      function bS(t, e) {
        const n = t.getShiftedBy(-1);
        return wS(n, e);
      }
      function wS(t, e) {
        const { nodeBefore: n, nodeAfter: o } = t;
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined;
          const i = o ? o.getAttribute(t) : undefined;
          if (i !== e) {
            return true;
          }
        }
        return false;
      }
      const _S = {
        copyright: { from: '(c)', to: '' },
        registeredTrademark: { from: '(r)', to: '' },
        trademark: { from: '(tm)', to: '' },
        oneHalf: {
          from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
          to: [null, '', null],
        },
        oneThird: {
          from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
          to: [null, '', null],
        },
        twoThirds: {
          from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
          to: [null, '', null],
        },
        oneForth: {
          from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
          to: [null, '', null],
        },
        threeQuarters: {
          from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
          to: [null, '', null],
        },
        lessThanOrEqual: { from: '<=', to: '' },
        greaterThanOrEqual: { from: '>=', to: '' },
        notEqual: { from: '!=', to: '' },
        arrowLeft: { from: '<-', to: '' },
        arrowRight: { from: '->', to: '' },
        horizontalEllipsis: { from: '...', to: '' },
        enDash: { from: /(^| )(--)( )$/, to: [null, '', null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, '', null] },
        quotesPrimary: { from: DS('"'), to: [null, '', null, ''] },
        quotesSecondary: { from: DS("'"), to: [null, '', null, ''] },
        quotesPrimaryEnGb: { from: DS("'"), to: [null, '', null, ''] },
        quotesSecondaryEnGb: { from: DS('"'), to: [null, '', null, ''] },
        quotesPrimaryPl: { from: DS('"'), to: [null, '', null, ''] },
        quotesSecondaryPl: { from: DS("'"), to: [null, '', null, ''] },
      };
      const vS = {
        symbols: ['copyright', 'registeredTrademark', 'trademark'],
        mathematical: [
          'oneHalf',
          'oneThird',
          'twoThirds',
          'oneForth',
          'threeQuarters',
          'lessThanOrEqual',
          'greaterThanOrEqual',
          'notEqual',
          'arrowLeft',
          'arrowRight',
        ],
        typography: ['horizontalEllipsis', 'enDash', 'emDash'],
        quotes: ['quotesPrimary', 'quotesSecondary'],
      };
      const AS = null && ['symbols', 'mathematical', 'typography', 'quotes'];
      class CS extends (null && Plugin) {
        static get requires() {
          return ['Delete', 'Input'];
        }
        static get pluginName() {
          return 'TextTransformation';
        }
        constructor(t) {
          super(t);
          t.config.define('typing', { transformations: { include: AS } });
        }
        init() {
          const t = this.editor.model;
          const e = t.document.selection;
          e.on('change:range', () => {
            this.isEnabled = !e.anchor.parent.is('element', 'codeBlock');
          });
          this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const t = this.editor;
          const e = t.model;
          const n = t.plugins.get('Delete');
          const o = TS(t.config.get('typing.transformations'));
          const i = t => {
            for (const e of o) {
              const n = e.from;
              const o = n.test(t);
              if (o) {
                return { normalizedTransformation: e };
              }
            }
          };
          const r = new TextWatcher(t.model, i);
          r.on('matched:data', (t, o) => {
            if (!o.batch.isTyping) {
              return;
            }
            const { from: i, to: r } = o.normalizedTransformation;
            const s = i.exec(o.text);
            const a = r(s.slice(1));
            const c = o.range;
            let l = s.index;
            e.enqueueChange(t => {
              for (let n = 1; n < s.length; n++) {
                const o = s[n];
                const i = a[n - 1];
                if (i == null) {
                  l += o.length;
                  continue;
                }
                const r = c.start.getShiftedBy(l);
                const d = e.createRange(r, r.getShiftedBy(o.length));
                const h = ES(r);
                e.insertContent(t.createText(i, h), d);
                l += i.length;
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace();
              });
            });
          });
          r.bind('isEnabled').to(this);
        }
      }
      function yS(t) {
        if (typeof t == 'string') {
          return new RegExp(`(${escapeRegExp(t)})$`);
        }
        return t;
      }
      function xS(t) {
        if (typeof t == 'string') {
          return () => [t];
        } else if (t instanceof Array) {
          return () => t;
        }
        return t;
      }
      function ES(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter;
        return e.getAttributes();
      }
      function DS(t) {
        return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
      }
      function TS(t) {
        const e = t.extra || [];
        const n = t.remove || [];
        const o = t => !n.includes(t);
        const i = t.include.concat(e).filter(o);
        return SS(i)
          .filter(o)
          .map(t => (typeof t == 'string' && _S[t] ? _S[t] : t))
          .filter(t => typeof t === 'object')
          .map(t => ({ from: yS(t.from), to: xS(t.to) }));
      }
      function SS(t) {
        const e = new Set();
        for (const n of t) {
          if (typeof n == 'string' && vS[n]) {
            for (const t of vS[n]) {
              e.add(t);
            }
          } else {
            e.add(n);
          }
        }
        return Array.from(e);
      }
      function* PS(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n;
          }
        }
      }
      class BS extends Bh {
        execute() {
          this.editor.model.change(t => {
            this.enterBlock(t);
            this.fire('afterExecute', { writer: t });
          });
        }
        enterBlock(t) {
          const e = this.editor.model;
          const n = e.document.selection;
          const o = e.schema;
          const i = n.isCollapsed;
          const r = n.getFirstRange();
          const s = r.start.parent;
          const a = r.end.parent;
          if (o.isLimit(s) || o.isLimit(a)) {
            if (!i && s == a) {
              e.deleteContent(n);
            }
            return false;
          }
          if (i) {
            const e = PS(t.model.schema, n.getAttributes());
            RS(t, r.start);
            t.setSelectionAttribute(e);
            return true;
          } else {
            const o = !(r.start.isAtStart && r.end.isAtEnd);
            const i = s == a;
            e.deleteContent(n, { leaveUnmerged: o });
            if (o) {
              if (i) {
                RS(t, n.focus);
                return true;
              } else {
                t.setSelection(a, 0);
              }
            }
          }
          return false;
        }
      }
      function RS(t, e) {
        t.split(e);
        t.setSelection(e.parent.nextSibling, 0);
      }
      const OS = {
        insertParagraph: { isSoft: false },
        insertLineBreak: { isSoft: true },
      };
      class IS extends Vg {
        constructor(t) {
          super(t);
          const e = this.document;
          let n = false;
          e.on('keydown', (t, e) => {
            n = e.shiftKey;
          });
          e.on('beforeinput', (o, i) => {
            if (!this.isEnabled) {
              return;
            }
            let r = i.inputType;
            if (s.isSafari && n && r == 'insertParagraph') {
              r = 'insertLineBreak';
            }
            const a = i.domEvent;
            const c = OS[r];
            if (!c) {
              return;
            }
            const l = new wp(e, 'enter', i.targetRanges[0]);
            e.fire(l, new Ng(t, a, { isSoft: c.isSoft }));
            if (l.stop.called) {
              o.stop();
            }
          });
        }
        observe() {}
        stopObserving() {}
      }
      class MS extends Sh {
        static get pluginName() {
          return 'Enter';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(IS);
          t.commands.add('enter', new BS(t));
          this.listenTo(
            n,
            'enter',
            (o, i) => {
              if (!n.isComposing) {
                i.preventDefault();
              }
              if (i.isSoft) {
                return;
              }
              t.execute('enter');
              e.scrollToTheSelection();
            },
            { priority: 'low' },
          );
        }
      }
      class VS extends Bh {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change(n => {
            FS(t, n, e.selection);
            this.fire('afterExecute', { writer: n });
          });
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = zS(t.schema, e.selection);
        }
      }
      function zS(t, e) {
        if (e.rangeCount > 1) {
          return false;
        }
        const n = e.anchor;
        if (!n || !t.checkChild(n, 'softBreak')) {
          return false;
        }
        const o = e.getFirstRange();
        const i = o.start.parent;
        const r = o.end.parent;
        if ((LS(i, t) || LS(r, t)) && i !== r) {
          return false;
        }
        return true;
      }
      function FS(t, e, n) {
        const o = n.isCollapsed;
        const i = n.getFirstRange();
        const r = i.start.parent;
        const s = i.end.parent;
        const a = r == s;
        if (o) {
          const o = PS(t.schema, n.getAttributes());
          NS(t, e, i.end);
          e.removeSelectionAttribute(n.getAttributeKeys());
          e.setSelectionAttribute(o);
        } else {
          const o = !(i.start.isAtStart && i.end.isAtEnd);
          t.deleteContent(n, { leaveUnmerged: o });
          if (a) {
            NS(t, e, n.focus);
          } else {
            if (o) {
              e.setSelection(s, 0);
            }
          }
        }
      }
      function NS(t, e, n) {
        const o = e.createElement('softBreak');
        t.insertContent(o, n);
        e.setSelection(o, 'after');
      }
      function LS(t, e) {
        if (t.is('rootElement')) {
          return false;
        }
        return e.isLimit(t) || LS(t.parent, e);
      }
      class HS extends Sh {
        static get pluginName() {
          return 'ShiftEnter';
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          const o = t.editing.view;
          const i = o.document;
          e.register('softBreak', { allowWhere: '$text', isInline: true });
          n.for('upcast').elementToElement({ model: 'softBreak', view: 'br' });
          n.for('downcast').elementToElement({
            model: 'softBreak',
            view: (t, { writer: e }) => e.createEmptyElement('br'),
          });
          o.addObserver(IS);
          t.commands.add('shiftEnter', new VS(t));
          this.listenTo(
            i,
            'enter',
            (e, n) => {
              if (!i.isComposing) {
                n.preventDefault();
              }
              if (!n.isSoft) {
                return;
              }
              t.execute('shiftEnter');
              o.scrollToTheSelection();
            },
            { priority: 'low' },
          );
        }
      }
      class jS extends $() {
        constructor() {
          super(...arguments);
          this._stack = [];
        }
        add(t, e) {
          const n = this._stack;
          const o = n[0];
          this._insertDescriptor(t);
          const i = n[0];
          if (o !== i && !qS(o, i)) {
            this.fire('change:top', {
              oldDescriptor: o,
              newDescriptor: i,
              writer: e,
            });
          }
        }
        remove(t, e) {
          const n = this._stack;
          const o = n[0];
          this._removeDescriptor(t);
          const i = n[0];
          if (o !== i && !qS(o, i)) {
            this.fire('change:top', {
              oldDescriptor: o,
              newDescriptor: i,
              writer: e,
            });
          }
        }
        _insertDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex(e => e.id === t.id);
          if (qS(t, e[n])) {
            return;
          }
          if (n > -1) {
            e.splice(n, 1);
          }
          let o = 0;
          while (e[o] && $S(e[o], t)) {
            o++;
          }
          e.splice(o, 0, t);
        }
        _removeDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex(e => e.id === t);
          if (n > -1) {
            e.splice(n, 1);
          }
        }
      }
      function qS(t, e) {
        return (
          t && e && t.priority == e.priority && WS(t.classes) == WS(e.classes)
        );
      }
      function $S(t, e) {
        if (t.priority > e.priority) {
          return true;
        } else if (t.priority < e.priority) {
          return false;
        }
        return WS(t.classes) > WS(e.classes);
      }
      function WS(t) {
        return Array.isArray(t) ? t.sort().join(',') : t;
      }
      const GS = 'ck-widget';
      const KS = 'ck-widget_selected';
      function US(t) {
        if (!t.is('element')) {
          return false;
        }
        return !!t.getCustomProperty('widget');
      }
      function ZS(t, e, n = {}) {
        if (!t.is('containerElement')) {
          throw new CKEditorError('widget-to-widget-wrong-element-type', null, {
            element: t,
          });
        }
        e.setAttribute('contenteditable', 'false', t);
        e.addClass(GS, t);
        e.setCustomProperty('widget', true, t);
        t.getFillerOffset = iP;
        e.setCustomProperty('widgetLabel', [], t);
        if (n.label) {
          XS(t, n.label);
        }
        if (n.hasSelectionHandle) {
          rP(t, e);
        }
        QS(t, e);
        return t;
      }
      function JS(t, e, n) {
        if (e.classes) {
          n.addClass(toArray(e.classes), t);
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.setAttribute(o, e.attributes[o], t);
          }
        }
      }
      function YS(t, e, n) {
        if (e.classes) {
          n.removeClass(toArray(e.classes), t);
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.removeAttribute(o, t);
          }
        }
      }
      function QS(t, e, n = JS, o = YS) {
        const i = new HighlightStack();
        i.on('change:top', (e, i) => {
          if (i.oldDescriptor) {
            o(t, i.oldDescriptor, i.writer);
          }
          if (i.newDescriptor) {
            n(t, i.newDescriptor, i.writer);
          }
        });
        const r = (t, e, n) => i.add(e, n);
        const s = (t, e, n) => i.remove(e, n);
        e.setCustomProperty('addHighlight', r, t);
        e.setCustomProperty('removeHighlight', s, t);
      }
      function XS(t, e) {
        const n = t.getCustomProperty('widgetLabel');
        n.push(e);
      }
      function tP(t) {
        const e = t.getCustomProperty('widgetLabel');
        return e.reduce((t, e) => {
          if (typeof e === 'function') {
            return t ? t + '. ' + e() : e();
          } else {
            return t ? t + '. ' + e : e;
          }
        }, '');
      }
      function eP(t, e, n = {}) {
        e.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], t);
        e.setAttribute('role', 'textbox', t);
        if (n.label) {
          e.setAttribute('aria-label', n.label, t);
        }
        e.setAttribute('contenteditable', t.isReadOnly ? 'false' : 'true', t);
        t.on('change:isReadOnly', (n, o, i) => {
          e.setAttribute('contenteditable', i ? 'false' : 'true', t);
        });
        t.on('change:isFocused', (n, o, i) => {
          if (i) {
            e.addClass('ck-editor__nested-editable_focused', t);
          } else {
            e.removeClass('ck-editor__nested-editable_focused', t);
          }
        });
        QS(t, e);
        return t;
      }
      function nP(t, e) {
        const n = t.getSelectedElement();
        if (n) {
          const o = getTypeAroundFakeCaretPosition(t);
          if (o) {
            return e.createRange(e.createPositionAt(n, o));
          }
        }
        return engineFindOptimalInsertionRange(t, e);
      }
      function oP(t, e) {
        return (n, o) => {
          const { mapper: i, viewPosition: r } = o;
          const s = i.findMappedViewAncestor(r);
          if (!e(s)) {
            return;
          }
          const a = i.toModelElement(s);
          o.modelPosition = t.createPositionAt(
            a,
            r.isAtStart ? 'before' : 'after',
          );
        };
      }
      function iP() {
        return null;
      }
      function rP(t, e) {
        const n = e.createUIElement(
          'div',
          { class: 'ck ck-widget__selection-handle' },
          function (t) {
            const e = this.toDomElement(t);
            const n = new IconView();
            n.set('content', dragHandleIcon);
            n.render();
            e.appendChild(n.element);
            return e;
          },
        );
        e.insert(e.createPositionAt(t, 0), n);
        e.addClass(['ck-widget_with-selection-handle'], t);
      }
      const sP = 'widget-type-around';
      function aP(t, e, n) {
        return !!t && US(t) && !n.isInline(e);
      }
      function cP(t) {
        return t.closest('.ck-widget__type-around__button');
      }
      function lP(t) {
        return t.classList.contains('ck-widget__type-around__button_before')
          ? 'before'
          : 'after';
      }
      function dP(t, e) {
        const n = t.closest('.ck-widget');
        return e.mapDomToView(n);
      }
      function hP(t) {
        return t.getAttribute(sP);
      }
      const uP =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
      var fP = n(347);
      var pP = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      pP.insert = 'head';
      pP.singleton = true;
      var gP = Bl()(fP.Z, pP);
      const mP = fP.Z.locals || {};
      const kP = ['before', 'after'];
      const bP = new DOMParser().parseFromString(
        uP,
        'image/svg+xml',
      ).firstChild;
      const wP = 'ck-widget__type-around_disabled';
      class _P extends Sh {
        constructor() {
          super(...arguments);
          this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return 'WidgetTypeAround';
        }
        static get requires() {
          return [MS, dS];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this.on('change:isEnabled', (n, o, i) => {
            e.change(t => {
              for (const n of e.document.roots) {
                if (i) {
                  t.removeClass(wP, n);
                } else {
                  t.addClass(wP, n);
                }
              }
            });
            if (!i) {
              t.model.change(t => {
                t.removeSelectionAttribute(sP);
              });
            }
          });
          this._enableTypeAroundUIInjection();
          this._enableInsertingParagraphsOnButtonClick();
          this._enableInsertingParagraphsOnEnterKeypress();
          this._enableInsertingParagraphsOnTypingKeystroke();
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
          this._enableDeleteIntegration();
          this._enableInsertContentIntegration();
          this._enableInsertObjectIntegration();
          this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy();
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          const i = n.model.schema.getAttributesWithProperty(
            t,
            'copyOnReplace',
            true,
          );
          n.execute('insertParagraph', {
            position: n.model.createPositionAt(t, e),
            attributes: i,
          });
          o.focus();
          o.scrollToTheSelection();
        }
        _listenToIfEnabled(t, e, n, o) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t);
              }
            },
            o,
          );
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = hP(n);
          if (!o) {
            return false;
          }
          const i = n.getSelectedElement();
          this._insertParagraph(i, o);
          return true;
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.locale.t;
          const o = {
            before: n('Insert paragraph before block'),
            after: n('Insert paragraph after block'),
          };
          t.editing.downcastDispatcher.on(
            'insert',
            (t, i, r) => {
              const s = r.mapper.toViewElement(i.item);
              if (!s) {
                return;
              }
              if (aP(s, i.item, e)) {
                vP(r.writer, o, s);
                const t = s.getCustomProperty('widgetLabel');
                t.push(() =>
                  this.isEnabled
                    ? n(
                        'Press Enter to type after or press Shift + Enter to type before the widget',
                      )
                    : '',
                );
              }
            },
            { priority: 'low' },
          );
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = e.schema;
          const i = t.editing.view;
          this._listenToIfEnabled(
            i.document,
            'arrowKey',
            (t, e) => {
              this._handleArrowKeyPress(t, e);
            },
            { context: [US, '$text'], priority: 'high' },
          );
          this._listenToIfEnabled(n, 'change:range', (e, n) => {
            if (!n.directChange) {
              return;
            }
            t.model.change(t => {
              t.removeSelectionAttribute(sP);
            });
          });
          this._listenToIfEnabled(e.document, 'change:data', () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (aP(n, e, o)) {
                return;
              }
            }
            t.model.change(t => {
              t.removeSelectionAttribute(sP);
            });
          });
          this._listenToIfEnabled(
            t.editing.downcastDispatcher,
            'selection',
            (t, e, n) => {
              const i = n.writer;
              if (this._currentFakeCaretModelElement) {
                const t = n.mapper.toViewElement(
                  this._currentFakeCaretModelElement,
                );
                if (t) {
                  i.removeClass(kP.map(r), t);
                  this._currentFakeCaretModelElement = null;
                }
              }
              const s = e.selection.getSelectedElement();
              if (!s) {
                return;
              }
              const a = n.mapper.toViewElement(s);
              if (!aP(a, s, o)) {
                return;
              }
              const c = hP(e.selection);
              if (!c) {
                return;
              }
              i.addClass(r(c), a);
              this._currentFakeCaretModelElement = s;
            },
          );
          this._listenToIfEnabled(
            t.ui.focusTracker,
            'change:isFocused',
            (e, n, o) => {
              if (!o) {
                t.model.change(t => {
                  t.removeSelectionAttribute(sP);
                });
              }
            },
          );
          function r(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`;
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor;
          const o = n.model;
          const i = o.document.selection;
          const r = o.schema;
          const s = n.editing.view;
          const a = e.keyCode;
          const c = Yc(a, n.locale.contentLanguageDirection);
          const l = s.document.selection.getSelectedElement();
          const d = n.editing.mapper.toModelElement(l);
          let h;
          if (aP(l, d, r)) {
            h = this._handleArrowKeyPressOnSelectedWidget(c);
          } else if (i.isCollapsed) {
            h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c);
          } else if (!e.shiftKey) {
            h = this._handleArrowKeyPressWhenNonCollapsedSelection(c);
          }
          if (h) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.document.selection;
          const i = hP(o);
          return n.change(e => {
            if (i) {
              const n = i === (t ? 'after' : 'before');
              if (!n) {
                e.removeSelectionAttribute(sP);
                return true;
              }
            } else {
              e.setSelectionAttribute(sP, t ? 'after' : 'before');
              return true;
            }
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.schema;
          const i = e.plugins.get('Widget');
          const r = i._getObjectElementNextToSelection(t);
          const s = e.editing.mapper.toViewElement(r);
          if (aP(s, r, o)) {
            n.change(e => {
              i._setSelectionOverElement(r);
              e.setSelectionAttribute(sP, t ? 'before' : 'after');
            });
            return true;
          }
          return false;
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.schema;
          const i = e.editing.mapper;
          const r = n.document.selection;
          const s = t
            ? r.getLastPosition().nodeBefore
            : r.getFirstPosition().nodeAfter;
          const a = i.toViewElement(s);
          if (aP(a, s, o)) {
            n.change(e => {
              e.setSelection(s, 'on');
              e.setSelectionAttribute(sP, t ? 'after' : 'before');
            });
            return true;
          }
          return false;
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, 'mousedown', (n, o) => {
            const i = cP(o.domTarget);
            if (!i) {
              return;
            }
            const r = lP(i);
            const s = dP(i, e.domConverter);
            const a = t.editing.mapper.toModelElement(s);
            this._insertParagraph(a, r);
            o.preventDefault();
            n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor;
          const e = t.model.document.selection;
          const n = t.editing.view;
          this._listenToIfEnabled(
            n.document,
            'enter',
            (n, o) => {
              if (n.eventPhase != 'atTarget') {
                return;
              }
              const i = e.getSelectedElement();
              const r = t.editing.mapper.toViewElement(i);
              const s = t.model.schema;
              let a;
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                a = true;
              } else if (aP(r, i, s)) {
                this._insertParagraph(i, o.isSoft ? 'before' : 'after');
                a = true;
              }
              if (a) {
                o.preventDefault();
                n.stop();
              }
            },
            { context: US },
          );
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor;
          const e = t.editing.view.document;
          this._listenToIfEnabled(
            e,
            'insertText',
            (t, n) => {
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                n.selection = e.selection;
              }
            },
            { priority: 'high' },
          );
          if (s.isAndroid) {
            this._listenToIfEnabled(e, 'keydown', (t, e) => {
              if (e.keyCode == 229) {
                this._insertParagraphAccordingToFakeCaretPosition();
              }
            });
          } else {
            this._listenToIfEnabled(
              e,
              'compositionstart',
              () => {
                this._insertParagraphAccordingToFakeCaretPosition();
              },
              { priority: 'high' },
            );
          }
        }
        _enableDeleteIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          const o = n.schema;
          this._listenToIfEnabled(
            e.document,
            'delete',
            (e, i) => {
              if (e.eventPhase != 'atTarget') {
                return;
              }
              const r = hP(n.document.selection);
              if (!r) {
                return;
              }
              const s = i.direction;
              const a = n.document.selection.getSelectedElement();
              const c = r === 'before';
              const l = s == 'forward';
              const d = c === l;
              if (d) {
                t.execute('delete', { selection: n.createSelection(a, 'on') });
              } else {
                const e = o.getNearestSelectionRange(
                  n.createPositionAt(a, r),
                  s,
                );
                if (e) {
                  if (!e.isCollapsed) {
                    n.change(n => {
                      n.setSelection(e);
                      t.execute(l ? 'deleteForward' : 'delete');
                    });
                  } else {
                    const i = n.createSelection(e.start);
                    n.modifySelection(i, { direction: s });
                    if (!i.focus.isEqual(e.start)) {
                      n.change(n => {
                        n.setSelection(e);
                        t.execute(l ? 'deleteForward' : 'delete');
                      });
                    } else {
                      const t = yP(o, e.start.parent);
                      n.deleteContent(n.createSelection(t, 'on'), {
                        doNotAutoparagraph: true,
                      });
                    }
                  }
                }
              }
              i.preventDefault();
              e.stop();
            },
            { context: US },
          );
        }
        _enableInsertContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'insertContent',
            (t, [o, i]) => {
              if (i && !i.is('documentSelection')) {
                return;
              }
              const r = hP(n);
              if (!r) {
                return;
              }
              t.stop();
              return e.change(t => {
                const i = n.getSelectedElement();
                const s = e.createPositionAt(i, r);
                const a = t.createSelection(s);
                const c = e.insertContent(o, a);
                t.setSelection(a);
                return c;
              });
            },
            { priority: 'high' },
          );
        }
        _enableInsertObjectIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'insertObject',
            (t, e) => {
              const [, o, i = {}] = e;
              if (o && !o.is('documentSelection')) {
                return;
              }
              const r = hP(n);
              if (!r) {
                return;
              }
              i.findOptimalPosition = r;
              e[3] = i;
            },
            { priority: 'high' },
          );
        }
        _enableDeleteContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            'deleteContent',
            (t, [e]) => {
              if (e && !e.is('documentSelection')) {
                return;
              }
              const o = hP(n);
              if (o) {
                t.stop();
              }
            },
            { priority: 'high' },
          );
        }
      }
      function vP(t, e, n) {
        const o = t.createUIElement(
          'div',
          { class: 'ck ck-reset_all ck-widget__type-around' },
          function (t) {
            const n = this.toDomElement(t);
            AP(n, e);
            CP(n);
            return n;
          },
        );
        t.insert(t.createPositionAt(n, 'end'), o);
      }
      function AP(t, e) {
        for (const n of kP) {
          const o = new Fl({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-widget__type-around__button',
                `ck-widget__type-around__button_${n}`,
              ],
              title: e[n],
              'aria-hidden': 'true',
            },
            children: [t.ownerDocument.importNode(bP, true)],
          });
          t.appendChild(o.render());
        }
      }
      function CP(t) {
        const e = new Fl({
          tag: 'div',
          attributes: { class: ['ck', 'ck-widget__type-around__fake-caret'] },
        });
        t.appendChild(e.render());
      }
      function yP(t, e) {
        let n = e;
        for (const o of e.getAncestors({ parentFirst: true })) {
          if (o.childCount > 1 || t.isLimit(o)) {
            break;
          }
          n = o;
        }
        return n;
      }
      function xP(t) {
        const e = t.model;
        return (n, o) => {
          const i = o.keyCode == qc.arrowup;
          const r = o.keyCode == qc.arrowdown;
          const s = o.shiftKey;
          const a = e.document.selection;
          if (!i && !r) {
            return;
          }
          const c = r;
          if (s && PP(a, c)) {
            return;
          }
          const l = EP(t, a, c);
          if (!l) {
            return;
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return;
            } else if (s) {
              return;
            }
          }
          if (l.isCollapsed || SP(t, l, c)) {
            e.change(t => {
              const n = c ? l.end : l.start;
              if (s) {
                const o = e.createSelection(a.anchor);
                o.setFocus(n);
                t.setSelection(o);
              } else {
                t.setSelection(n);
              }
            });
            n.stop();
            o.preventDefault();
            o.stopPropagation();
          }
        };
      }
      function EP(t, e, n) {
        const o = t.model;
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition();
          const n = DP(o, t, 'forward');
          if (!n) {
            return null;
          }
          const i = o.createRange(t, n);
          const r = TP(o.schema, i, 'backward');
          if (r) {
            return o.createRange(t, r);
          }
          return null;
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition();
          const n = DP(o, t, 'backward');
          if (!n) {
            return null;
          }
          const i = o.createRange(n, t);
          const r = TP(o.schema, i, 'forward');
          if (r) {
            return o.createRange(r, t);
          }
          return null;
        }
      }
      function DP(t, e, n) {
        const o = t.schema;
        const i = t.createRangeIn(e.root);
        const r = n == 'forward' ? 'elementStart' : 'elementEnd';
        for (const { previousPosition: t, item: s, type: a } of i.getWalker({
          startPosition: e,
          direction: n,
        })) {
          if (o.isLimit(s) && !o.isInline(s)) {
            return t;
          }
          if (a == r && o.isBlock(s)) {
            return null;
          }
        }
        return null;
      }
      function TP(t, e, n) {
        const o = n == 'backward' ? e.end : e.start;
        if (t.checkChild(o, '$text')) {
          return o;
        }
        for (const { nextPosition: o } of e.getWalker({ direction: n })) {
          if (t.checkChild(o, '$text')) {
            return o;
          }
        }
        return null;
      }
      function SP(t, e, n) {
        const o = t.model;
        const i = t.view.domConverter;
        if (n) {
          const t = o.createSelection(e.start);
          o.modifySelection(t);
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = o.createRange(t.focus, e.end);
          }
        }
        const r = t.mapper.toViewRange(e);
        const s = i.viewRangeToDom(r);
        const a = cc.getDomRangeRects(s);
        let c;
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom);
            continue;
          }
          if (Math.round(t.top) >= c) {
            return false;
          }
          c = Math.max(c, Math.round(t.bottom));
        }
        return true;
      }
      function PP(t, e) {
        return !t.isCollapsed && t.isBackward == e;
      }
      var BP = n(153);
      var RP = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      RP.insert = 'head';
      RP.singleton = true;
      var OP = Bl()(BP.Z, RP);
      const IP = BP.Z.locals || {};
      class MP extends Sh {
        constructor() {
          super(...arguments);
          this._previouslySelected = new Set();
        }
        static get pluginName() {
          return 'Widget';
        }
        static get requires() {
          return [_P, dS];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.editor.editing.downcastDispatcher.on('selection', (e, n, o) => {
            const i = o.writer;
            const r = n.selection;
            if (r.isCollapsed) {
              return;
            }
            const s = r.getSelectedElement();
            if (!s) {
              return;
            }
            const a = t.editing.mapper.toViewElement(s);
            if (!US(a)) {
              return;
            }
            if (!o.consumable.consume(r, 'selection')) {
              return;
            }
            i.setSelection(i.createRangeOn(a), { fake: true, label: tP(a) });
          });
          this.editor.editing.downcastDispatcher.on(
            'selection',
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const o = n.writer;
              const i = o.document.selection;
              let r = null;
              for (const t of i.getRanges()) {
                for (const e of t) {
                  const t = e.item;
                  if (US(t) && !zP(t, r)) {
                    o.addClass(KS, t);
                    this._previouslySelected.add(t);
                    r = t;
                  }
                }
              }
            },
            { priority: 'low' },
          );
          e.addObserver(Xv);
          this.listenTo(n, 'mousedown', (...t) => this._onMousedown(...t));
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { context: [US, '$text'] },
          );
          this.listenTo(
            n,
            'arrowKey',
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { context: '$root' },
          );
          this.listenTo(n, 'arrowKey', xP(this.editor.editing), {
            context: '$text',
          });
          this.listenTo(
            n,
            'delete',
            (t, e) => {
              if (this._handleDelete(e.direction == 'forward')) {
                e.preventDefault();
                t.stop();
              }
            },
            { context: '$root' },
          );
        }
        _onMousedown(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          const i = o.document;
          let r = e.target;
          if (e.domEvent.detail >= 3) {
            if (this._selectBlockContent(r)) {
              e.preventDefault();
            }
            return;
          }
          if (VP(r)) {
            return;
          }
          if (!US(r)) {
            r = r.findAncestor(US);
            if (!r) {
              return;
            }
          }
          if (s.isAndroid) {
            e.preventDefault();
          }
          if (!i.isFocused) {
            o.focus();
          }
          const a = n.editing.mapper.toModelElement(r);
          this._setSelectionOverElement(a);
        }
        _selectBlockContent(t) {
          const e = this.editor;
          const n = e.model;
          const o = e.editing.mapper;
          const i = n.schema;
          const r = o.findMappedViewAncestor(
            this.editor.editing.view.createPositionAt(t, 0),
          );
          const s = FP(o.toModelElement(r), n.schema);
          if (!s) {
            return false;
          }
          n.change(t => {
            const e = !i.isLimit(s) ? NP(t.createPositionAfter(s), i) : null;
            const n = t.createPositionAt(s, 0);
            const o = e
              ? t.createPositionAt(e, 0)
              : t.createPositionAt(s, 'end');
            t.setSelection(t.createRange(n, o));
          });
          return true;
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          const o = this.editor.model;
          const i = o.schema;
          const r = o.document.selection;
          const s = r.getSelectedElement();
          const a = Zc(n, this.editor.locale.contentLanguageDirection);
          const c = a == 'down' || a == 'right';
          const l = a == 'up' || a == 'down';
          if (s && i.isObject(s)) {
            const n = c ? r.getLastPosition() : r.getFirstPosition();
            const s = i.getNearestSelectionRange(n, c ? 'forward' : 'backward');
            if (s) {
              o.change(t => {
                t.setSelection(s);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed && !e.shiftKey) {
            const n = r.getFirstPosition();
            const s = r.getLastPosition();
            const a = n.nodeAfter;
            const l = s.nodeBefore;
            if ((a && i.isObject(a)) || (l && i.isObject(l))) {
              o.change(t => {
                t.setSelection(c ? s : n);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed) {
            return;
          }
          const d = this._getObjectElementNextToSelection(c);
          if (d && i.isObject(d)) {
            if (i.isInline(d) && l) {
              return;
            }
            this._setSelectionOverElement(d);
            e.preventDefault();
            t.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model;
          const o = n.schema;
          const i = n.document.selection.getSelectedElement();
          if (i && o.isObject(i)) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleDelete(t) {
          const e = this.editor.model.document;
          const n = e.selection;
          if (!this.editor.model.canEditAt(n)) {
            return;
          }
          if (!n.isCollapsed) {
            return;
          }
          const o = this._getObjectElementNextToSelection(t);
          if (o) {
            this.editor.model.change(t => {
              let e = n.anchor.parent;
              while (e.isEmpty) {
                const n = e;
                e = n.parent;
                t.remove(n);
              }
              this._setSelectionOverElement(o);
            });
            return true;
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change(e => {
            e.setSelection(e.createRangeOn(t));
          });
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model;
          const n = e.schema;
          const o = e.document.selection;
          const i = e.createSelection(o);
          e.modifySelection(i, { direction: t ? 'forward' : 'backward' });
          if (i.isEqual(o)) {
            return null;
          }
          const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
          if (!!r && n.isObject(r)) {
            return r;
          }
          return null;
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(KS, e);
          }
          this._previouslySelected.clear();
        }
      }
      function VP(t) {
        let e = t;
        while (e) {
          if (e.is('editableElement') && !e.is('rootElement')) {
            return true;
          }
          if (US(e)) {
            return false;
          }
          e = e.parent;
        }
        return false;
      }
      function zP(t, e) {
        if (!e) {
          return false;
        }
        return Array.from(t.getAncestors()).includes(e);
      }
      function FP(t, e) {
        for (const n of t.getAncestors({
          includeSelf: true,
          parentFirst: true,
        })) {
          if (e.checkChild(n, '$text')) {
            return n;
          }
          if (e.isLimit(n) && !e.isObject(n)) {
            break;
          }
        }
        return null;
      }
      function NP(t, e) {
        const n = new Pk({ startPosition: t });
        for (const { item: t } of n) {
          if (e.isLimit(t) || !t.is('element')) {
            return null;
          }
          if (e.checkChild(t, '$text')) {
            return t;
          }
        }
        return null;
      }
      class LP extends (null && Plugin) {
        constructor() {
          super(...arguments);
          this._toolbarDefinitions = new Map();
        }
        static get requires() {
          return [ContextualBalloon];
        }
        static get pluginName() {
          return 'WidgetToolbarRepository';
        }
        init() {
          const t = this.editor;
          if (t.plugins.has('BalloonToolbar')) {
            const e = t.plugins.get('BalloonToolbar');
            this.listenTo(
              e,
              'show',
              e => {
                if (qP(t.editing.view.document.selection)) {
                  e.stop();
                }
              },
              { priority: 'high' },
            );
          }
          this._balloon = this.editor.plugins.get('ContextualBalloon');
          this.on('change:isEnabled', () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(t.ui, 'update', () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(
            t.ui.focusTracker,
            'change:isFocused',
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: 'low' },
          );
        }
        destroy() {
          super.destroy();
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy();
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: o,
            balloonClassName: i = 'ck-toolbar-container',
          },
        ) {
          if (!n.length) {
            logWarning('widget-toolbar-no-items', { toolbarId: t });
            return;
          }
          const r = this.editor;
          const s = r.t;
          const a = new ToolbarView(r.locale);
          a.ariaLabel = e || s('Widget toolbar');
          if (this._toolbarDefinitions.has(t)) {
            throw new CKEditorError('widget-toolbar-duplicated', this, {
              toolbarId: t,
            });
          }
          const c = {
            view: a,
            getRelatedElement: o,
            balloonClassName: i,
            itemsConfig: n,
            initialized: false,
          };
          r.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = o(r.editing.view.document.selection);
              if (t) {
                this._showToolbar(c, t);
              }
            },
            afterBlur: () => {
              this._hideToolbar(c);
            },
          });
          this._toolbarDefinitions.set(t, c);
        }
        _updateToolbarsVisibility() {
          let t = 0;
          let e = null;
          let n = null;
          for (const o of this._toolbarDefinitions.values()) {
            const i = o.getRelatedElement(
              this.editor.editing.view.document.selection,
            );
            if (!this.isEnabled || !i) {
              if (this._isToolbarInBalloon(o)) {
                this._hideToolbar(o);
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(o)) {
                this._hideToolbar(o);
              }
            } else {
              const r = i.getAncestors().length;
              if (r > t) {
                t = r;
                e = i;
                n = o;
              }
            }
          }
          if (n) {
            this._showToolbar(n, e);
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view);
          this.stopListening(this._balloon, 'change:visibleView');
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            HP(this.editor, e);
          } else if (!this._isToolbarInBalloon(t)) {
            if (!t.initialized) {
              t.initialized = true;
              t.view.fillFromConfig(
                t.itemsConfig,
                this.editor.ui.componentFactory,
              );
            }
            this._balloon.add({
              view: t.view,
              position: jP(this.editor, e),
              balloonClassName: t.balloonClassName,
            });
            this.listenTo(this._balloon, 'change:visibleView', () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(
                    this.editor.editing.view.document.selection,
                  );
                  HP(this.editor, e);
                }
              }
            });
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view;
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view);
        }
      }
      function HP(t, e) {
        const n = t.plugins.get('ContextualBalloon');
        const o = jP(t, e);
        n.updatePosition(o);
      }
      function jP(t, e) {
        const n = t.editing.view;
        const o = BalloonPanelView.defaultPositions;
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            o.northArrowSouth,
            o.northArrowSouthWest,
            o.northArrowSouthEast,
            o.southArrowNorth,
            o.southArrowNorthWest,
            o.southArrowNorthEast,
            o.viewportStickyNorth,
          ],
        };
      }
      function qP(t) {
        const e = t.getSelectedElement();
        return !!(e && isWidget(e));
      }
      class $P extends dt() {
        constructor(t) {
          super();
          this.set('activeHandlePosition', null);
          this.set('proposedWidthPercents', null);
          this.set('proposedWidth', null);
          this.set('proposedHeight', null);
          this.set('proposedHandleHostWidth', null);
          this.set('proposedHandleHostHeight', null);
          this._options = t;
          this._referenceCoordinates = null;
        }
        get originalWidth() {
          return this._originalWidth;
        }
        get originalHeight() {
          return this._originalHeight;
        }
        get originalWidthPercents() {
          return this._originalWidthPercents;
        }
        get aspectRatio() {
          return this._aspectRatio;
        }
        begin(t, e, n) {
          const o = new cc(e);
          this.activeHandlePosition = UP(t);
          this._referenceCoordinates = GP(e, ZP(this.activeHandlePosition));
          this._originalWidth = o.width;
          this._originalHeight = o.height;
          this._aspectRatio = o.width / o.height;
          const i = n.style.width;
          if (i && i.match(/^\d+(\.\d*)?%$/)) {
            this._originalWidthPercents = parseFloat(i);
          } else {
            this._originalWidthPercents = WP(n, o);
          }
        }
        update(t) {
          this.proposedWidth = t.width;
          this.proposedHeight = t.height;
          this.proposedWidthPercents = t.widthPercents;
          this.proposedHandleHostWidth = t.handleHostWidth;
          this.proposedHandleHostHeight = t.handleHostHeight;
        }
      }
      function WP(t, e) {
        const n = t.parentElement;
        let o = parseFloat(
          n.ownerDocument.defaultView.getComputedStyle(n).width,
        );
        const i = 5;
        let r = 0;
        let s = n;
        while (isNaN(o)) {
          s = s.parentElement;
          if (++r > i) {
            return 0;
          }
          o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width);
        }
        return (e.width / o) * 100;
      }
      function GP(t, e) {
        const n = new cc(t);
        const o = e.split('-');
        const i = {
          x: o[1] == 'right' ? n.right : n.left,
          y: o[0] == 'bottom' ? n.bottom : n.top,
        };
        i.x += t.ownerDocument.defaultView.scrollX;
        i.y += t.ownerDocument.defaultView.scrollY;
        return i;
      }
      function KP(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function UP(t) {
        const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
        for (const n of e) {
          if (t.classList.contains(KP(n))) {
            return n;
          }
        }
      }
      function ZP(t) {
        const e = t.split('-');
        const n = {
          top: 'bottom',
          bottom: 'top',
          left: 'right',
          right: 'left',
        };
        return `${n[e[0]]}-${n[e[1]]}`;
      }
      class JP extends Vl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-size-view',
                t.to('_viewPosition', t => (t ? `ck-orientation-${t}` : '')),
              ],
              style: { display: t.if('_isVisible', 'none', t => !t) },
            },
            children: [{ text: t.to('_label') }],
          });
        }
        _bindToState(t, e) {
          this.bind('_isVisible').to(
            e,
            'proposedWidth',
            e,
            'proposedHeight',
            (t, e) => t !== null && e !== null,
          );
          this.bind('_label').to(
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            e,
            'proposedWidthPercents',
            (e, n, o) => {
              if (t.unit === 'px') {
                return `${e}${n}`;
              } else {
                return `${o}%`;
              }
            },
          );
          this.bind('_viewPosition').to(
            e,
            'activeHandlePosition',
            e,
            'proposedHandleHostWidth',
            e,
            'proposedHandleHostHeight',
            (t, e, n) => (e < 50 || n < 50 ? 'above-center' : t),
          );
        }
        _dismiss() {
          this.unbind();
          this._isVisible = false;
        }
      }
      class YP extends dt() {
        constructor(t) {
          super();
          this._viewResizerWrapper = null;
          this._options = t;
          this.set('isEnabled', true);
          this.set('isSelected', false);
          this.bind('isVisible').to(
            this,
            'isEnabled',
            this,
            'isSelected',
            (t, e) => t && e,
          );
          this.decorate('begin');
          this.decorate('cancel');
          this.decorate('commit');
          this.decorate('updateSize');
          this.on(
            'commit',
            t => {
              if (
                !this.state.proposedWidth &&
                !this.state.proposedWidthPercents
              ) {
                this._cleanup();
                t.stop();
              }
            },
            { priority: 'high' },
          );
        }
        get state() {
          return this._state;
        }
        show() {
          const t = this._options.editor.editing.view;
          t.change(t => {
            t.removeClass('ck-hidden', this._viewResizerWrapper);
          });
        }
        hide() {
          const t = this._options.editor.editing.view;
          t.change(t => {
            t.addClass('ck-hidden', this._viewResizerWrapper);
          });
        }
        attach() {
          const t = this;
          const e = this._options.viewElement;
          const n = this._options.editor.editing.view;
          n.change(n => {
            const o = n.createUIElement(
              'div',
              { class: 'ck ck-reset_all ck-widget__resizer' },
              function (e) {
                const n = this.toDomElement(e);
                t._appendHandles(n);
                t._appendSizeUI(n);
                return n;
              },
            );
            n.insert(n.createPositionAt(e, 'end'), o);
            n.addClass('ck-widget_with-resizer', e);
            this._viewResizerWrapper = o;
            if (!this.isVisible) {
              this.hide();
            }
          });
          this.on('change:isVisible', () => {
            if (this.isVisible) {
              this.show();
              this.redraw();
            } else {
              this.hide();
            }
          });
        }
        begin(t) {
          this._state = new $P(this._options);
          this._sizeView._bindToState(this._options, this.state);
          this._initialViewWidth = this._options.viewElement.getStyle('width');
          this.state.begin(t, this._getHandleHost(), this._getResizeHost());
        }
        updateSize(t) {
          const e = this._proposeNewSize(t);
          const n = this._options.editor.editing.view;
          n.change(t => {
            const n = this._options.unit || '%';
            const o = (n === '%' ? e.widthPercents : e.width) + n;
            t.setStyle('width', o, this._options.viewElement);
          });
          const o = this._getHandleHost();
          const i = new cc(o);
          const r = Math.round(i.width);
          const s = Math.round(i.height);
          const a = new cc(o);
          e.width = Math.round(a.width);
          e.height = Math.round(a.height);
          this.redraw(i);
          this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s });
        }
        commit() {
          const t = this._options.unit || '%';
          const e =
            (t === '%'
              ? this.state.proposedWidthPercents
              : this.state.proposedWidth) + t;
          this._options.editor.editing.view.change(() => {
            this._cleanup();
            this._options.onCommit(e);
          });
        }
        cancel() {
          this._cleanup();
        }
        destroy() {
          this.cancel();
        }
        redraw(t) {
          const e = this._domResizerWrapper;
          if (!tB(e)) {
            return;
          }
          const n = e.parentElement;
          const o = this._getHandleHost();
          const i = this._viewResizerWrapper;
          const r = [
            i.getStyle('width'),
            i.getStyle('height'),
            i.getStyle('left'),
            i.getStyle('top'),
          ];
          let s;
          if (n.isSameNode(o)) {
            const e = t || new cc(o);
            s = [e.width + 'px', e.height + 'px', undefined, undefined];
          } else {
            s = [
              o.offsetWidth + 'px',
              o.offsetHeight + 'px',
              o.offsetLeft + 'px',
              o.offsetTop + 'px',
            ];
          }
          if (Ct(r, s) !== 'same') {
            this._options.editor.editing.view.change(t => {
              t.setStyle(
                { width: s[0], height: s[1], left: s[2], top: s[3] },
                i,
              );
            });
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t);
        }
        static isResizeHandle(t) {
          return t.classList.contains('ck-widget__resizer__handle');
        }
        _cleanup() {
          this._sizeView._dismiss();
          const t = this._options.editor.editing.view;
          t.change(t => {
            t.setStyle(
              'width',
              this._initialViewWidth,
              this._options.viewElement,
            );
          });
        }
        _proposeNewSize(t) {
          const e = this.state;
          const n = XP(t);
          const o = this._options.isCentered
            ? this._options.isCentered(this)
            : true;
          const i = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          };
          if (o && e.activeHandlePosition.endsWith('-right')) {
            i.x = n.x - (e._referenceCoordinates.x + e.originalWidth);
          }
          if (o) {
            i.x *= 2;
          }
          let r = Math.abs(e.originalWidth + i.x);
          let s = Math.abs(e.originalHeight + i.y);
          const a = r / e.aspectRatio > s ? 'width' : 'height';
          if (a == 'width') {
            s = r / e.aspectRatio;
          } else {
            r = s * e.aspectRatio;
          }
          return {
            width: Math.round(r),
            height: Math.round(s),
            widthPercents: Math.min(
              Math.round(
                (e.originalWidthPercents / e.originalWidth) * r * 100,
              ) / 100,
              100,
            ),
          };
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getResizeHost(t);
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement;
          return this._options.getHandleHost(t);
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(
            this._viewResizerWrapper,
          );
        }
        _appendHandles(t) {
          const e = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
          for (const n of e) {
            t.appendChild(
              new Fl({
                tag: 'div',
                attributes: { class: `ck-widget__resizer__handle ${QP(n)}` },
              }).render(),
            );
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new JP();
          this._sizeView.render();
          t.appendChild(this._sizeView.element);
        }
      }
      function QP(t) {
        return `ck-widget__resizer__handle-${t}`;
      }
      function XP(t) {
        return { x: t.pageX, y: t.pageY };
      }
      function tB(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t);
      }
      var eB = n(875);
      var nB = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      nB.insert = 'head';
      nB.singleton = true;
      var oB = Bl()(eB.Z, nB);
      const iB = eB.Z.locals || {};
      class rB extends (null && Plugin) {
        constructor() {
          super(...arguments);
          this._resizers = new Map();
        }
        static get pluginName() {
          return 'WidgetResize';
        }
        init() {
          const t = this.editor.editing;
          const e = global.window.document;
          this.set('selectedResizer', null);
          this.set('_activeResizer', null);
          t.view.addObserver(MouseObserver);
          this._observer = new (DomEmitterMixin())();
          this.listenTo(
            t.view.document,
            'mousedown',
            this._mouseDownListener.bind(this),
            { priority: 'high' },
          );
          this._observer.listenTo(
            e,
            'mousemove',
            this._mouseMoveListener.bind(this),
          );
          this._observer.listenTo(
            e,
            'mouseup',
            this._mouseUpListener.bind(this),
          );
          this._redrawSelectedResizerThrottled = throttle(
            () => this.redrawSelectedResizer(),
            200,
          );
          this.editor.ui.on('update', this._redrawSelectedResizerThrottled);
          this.editor.model.document.on(
            'change',
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t);
                  e.destroy();
                }
              }
            },
            { priority: 'lowest' },
          );
          this._observer.listenTo(
            global.window,
            'resize',
            this._redrawSelectedResizerThrottled,
          );
          const n = this.editor.editing.view.document.selection;
          n.on('change', () => {
            const t = n.getSelectedElement();
            const e = this.getResizerByViewElement(t) || null;
            if (e) {
              this.select(e);
            } else {
              this.deselect();
            }
          });
        }
        redrawSelectedResizer() {
          if (this.selectedResizer && this.selectedResizer.isVisible) {
            this.selectedResizer.redraw();
          }
        }
        destroy() {
          super.destroy();
          this._observer.stopListening();
          for (const t of this._resizers.values()) {
            t.destroy();
          }
          this._redrawSelectedResizerThrottled.cancel();
        }
        select(t) {
          this.deselect();
          this.selectedResizer = t;
          this.selectedResizer.isSelected = true;
        }
        deselect() {
          if (this.selectedResizer) {
            this.selectedResizer.isSelected = false;
          }
          this.selectedResizer = null;
        }
        attachTo(t) {
          const e = new Resizer(t);
          const n = this.editor.plugins;
          e.attach();
          if (n.has('WidgetToolbarRepository')) {
            const t = n.get('WidgetToolbarRepository');
            e.on(
              'begin',
              () => {
                t.forceDisabled('resize');
              },
              { priority: 'lowest' },
            );
            e.on(
              'cancel',
              () => {
                t.clearForceDisabled('resize');
              },
              { priority: 'highest' },
            );
            e.on(
              'commit',
              () => {
                t.clearForceDisabled('resize');
              },
              { priority: 'highest' },
            );
          }
          this._resizers.set(t.viewElement, e);
          const o = this.editor.editing.view.document.selection;
          const i = o.getSelectedElement();
          if (this.getResizerByViewElement(i) == e) {
            this.select(e);
          }
          return e;
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t);
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e;
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget;
          if (!Resizer.isResizeHandle(n)) {
            return;
          }
          this._activeResizer = this._getResizerByHandle(n) || null;
          if (this._activeResizer) {
            this._activeResizer.begin(n);
            t.stop();
            e.preventDefault();
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e);
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit();
            this._activeResizer = null;
          }
        }
      }
      const sB = kc('px');
      class aB extends Vl {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set({ isVisible: false, left: null, top: null, width: null });
          this.setTemplate({
            tag: 'div',
            attributes: {
              class: [
                'ck',
                'ck-clipboard-drop-target-line',
                t.if('isVisible', 'ck-hidden', t => !t),
              ],
              style: {
                left: t.to('left', t => sB(t)),
                top: t.to('top', t => sB(t)),
                width: t.to('width', t => sB(t)),
              },
            },
          });
        }
      }
      class cB extends Sh {
        constructor() {
          super(...arguments);
          this.removeDropMarkerDelayed = bl(() => this.removeDropMarker(), 40);
          this._updateDropMarkerThrottled = yE(
            t => this._updateDropMarker(t),
            40,
          );
          this._reconvertMarkerThrottled = yE(() => {
            if (this.editor.model.markers.has('drop-target')) {
              this.editor.editing.reconvertMarker('drop-target');
            }
          }, 0);
          this._dropTargetLineView = new aB();
          this._domEmitter = new (Ua())();
          this._scrollables = new Map();
        }
        static get pluginName() {
          return 'DragDropTarget';
        }
        init() {
          this._setupDropMarker();
        }
        destroy() {
          this._domEmitter.stopListening();
          for (const { resizeObserver: t } of this._scrollables.values()) {
            t.destroy();
          }
          this._updateDropMarkerThrottled.cancel();
          this.removeDropMarkerDelayed.cancel();
          this._reconvertMarkerThrottled.cancel();
          return super.destroy();
        }
        updateDropMarker(t, e, n, o, i, r) {
          this.removeDropMarkerDelayed.cancel();
          const s = lB(this.editor, t, e, n, o, i, r);
          if (!s) {
            return;
          }
          if (r && r.containsRange(s)) {
            return this.removeDropMarker();
          }
          this._updateDropMarkerThrottled(s);
        }
        getFinalDropRange(t, e, n, o, i, r) {
          const s = lB(this.editor, t, e, n, o, i, r);
          this.removeDropMarker();
          return s;
        }
        removeDropMarker() {
          const t = this.editor.model;
          this.removeDropMarkerDelayed.cancel();
          this._updateDropMarkerThrottled.cancel();
          this._dropTargetLineView.isVisible = false;
          if (t.markers.has('drop-target')) {
            t.change(t => {
              t.removeMarker('drop-target');
            });
          }
        }
        _setupDropMarker() {
          const t = this.editor;
          t.ui.view.body.add(this._dropTargetLineView);
          t.conversion.for('editingDowncast').markerToHighlight({
            model: 'drop-target',
            view: { classes: ['ck-clipboard-drop-target-range'] },
          });
          t.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (e, { writer: n }) => {
              if (t.model.schema.checkChild(e.markerRange.start, '$text')) {
                this._dropTargetLineView.isVisible = false;
                return this._createDropTargetPosition(n);
              } else {
                if (e.markerRange.isCollapsed) {
                  this._updateDropTargetLine(e.markerRange);
                } else {
                  this._dropTargetLineView.isVisible = false;
                }
              }
            },
          });
        }
        _updateDropMarker(t) {
          const e = this.editor;
          const n = e.model.markers;
          e.model.change(e => {
            if (n.has('drop-target')) {
              if (!n.get('drop-target').getRange().isEqual(t)) {
                e.updateMarker('drop-target', { range: t });
              }
            } else {
              e.addMarker('drop-target', {
                range: t,
                usingOperation: false,
                affectsData: false,
              });
            }
          });
        }
        _createDropTargetPosition(t) {
          return t.createUIElement(
            'span',
            { class: 'ck ck-clipboard-drop-target-position' },
            function (t) {
              const e = this.toDomElement(t);
              e.append('', t.createElement('span'), '');
              return e;
            },
          );
        }
        _updateDropTargetLine(t) {
          const e = this.editor.editing;
          const n = t.start.nodeBefore;
          const o = t.start.nodeAfter;
          const i = t.start.parent;
          const r = n ? e.mapper.toViewElement(n) : null;
          const s = r ? e.view.domConverter.mapViewToDom(r) : null;
          const a = o ? e.mapper.toViewElement(o) : null;
          const c = a ? e.view.domConverter.mapViewToDom(a) : null;
          const l = e.mapper.toViewElement(i);
          const d = e.view.domConverter.mapViewToDom(l);
          const h = this._getScrollableRect(l);
          const { scrollX: u, scrollY: f } = Xa.window;
          const p = s ? new cc(s) : null;
          const g = c ? new cc(c) : null;
          const m = new cc(d).excludeScrollbarsAndBorders();
          const k = p ? p.bottom : m.top;
          const b = g ? g.top : m.bottom;
          const w = Xa.window.getComputedStyle(d);
          const _ = k <= b ? (k + b) / 2 : b;
          if (h.top < _ && _ < h.bottom) {
            const t = m.left + parseFloat(w.paddingLeft);
            const e = m.right - parseFloat(w.paddingRight);
            const n = Math.max(t + u, h.left);
            const o = Math.min(e + u, h.right);
            this._dropTargetLineView.set({
              isVisible: true,
              left: n,
              top: _ + f,
              width: o - n,
            });
          } else {
            this._dropTargetLineView.isVisible = false;
          }
        }
        _getScrollableRect(t) {
          const e = t.root.rootName;
          let n;
          if (this._scrollables.has(e)) {
            n = this._scrollables.get(e).domElement;
          } else {
            const o = this.editor.editing.view.domConverter.mapViewToDom(t);
            n = pB(o);
            this._domEmitter.listenTo(
              n,
              'scroll',
              this._reconvertMarkerThrottled,
              { usePassive: true },
            );
            const i = new gc(n, this._reconvertMarkerThrottled);
            this._scrollables.set(e, { domElement: n, resizeObserver: i });
          }
          return new cc(n).excludeScrollbarsAndBorders();
        }
      }
      function lB(t, e, n, o, i, r, s) {
        const a = t.model;
        const c = t.editing.mapper;
        const l = fB(t, e);
        let d = l;
        while (d) {
          if (!r) {
            if (a.schema.checkChild(d, '$text')) {
              if (n) {
                const e = n[0].start;
                const r = c.toModelPosition(e);
                const l =
                  !s ||
                  Array.from(s.getItems()).every(t =>
                    a.schema.checkChild(r, t),
                  );
                if (l) {
                  if (a.schema.checkChild(r, '$text')) {
                    return a.createRange(r);
                  } else if (e) {
                    return hB(t, fB(t, e.parent), o, i);
                  }
                }
              }
            } else if (a.schema.isInline(d)) {
              return hB(t, d, o, i);
            }
          }
          if (a.schema.isBlock(d)) {
            return hB(t, d, o, i);
          } else if (a.schema.checkChild(d, '$block')) {
            const e = Array.from(d.getChildren()).filter(
              e => e.is('element') && !dB(t, e),
            );
            let n = 0;
            let r = e.length;
            if (r == 0) {
              return a.createRange(a.createPositionAt(d, 'end'));
            }
            while (n < r - 1) {
              const s = Math.floor((n + r) / 2);
              const a = uB(t, e[s], o, i);
              if (a == 'before') {
                r = s;
              } else {
                n = s;
              }
            }
            return hB(t, e[n], o, i);
          }
          d = d.parent;
        }
        return null;
      }
      function dB(t, e) {
        const n = t.editing.mapper;
        const o = t.editing.view.domConverter;
        const i = n.toViewElement(e);
        const r = o.mapViewToDom(i);
        return Xa.window.getComputedStyle(r).float != 'none';
      }
      function hB(t, e, n, o) {
        const i = t.model;
        return i.createRange(i.createPositionAt(e, uB(t, e, n, o)));
      }
      function uB(t, e, n, o) {
        const i = t.editing.mapper;
        const r = t.editing.view.domConverter;
        const s = i.toViewElement(e);
        const a = r.mapViewToDom(s);
        const c = new cc(a);
        if (t.model.schema.isInline(e)) {
          return n < (c.left + c.right) / 2 ? 'before' : 'after';
        } else {
          return o < (c.top + c.bottom) / 2 ? 'before' : 'after';
        }
      }
      function fB(t, e) {
        const n = t.editing.mapper;
        const o = t.editing.view;
        const i = n.toModelElement(e);
        if (i) {
          return i;
        }
        const r = o.createPositionBefore(e);
        const s = n.findMappedViewAncestor(r);
        return n.toModelElement(s);
      }
      function pB(t) {
        let e = t;
        do {
          e = e.parentElement;
          const t = Xa.window.getComputedStyle(e).overflowY;
          if (t == 'auto' || t == 'scroll') {
            break;
          }
        } while (e.tagName != 'BODY');
        return e;
      }
      class gB extends Sh {
        constructor() {
          super(...arguments);
          this._isBlockDragging = false;
          this._domEmitter = new (Ua())();
        }
        static get pluginName() {
          return 'DragDropBlockToolbar';
        }
        init() {
          const t = this.editor;
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode');
              this._isBlockDragging = false;
            } else {
              this.clearForceDisabled('readOnlyMode');
            }
          });
          if (s.isAndroid) {
            this.forceDisabled('noAndroidSupport');
          }
          if (t.plugins.has('BlockToolbar')) {
            const e = t.plugins.get('BlockToolbar');
            const n = e.buttonView.element;
            this._domEmitter.listenTo(n, 'dragstart', (t, e) =>
              this._handleBlockDragStart(e),
            );
            this._domEmitter.listenTo(Xa.document, 'dragover', (t, e) =>
              this._handleBlockDragging(e),
            );
            this._domEmitter.listenTo(Xa.document, 'drop', (t, e) =>
              this._handleBlockDragging(e),
            );
            this._domEmitter.listenTo(
              Xa.document,
              'dragend',
              () => this._handleBlockDragEnd(),
              { useCapture: true },
            );
            if (this.isEnabled) {
              n.setAttribute('draggable', 'true');
            }
            this.on('change:isEnabled', (t, e, o) => {
              n.setAttribute('draggable', o ? 'true' : 'false');
            });
          }
        }
        destroy() {
          this._domEmitter.stopListening();
          return super.destroy();
        }
        _handleBlockDragStart(t) {
          if (!this.isEnabled) {
            return;
          }
          const e = this.editor.model;
          const n = e.document.selection;
          const o = this.editor.editing.view;
          const i = Array.from(n.getSelectedBlocks());
          const r = e.createRange(
            e.createPositionBefore(i[0]),
            e.createPositionAfter(i[i.length - 1]),
          );
          e.change(t => t.setSelection(r));
          this._isBlockDragging = true;
          o.focus();
          o.getObserver(FT).onDomEvent(t);
        }
        _handleBlockDragging(t) {
          if (!this.isEnabled || !this._isBlockDragging) {
            return;
          }
          const e =
            t.clientX +
            (this.editor.locale.contentLanguageDirection == 'ltr' ? 100 : -100);
          const n = t.clientY;
          const o = document.elementFromPoint(e, n);
          const i = this.editor.editing.view;
          if (!o || !o.closest('.ck-editor__editable')) {
            return;
          }
          i.getObserver(FT).onDomEvent({
            ...t,
            type: t.type,
            dataTransfer: t.dataTransfer,
            target: o,
            clientX: e,
            clientY: n,
            preventDefault: () => t.preventDefault(),
            stopPropagation: () => t.stopPropagation(),
          });
        }
        _handleBlockDragEnd() {
          this._isBlockDragging = false;
        }
      }
      var mB = n(799);
      var kB = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      kB.insert = 'head';
      kB.singleton = true;
      var bB = Bl()(mB.Z, kB);
      const wB = mB.Z.locals || {};
      class _B extends Sh {
        constructor() {
          super(...arguments);
          this._clearDraggableAttributesDelayed = bl(
            () => this._clearDraggableAttributes(),
            40,
          );
          this._blockMode = false;
          this._domEmitter = new (Ua())();
        }
        static get pluginName() {
          return 'DragDrop';
        }
        static get requires() {
          return [GT, MP, cB, gB];
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this._draggedRange = null;
          this._draggingUid = '';
          this._draggableElement = null;
          e.addObserver(FT);
          e.addObserver(Xv);
          this._setupDragging();
          this._setupContentInsertionIntegration();
          this._setupClipboardInputIntegration();
          this._setupDraggableAttributeHandling();
          this.listenTo(t, 'change:isReadOnly', (t, e, n) => {
            if (n) {
              this.forceDisabled('readOnlyMode');
            } else {
              this.clearForceDisabled('readOnlyMode');
            }
          });
          this.on('change:isEnabled', (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false);
            }
          });
          if (s.isAndroid) {
            this.forceDisabled('noAndroidSupport');
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach();
            this._draggedRange = null;
          }
          if (this._previewContainer) {
            this._previewContainer.remove();
          }
          this._domEmitter.stopListening();
          this._clearDraggableAttributesDelayed.cancel();
          return super.destroy();
        }
        _setupDragging() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          const i = t.plugins.get(cB);
          this.listenTo(
            o,
            'dragstart',
            (t, n) => {
              if (n.target && n.target.is('editableElement')) {
                n.preventDefault();
                return;
              }
              this._prepareDraggedRange(n.target);
              if (!this._draggedRange) {
                n.preventDefault();
                return;
              }
              this._draggingUid = E();
              n.dataTransfer.effectAllowed = this.isEnabled
                ? 'copyMove'
                : 'copy';
              n.dataTransfer.setData(
                'application/ckeditor5-dragging-uid',
                this._draggingUid,
              );
              const o = e.createSelection(this._draggedRange.toRange());
              const i = this.editor.plugins.get('ClipboardPipeline');
              i._fireOutputTransformationEvent(n.dataTransfer, o, 'dragstart');
              const { dataTransfer: r, domTarget: s, domEvent: a } = n;
              const { clientX: c } = a;
              this._updatePreview({
                dataTransfer: r,
                domTarget: s,
                clientX: c,
              });
              n.stopPropagation();
              if (!this.isEnabled) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
              }
            },
            { priority: 'low' },
          );
          this.listenTo(
            o,
            'dragend',
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled &&
                  e.dataTransfer.dropEffect == 'move',
              );
            },
            { priority: 'low' },
          );
          this._domEmitter.listenTo(
            Xa.document,
            'dragend',
            () => {
              this._blockMode = false;
            },
            { useCapture: true },
          );
          this.listenTo(o, 'dragenter', () => {
            if (!this.isEnabled) {
              return;
            }
            n.focus();
          });
          this.listenTo(o, 'dragleave', () => {
            i.removeDropMarkerDelayed();
          });
          this.listenTo(
            o,
            'dragging',
            (t, e) => {
              if (!this.isEnabled) {
                e.dataTransfer.dropEffect = 'none';
                return;
              }
              const { clientX: n, clientY: o } = e.domEvent;
              i.updateDropMarker(
                e.target,
                e.targetRanges,
                n,
                o,
                this._blockMode,
                this._draggedRange,
              );
              if (!this._draggedRange) {
                e.dataTransfer.dropEffect = 'copy';
              }
              if (!s.isGecko) {
                if (e.dataTransfer.effectAllowed == 'copy') {
                  e.dataTransfer.dropEffect = 'copy';
                } else if (
                  ['all', 'copyMove'].includes(e.dataTransfer.effectAllowed)
                ) {
                  e.dataTransfer.dropEffect = 'move';
                }
              }
              t.stop();
            },
            { priority: 'low' },
          );
        }
        _setupClipboardInputIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          const o = t.plugins.get(cB);
          this.listenTo(
            n,
            'clipboardInput',
            (e, n) => {
              if (n.method != 'drop') {
                return;
              }
              const { clientX: i, clientY: r } = n.domEvent;
              const s = o.getFinalDropRange(
                n.target,
                n.targetRanges,
                i,
                r,
                this._blockMode,
                this._draggedRange,
              );
              if (!s) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              if (
                this._draggedRange &&
                this._draggingUid !=
                  n.dataTransfer.getData('application/ckeditor5-dragging-uid')
              ) {
                this._draggedRange.detach();
                this._draggedRange = null;
                this._draggingUid = '';
              }
              const a = vB(n.dataTransfer) == 'move';
              if (
                a &&
                this._draggedRange &&
                this._draggedRange.containsRange(s, true)
              ) {
                this._finalizeDragging(false);
                e.stop();
                return;
              }
              n.targetRanges = [t.editing.mapper.toViewRange(s)];
            },
            { priority: 'high' },
          );
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(GT);
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return;
              }
              const n = e.targetRanges.map(t =>
                this.editor.editing.mapper.toModelRange(t),
              );
              this.editor.model.change(t => t.setSelection(n));
            },
            { priority: 'high' },
          );
          t.on(
            'contentInsertion',
            (t, e) => {
              if (!this.isEnabled || e.method !== 'drop') {
                return;
              }
              const n = vB(e.dataTransfer) == 'move';
              const o = !e.resultRange || !e.resultRange.isCollapsed;
              this._finalizeDragging(o && n);
            },
            { priority: 'lowest' },
          );
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this.listenTo(n, 'mousedown', (o, i) => {
            if (s.isAndroid || !i) {
              return;
            }
            this._clearDraggableAttributesDelayed.cancel();
            let r = AB(i.target);
            if (s.isBlink && !t.isReadOnly && !r && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement();
              if (!t || !US(t)) {
                r = n.selection.editableElement;
              }
            }
            if (r) {
              e.change(t => {
                t.setAttribute('draggable', 'true', r);
              });
              this._draggableElement = t.editing.mapper.toModelElement(r);
            }
          });
          this.listenTo(n, 'mouseup', () => {
            if (!s.isAndroid) {
              this._clearDraggableAttributesDelayed();
            }
          });
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing;
          t.view.change(e => {
            if (
              this._draggableElement &&
              this._draggableElement.root.rootName != '$graveyard'
            ) {
              e.removeAttribute(
                'draggable',
                t.mapper.toViewElement(this._draggableElement),
              );
            }
            this._draggableElement = null;
          });
        }
        _finalizeDragging(t) {
          const e = this.editor;
          const n = e.model;
          const o = e.plugins.get(cB);
          o.removeDropMarker();
          this._clearDraggableAttributes();
          if (e.plugins.has('WidgetToolbarRepository')) {
            const t = e.plugins.get('WidgetToolbarRepository');
            t.clearForceDisabled('dragDrop');
          }
          this._draggingUid = '';
          if (this._previewContainer) {
            this._previewContainer.remove();
            this._previewContainer = undefined;
          }
          if (!this._draggedRange) {
            return;
          }
          if (t && this.isEnabled) {
            n.change(t => {
              const e = n.createSelection(this._draggedRange);
              n.deleteContent(e, { doNotAutoparagraph: true });
              const o = e.getFirstPosition().parent;
              if (
                o.isEmpty &&
                !n.schema.checkChild(o, '$text') &&
                n.schema.checkChild(o, 'paragraph')
              ) {
                t.insertElement('paragraph', o, 0);
              }
            });
          }
          this._draggedRange.detach();
          this._draggedRange = null;
        }
        _prepareDraggedRange(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.document.selection;
          const i = t ? AB(t) : null;
          if (i) {
            const t = e.editing.mapper.toModelElement(i);
            this._draggedRange = eb.fromRange(n.createRangeOn(t));
            this._blockMode = n.schema.isBlock(t);
            if (e.plugins.has('WidgetToolbarRepository')) {
              const t = e.plugins.get('WidgetToolbarRepository');
              t.forceDisabled('dragDrop');
            }
            return;
          }
          if (o.isCollapsed && !o.getFirstPosition().parent.isEmpty) {
            return;
          }
          const r = Array.from(o.getSelectedBlocks());
          const s = o.getFirstRange();
          if (r.length == 0) {
            this._draggedRange = eb.fromRange(s);
            return;
          }
          const a = CB(n, r);
          if (r.length > 1) {
            this._draggedRange = eb.fromRange(a);
            this._blockMode = true;
          } else if (r.length == 1) {
            const t = s.start.isTouching(a.start) && s.end.isTouching(a.end);
            this._draggedRange = eb.fromRange(t ? a : s);
            this._blockMode = t;
          }
          n.change(t => t.setSelection(this._draggedRange.toRange()));
        }
        _updatePreview({ dataTransfer: t, domTarget: e, clientX: n }) {
          const o = this.editor.editing.view;
          const i = o.document.selection.editableElement;
          const r = o.domConverter.mapViewToDom(i);
          const a = Xa.window.getComputedStyle(r);
          if (!this._previewContainer) {
            this._previewContainer = te(Xa.document, 'div', {
              style: 'position: fixed; left: -999999px;',
            });
            Xa.document.body.appendChild(this._previewContainer);
          } else if (this._previewContainer.firstElementChild) {
            this._previewContainer.removeChild(
              this._previewContainer.firstElementChild,
            );
          }
          const c = new cc(r);
          if (r.contains(e)) {
            return;
          }
          const l = parseFloat(a.paddingLeft);
          const d = te(Xa.document, 'div');
          d.className = 'ck ck-content';
          d.style.width = a.width;
          d.style.paddingLeft = `${c.left - n + l}px`;
          if (s.isiOS) {
            d.style.backgroundColor = 'white';
          }
          d.innerHTML = t.getData('text/html');
          t.setDragImage(d, 0, 0);
          this._previewContainer.appendChild(d);
        }
      }
      function vB(t) {
        if (s.isGecko) {
          return t.dropEffect;
        }
        return ['all', 'copyMove'].includes(t.effectAllowed) ? 'move' : 'copy';
      }
      function AB(t) {
        if (t.is('editableElement')) {
          return null;
        }
        if (t.hasClass('ck-widget__selection-handle')) {
          return t.findAncestor(US);
        }
        if (US(t)) {
          return t;
        }
        const e = t.findAncestor(t => US(t) || t.is('editableElement'));
        if (US(e)) {
          return e;
        }
        return null;
      }
      function CB(t, e) {
        const n = e[0];
        const o = e[e.length - 1];
        const i = n.getCommonAncestor(o);
        const r = t.createPositionBefore(n);
        const s = t.createPositionAfter(o);
        if (i && i.is('element') && !t.schema.isLimit(i)) {
          const e = t.createRangeOn(i);
          const n = r.isTouching(e.start);
          const o = s.isTouching(e.end);
          if (n && o) {
            return CB(t, [i]);
          }
        }
        return t.createRange(r, s);
      }
      class yB extends Sh {
        static get pluginName() {
          return 'PastePlainText';
        }
        static get requires() {
          return [GT];
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = n.document;
          const i = e.document.selection;
          let r = false;
          n.addObserver(FT);
          this.listenTo(o, 'keydown', (t, e) => {
            r = e.shiftKey;
          });
          t.plugins.get(GT).on('contentInsertion', (t, n) => {
            if (!r && !xB(n.content, e.schema)) {
              return;
            }
            e.change(t => {
              const o = Array.from(i.getAttributes()).filter(
                ([t]) => e.schema.getAttributeProperties(t).isFormatting,
              );
              if (!i.isCollapsed) {
                e.deleteContent(i, { doNotAutoparagraph: true });
              }
              o.push(...i.getAttributes());
              const r = t.createRangeIn(n.content);
              for (const e of r.getItems()) {
                if (e.is('$textProxy')) {
                  t.setAttributes(o, e);
                }
              }
            });
          });
        }
      }
      function xB(t, e) {
        if (t.childCount > 1) {
          return false;
        }
        const n = t.getChild(0);
        if (e.isObject(n)) {
          return false;
        }
        return Array.from(n.getAttributeKeys()).length == 0;
      }
      class EB extends Sh {
        static get pluginName() {
          return 'Clipboard';
        }
        static get requires() {
          return [GT, _B, yB];
        }
      }
      class DB extends Bh {
        constructor(t) {
          super(t);
          this.affectsData = false;
        }
        execute() {
          const t = this.editor.model;
          const e = t.document.selection;
          let n = t.schema.getLimitElement(e);
          if (e.containsEntireContent(n) || !TB(t.schema, n)) {
            do {
              n = n.parent;
              if (!n) {
                return;
              }
            } while (!TB(t.schema, n));
          }
          t.change(t => {
            t.setSelection(n, 'in');
          });
        }
      }
      function TB(t, e) {
        return (
          t.isLimit(e) &&
          (t.checkChild(e, '$text') || t.checkChild(e, 'paragraph'))
        );
      }
      const SB = Gc('Ctrl+A');
      class PB extends Sh {
        static get pluginName() {
          return 'SelectAllEditing';
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          t.commands.add('selectAll', new DB(t));
          this.listenTo(n, 'keydown', (e, n) => {
            if (Wc(n) === SB) {
              t.execute('selectAll');
              n.preventDefault();
            }
          });
        }
      }
      const BB =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
      class RB extends Sh {
        static get pluginName() {
          return 'SelectAllUI';
        }
        init() {
          const t = this.editor;
          t.ui.componentFactory.add('selectAll', e => {
            const n = t.commands.get('selectAll');
            const o = new Ad(e);
            const i = e.t;
            o.set({
              label: i('Select all'),
              icon: BB,
              keystroke: 'Ctrl+A',
              tooltip: true,
            });
            o.bind('isEnabled').to(n, 'isEnabled');
            this.listenTo(o, 'execute', () => {
              t.execute('selectAll');
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class OB extends Sh {
        static get requires() {
          return [PB, RB];
        }
        static get pluginName() {
          return 'SelectAll';
        }
      }
      class IB extends Bh {
        constructor(t) {
          super(t);
          this._stack = [];
          this._createdBatches = new WeakSet();
          this.refresh();
          this._isEnabledBasedOnSelection = false;
          this.listenTo(
            t.data,
            'set',
            (t, e) => {
              e[1] = { ...e[1] };
              const n = e[1];
              if (!n.batchType) {
                n.batchType = { isUndoable: false };
              }
            },
            { priority: 'high' },
          );
          this.listenTo(t.data, 'set', (t, e) => {
            const n = e[1];
            if (!n.batchType.isUndoable) {
              this.clearStack();
            }
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(t) {
          const e = this.editor.model.document.selection;
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
          this._stack.push({ batch: t, selection: n });
          this.refresh();
        }
        clearStack() {
          this._stack = [];
          this.refresh();
        }
        _restoreSelection(t, e, n) {
          const o = this.editor.model;
          const i = o.document;
          const r = [];
          const s = t.map(t => t.getTransformedByOperations(n));
          const a = s.flat();
          for (const t of s) {
            const e = t
              .filter(t => t.root != i.graveyard)
              .filter(t => !VB(t, a));
            if (!e.length) {
              continue;
            }
            MB(e);
            r.push(e[0]);
          }
          if (r.length) {
            o.change(t => {
              t.setSelection(r, { backward: e });
            });
          }
        }
        _undo(t, e) {
          const n = this.editor.model;
          const o = n.document;
          this._createdBatches.add(e);
          const i = t.operations.slice().filter(t => t.isDocumentOperation);
          i.reverse();
          for (const t of i) {
            const i = t.baseVersion + 1;
            const r = Array.from(o.history.getOperations(i));
            const s = j_([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            });
            const a = s.operationsA;
            for (let i of a) {
              const r = i.affectedSelectable;
              if (r && !n.canEditAt(r)) {
                i = new B_(i.baseVersion);
              }
              e.addOperation(i);
              n.applyOperation(i);
              o.history.setOperationAsUndone(t, i);
            }
          }
        }
      }
      function MB(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1];
          const o = n.getJoined(t[e], true);
          if (o) {
            e--;
            t.splice(e, 2, o);
          }
        }
      }
      function VB(t, e) {
        return e.some(e => e !== t && e.containsRange(t, true));
      }
      class zB extends IB {
        execute(t = null) {
          const e = t
            ? this._stack.findIndex(e => e.batch == t)
            : this._stack.length - 1;
          const n = this._stack.splice(e, 1)[0];
          const o = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(o, () => {
            this._undo(n.batch, o);
            const t = this.editor.model.document.history.getOperations(
              n.batch.baseVersion,
            );
            this._restoreSelection(
              n.selection.ranges,
              n.selection.isBackward,
              t,
            );
          });
          this.fire('revert', n.batch, o);
          this.refresh();
        }
      }
      class FB extends IB {
        execute() {
          const t = this._stack.pop();
          const e = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1];
            const o = n.baseVersion + 1;
            const i = this.editor.model.document.history.getOperations(o);
            this._restoreSelection(
              t.selection.ranges,
              t.selection.isBackward,
              i,
            );
            this._undo(t.batch, e);
          });
          this.refresh();
        }
      }
      class NB extends Sh {
        constructor() {
          super(...arguments);
          this._batchRegistry = new WeakSet();
        }
        static get pluginName() {
          return 'UndoEditing';
        }
        init() {
          const t = this.editor;
          this._undoCommand = new zB(t);
          this._redoCommand = new FB(t);
          t.commands.add('undo', this._undoCommand);
          t.commands.add('redo', this._redoCommand);
          this.listenTo(
            t.model,
            'applyOperation',
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) {
                return;
              }
              const o = n.batch;
              const i = this._redoCommand.createdBatches.has(o);
              const r = this._undoCommand.createdBatches.has(o);
              const s = this._batchRegistry.has(o);
              if (s) {
                return;
              }
              this._batchRegistry.add(o);
              if (!o.isUndoable) {
                return;
              }
              if (i) {
                this._undoCommand.addBatch(o);
              } else if (!r) {
                this._undoCommand.addBatch(o);
                this._redoCommand.clearStack();
              }
            },
            { priority: 'highest' },
          );
          this.listenTo(this._undoCommand, 'revert', (t, e, n) => {
            this._redoCommand.addBatch(n);
          });
          t.keystrokes.set('CTRL+Z', 'undo');
          t.keystrokes.set('CTRL+Y', 'redo');
          t.keystrokes.set('CTRL+SHIFT+Z', 'redo');
        }
      }
      const LB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
      const HB =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class jB extends Sh {
        static get pluginName() {
          return 'UndoUI';
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const o = e.uiLanguageDirection == 'ltr' ? LB : HB;
          const i = e.uiLanguageDirection == 'ltr' ? HB : LB;
          this._addButton('undo', n('Undo'), 'CTRL+Z', o);
          this._addButton('redo', n('Redo'), 'CTRL+Y', i);
        }
        _addButton(t, e, n, o) {
          const i = this.editor;
          i.ui.componentFactory.add(t, r => {
            const s = i.commands.get(t);
            const a = new Ad(r);
            a.set({ label: e, icon: o, keystroke: n, tooltip: true });
            a.bind('isEnabled').to(s, 'isEnabled');
            this.listenTo(a, 'execute', () => {
              i.execute(t);
              i.editing.view.focus();
            });
            return a;
          });
        }
      }
      class qB extends Sh {
        static get requires() {
          return [NB, jB];
        }
        static get pluginName() {
          return 'Undo';
        }
      }
      class $B extends Sh {
        static get requires() {
          return [EB, MS, OB, HS, hS, qB];
        }
        static get pluginName() {
          return 'Essentials';
        }
      }
      class WB extends Bh {
        constructor(t) {
          super(t);
          this._isEnabledBasedOnSelection = false;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            'mention',
          );
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i =
            typeof t.mention == 'string' ? { id: t.mention } : t.mention;
          const r = i.id;
          const s = t.range || o.getFirstRange();
          if (!e.canEditAt(s)) {
            return;
          }
          const a = t.text || r;
          const c = KB({ _text: a, id: r }, i);
          if (t.marker.length != 1) {
            throw new B('mentioncommand-incorrect-marker', this);
          }
          if (r.charAt(0) != t.marker) {
            throw new B('mentioncommand-incorrect-id', this);
          }
          e.change(t => {
            const n = gl(o.getAttributes());
            const i = new Map(n.entries());
            i.set('mention', c);
            e.insertContent(t.createText(a, i), s);
            e.insertContent(
              t.createText(' ', n),
              s.start.getShiftedBy(a.length),
            );
          });
        }
      }
      class GB extends Sh {
        static get pluginName() {
          return 'MentionEditing';
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = e.document;
          e.schema.extend('$text', { allowAttributes: 'mention' });
          t.conversion.for('upcast').elementToAttribute({
            view: { name: 'span', key: 'data-mention', classes: 'mention' },
            model: { key: 'mention', value: t => UB(t) },
          });
          t.conversion
            .for('downcast')
            .attributeToElement({ model: 'mention', view: JB });
          t.conversion.for('downcast').add(ZB);
          n.registerPostFixer(t => XB(t, n, e.schema));
          n.registerPostFixer(t => tR(t, n));
          n.registerPostFixer(t => YB(t, n));
          t.commands.add('mention', new WB(t));
        }
      }
      function KB(t, e) {
        return Object.assign({ uid: E() }, t, e || {});
      }
      function UB(t, e) {
        const n = t.getAttribute('data-mention');
        const o = t.getChild(0);
        if (!o) {
          return;
        }
        const i = { id: n, _text: o.data };
        return KB(i, e);
      }
      function ZB(t) {
        t.on(
          'attribute:mention',
          (t, e, n) => {
            const o = e.attributeNewValue;
            if (!e.item.is('$textProxy') || !o) {
              return;
            }
            const i = e.range.start;
            const r = i.textNode || i.nodeAfter;
            if (r.data != o._text) {
              n.consumable.consume(e.item, t.name);
            }
          },
          { priority: 'highest' },
        );
      }
      function JB(t, { writer: e }) {
        if (!t) {
          return;
        }
        const n = { class: 'mention', 'data-mention': t.id };
        const o = { id: t.uid, priority: 20 };
        return e.createAttributeElement('span', n, o);
      }
      function YB(t, e) {
        const n = e.selection;
        const o = n.focus;
        if (n.isCollapsed && n.hasAttribute('mention') && QB(o)) {
          t.removeSelectionAttribute('mention');
          return true;
        }
        return false;
      }
      function QB(t) {
        const e = t.isAtStart;
        const n = t.nodeBefore && t.nodeBefore.is('$text');
        return n || e;
      }
      function XB(t, e, n) {
        const o = e.differ.getChanges();
        let i = false;
        for (const e of o) {
          if (e.type == 'attribute') {
            continue;
          }
          const o = e.position;
          if (e.name == '$text') {
            const e = o.textNode && o.textNode.nextSibling;
            i = nR(o.textNode, t) || i;
            i = nR(e, t) || i;
            i = nR(o.nodeBefore, t) || i;
            i = nR(o.nodeAfter, t) || i;
          }
          if (e.name != '$text' && e.type == 'insert') {
            const e = o.nodeAfter;
            for (const n of t.createRangeIn(e).getItems()) {
              i = nR(n, t) || i;
            }
          }
          if (e.type == 'insert' && n.isInline(e.name)) {
            const e = o.nodeAfter && o.nodeAfter.nextSibling;
            i = nR(o.nodeBefore, t) || i;
            i = nR(e, t) || i;
          }
        }
        return i;
      }
      function tR(t, e) {
        const n = e.differ.getChanges();
        let o = false;
        for (const e of n) {
          if (e.type === 'attribute' && e.attributeKey != 'mention') {
            const n = e.range.start.nodeBefore;
            const i = e.range.end.nodeAfter;
            for (const r of [n, i]) {
              if (
                eR(r) &&
                r.getAttribute(e.attributeKey) != e.attributeNewValue
              ) {
                t.setAttribute(e.attributeKey, e.attributeNewValue, r);
                o = true;
              }
            }
          }
        }
        return o;
      }
      function eR(t) {
        if (
          !t ||
          !(t.is('$text') || t.is('$textProxy')) ||
          !t.hasAttribute('mention')
        ) {
          return false;
        }
        const e = t.data;
        const n = t.getAttribute('mention');
        const o = n._text;
        return e != o;
      }
      function nR(t, e) {
        if (eR(t)) {
          e.removeAttribute('mention', t);
          return true;
        }
        return false;
      }
      var oR = n(139);
      var iR = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      iR.insert = 'head';
      iR.singleton = true;
      var rR = Bl()(oR.Z, iR);
      const sR = oR.Z.locals || {};
      class aR extends ey {
        constructor(t) {
          super(t);
          this.extendTemplate({
            attributes: { class: ['ck-mentions'], tabindex: '-1' },
          });
        }
        selectFirst() {
          this.select(0);
        }
        selectNext() {
          const t = this.selected;
          const e = this.items.getIndex(t);
          this.select(e + 1);
        }
        selectPrevious() {
          const t = this.selected;
          const e = this.items.getIndex(t);
          this.select(e - 1);
        }
        select(t) {
          let e = 0;
          if (t > 0 && t < this.items.length) {
            e = t;
          } else if (t < 0) {
            e = this.items.length - 1;
          }
          const n = this.items.get(e);
          if (this.selected === n) {
            return;
          }
          if (this.selected) {
            this.selected.removeHighlight();
          }
          n.highlight();
          this.selected = n;
          if (!this._isItemVisibleInScrolledArea(n)) {
            this.element.scrollTop = n.element.offsetTop;
          }
        }
        executeSelected() {
          this.selected.fire('execute');
        }
        _isItemVisibleInScrolledArea(t) {
          return new cc(this.element).contains(new cc(t.element));
        }
      }
      class cR extends Vl {
        constructor(t, e) {
          super(t);
          this.template = undefined;
          this.domElement = e;
          this.domElement.classList.add('ck-button');
          this.set('isOn', false);
          this.on('change:isOn', (t, e, n) => {
            if (n) {
              this.domElement.classList.add('ck-on');
              this.domElement.classList.remove('ck-off');
            } else {
              this.domElement.classList.add('ck-off');
              this.domElement.classList.remove('ck-on');
            }
          });
          this.listenTo(this.domElement, 'click', () => {
            this.fire('execute');
          });
        }
        render() {
          super.render();
          this.element = this.domElement;
        }
        focus() {
          this.domElement.focus();
        }
      }
      class lR extends ny {
        highlight() {
          const t = this.children.first;
          t.isOn = true;
        }
        removeHighlight() {
          const t = this.children.first;
          t.isOn = false;
        }
      }
      const dR = 3;
      const hR = [qc.arrowup, qc.arrowdown, qc.esc];
      const uR = [qc.enter, qc.tab];
      class fR extends Sh {
        static get pluginName() {
          return 'MentionUI';
        }
        static get requires() {
          return [vD];
        }
        constructor(t) {
          super(t);
          this._items = new dl();
          this._mentionsView = this._createMentionView();
          this._mentionsConfigurations = new Map();
          this._requestFeedDebounced = am(this._requestFeed, 100);
          t.config.define('mention', { feeds: [] });
        }
        init() {
          const e = this.editor;
          const n = e.config.get('mention.commitKeys') || uR;
          const o = hR.concat(n);
          this._balloon = e.plugins.get(vD);
          e.editing.view.document.on(
            'keydown',
            (t, e) => {
              if (r(e.keyCode) && this._isUIVisible) {
                e.preventDefault();
                t.stop();
                if (e.keyCode == qc.arrowdown) {
                  this._mentionsView.selectNext();
                }
                if (e.keyCode == qc.arrowup) {
                  this._mentionsView.selectPrevious();
                }
                if (n.includes(e.keyCode)) {
                  this._mentionsView.executeSelected();
                }
                if (e.keyCode == qc.esc) {
                  this._hideUIAndRemoveMarker();
                }
              }
            },
            { priority: 'highest' },
          );
          t({
            emitter: this._mentionsView,
            activator: () => this._isUIVisible,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideUIAndRemoveMarker(),
          });
          const i = e.config.get('mention.feeds');
          for (const t of i) {
            const { feed: e, marker: n, dropdownLimit: o } = t;
            if (!AR(n)) {
              throw new B('mentionconfig-incorrect-marker', null, {
                marker: n,
              });
            }
            const i = typeof e == 'function' ? e.bind(this.editor) : wR(e);
            const r = t.itemRenderer;
            const s = {
              marker: n,
              feedCallback: i,
              itemRenderer: r,
              dropdownLimit: o,
            };
            this._mentionsConfigurations.set(n, s);
          }
          this._setupTextWatcher(i);
          this.listenTo(e, 'change:isReadOnly', () => {
            this._hideUIAndRemoveMarker();
          });
          this.on('requestFeed:response', (t, e) =>
            this._handleFeedResponse(e),
          );
          this.on('requestFeed:error', () => this._hideUIAndRemoveMarker());
          function r(t) {
            return o.includes(t);
          }
        }
        destroy() {
          super.destroy();
          this._mentionsView.destroy();
        }
        get _isUIVisible() {
          return this._balloon.visibleView === this._mentionsView;
        }
        _createMentionView() {
          const t = this.editor.locale;
          const e = new aR(t);
          e.items.bindTo(this._items).using(n => {
            const { item: o, marker: i } = n;
            const { dropdownLimit: r } = this._mentionsConfigurations.get(i);
            const s =
              r || this.editor.config.get('mention.dropdownLimit') || 10;
            if (e.items.length >= s) {
              return null;
            }
            const a = new lR(t);
            const c = this._renderItem(o, i);
            c.delegate('execute').to(a);
            a.children.add(c);
            a.item = o;
            a.marker = i;
            a.on('execute', () => {
              e.fire('execute', { item: o, marker: i });
            });
            return a;
          });
          e.on('execute', (t, e) => {
            const n = this.editor;
            const o = n.model;
            const i = e.item;
            const r = e.marker;
            const s = n.model.markers.get('mention');
            const a = o.createPositionAt(o.document.selection.focus);
            const c = o.createPositionAt(s.getStart());
            const l = o.createRange(c, a);
            this._hideUIAndRemoveMarker();
            n.execute('mention', {
              mention: i,
              text: i.text,
              marker: r,
              range: l,
            });
            n.editing.view.focus();
          });
          return e;
        }
        _getItemRenderer(t) {
          const { itemRenderer: e } = this._mentionsConfigurations.get(t);
          return e;
        }
        _requestFeed(t, e) {
          this._lastRequested = e;
          const { feedCallback: n } = this._mentionsConfigurations.get(t);
          const o = n(e);
          const i = o instanceof Promise;
          if (!i) {
            this.fire('requestFeed:response', {
              feed: o,
              marker: t,
              feedText: e,
            });
            return;
          }
          o.then(n => {
            if (this._lastRequested == e) {
              this.fire('requestFeed:response', {
                feed: n,
                marker: t,
                feedText: e,
              });
            } else {
              this.fire('requestFeed:discarded', {
                feed: n,
                marker: t,
                feedText: e,
              });
            }
          }).catch(e => {
            this.fire('requestFeed:error', { error: e });
            R('mention-feed-callback-error', { marker: t });
          });
        }
        _setupTextWatcher(t) {
          const e = this.editor;
          const n = t.map(t => ({
            ...t,
            pattern: mR(t.marker, t.minimumCharacters || 0),
          }));
          const o = new fS(e.model, kR(n));
          o.on('matched', (t, o) => {
            const i = gR(n, o.text);
            const r = e.model.document.selection;
            const s = r.focus;
            const a = e.model.createPositionAt(s.parent, i.position);
            if (_R(s) || vR(a)) {
              this._hideUIAndRemoveMarker();
              return;
            }
            const c = bR(i, o.text);
            const l = i.marker.length + c.length;
            const d = s.getShiftedBy(-l);
            const h = s.getShiftedBy(-c.length);
            const u = e.model.createRange(d, h);
            if (CR(e)) {
              const t = e.model.markers.get('mention');
              e.model.change(e => {
                e.updateMarker(t, { range: u });
              });
            } else {
              e.model.change(t => {
                t.addMarker('mention', {
                  range: u,
                  usingOperation: false,
                  affectsData: false,
                });
              });
            }
            this._requestFeedDebounced(i.marker, c);
          });
          o.on('unmatched', () => {
            this._hideUIAndRemoveMarker();
          });
          const i = e.commands.get('mention');
          o.bind('isEnabled').to(i);
          return o;
        }
        _handleFeedResponse(t) {
          const { feed: e, marker: n } = t;
          if (!CR(this.editor)) {
            return;
          }
          this._items.clear();
          for (const t of e) {
            const e = typeof t != 'object' ? { id: t, text: t } : t;
            this._items.add({ item: e, marker: n });
          }
          const o = this.editor.model.markers.get('mention');
          if (this._items.length) {
            this._showOrUpdateUI(o);
          } else {
            this._hideUIAndRemoveMarker();
          }
        }
        _showOrUpdateUI(t) {
          if (this._isUIVisible) {
            this._balloon.updatePosition(
              this._getBalloonPanelPositionData(t, this._mentionsView.position),
            );
          } else {
            this._balloon.add({
              view: this._mentionsView,
              position: this._getBalloonPanelPositionData(
                t,
                this._mentionsView.position,
              ),
              singleViewMode: true,
            });
          }
          this._mentionsView.position = this._balloon.view.position;
          this._mentionsView.selectFirst();
        }
        _hideUIAndRemoveMarker() {
          if (this._balloon.hasView(this._mentionsView)) {
            this._balloon.remove(this._mentionsView);
          }
          if (CR(this.editor)) {
            this.editor.model.change(t => t.removeMarker('mention'));
          }
          this._mentionsView.position = undefined;
        }
        _renderItem(t, e) {
          const n = this.editor;
          let o;
          let i = t.id;
          const r = this._getItemRenderer(e);
          if (r) {
            const e = r(t);
            if (typeof e != 'string') {
              o = new cR(n.locale, e);
            } else {
              i = e;
            }
          }
          if (!o) {
            const t = new Ad(n.locale);
            t.label = i;
            t.withText = true;
            o = t;
          }
          return o;
        }
        _getBalloonPanelPositionData(t, e) {
          const n = this.editor;
          const o = n.editing;
          const i = o.view.domConverter;
          const r = o.mapper;
          const s = n.locale.uiLanguageDirection;
          return {
            target: () => {
              let e = t.getRange();
              if (e.start.root.rootName == '$graveyard') {
                e = n.model.document.selection.getFirstRange();
              }
              const o = r.toViewRange(e);
              const s = cc.getDomRangeRects(i.viewRangeToDom(o));
              return s.pop();
            },
            limiter: () => {
              const t = this.editor.editing.view;
              const e = t.document;
              const n = e.selection.editableElement;
              if (n) {
                return t.domConverter.mapViewToDom(n.root);
              }
              return null;
            },
            positions: pR(e, s),
          };
        }
      }
      function pR(t, e) {
        const n = {
          caret_se: t => ({
            top: t.bottom + dR,
            left: t.right,
            name: 'caret_se',
            config: { withArrow: false },
          }),
          caret_ne: (t, e) => ({
            top: t.top - e.height - dR,
            left: t.right,
            name: 'caret_ne',
            config: { withArrow: false },
          }),
          caret_sw: (t, e) => ({
            top: t.bottom + dR,
            left: t.right - e.width,
            name: 'caret_sw',
            config: { withArrow: false },
          }),
          caret_nw: (t, e) => ({
            top: t.top - e.height - dR,
            left: t.right - e.width,
            name: 'caret_nw',
            config: { withArrow: false },
          }),
        };
        if (Object.prototype.hasOwnProperty.call(n, t)) {
          return [n[t]];
        }
        return e !== 'rtl'
          ? [n.caret_se, n.caret_sw, n.caret_ne, n.caret_nw]
          : [n.caret_sw, n.caret_se, n.caret_nw, n.caret_ne];
      }
      function gR(t, e) {
        let n;
        for (const o of t) {
          const t = e.lastIndexOf(o.marker);
          if (t > 0 && !e.substring(t - 1).match(o.pattern)) {
            continue;
          }
          if (!n || t >= n.position) {
            n = {
              marker: o.marker,
              position: t,
              minimumCharacters: o.minimumCharacters,
              pattern: o.pattern,
            };
          }
        }
        return n;
      }
      function mR(t, e) {
        const n = e == 0 ? '*' : `{${e},}`;
        const o = s.features.isRegExpUnicodePropertySupported
          ? '\\p{Ps}\\p{Pi}"\''
          : '\\(\\[{"\'';
        const i = '.';
        const r = `(?:^|[ ${o}])([${t}])(${i}${n})$`;
        return new RegExp(r, 'u');
      }
      function kR(t) {
        const e = e => {
          const n = gR(t, e);
          if (!n) {
            return false;
          }
          let o = 0;
          if (n.position !== 0) {
            o = n.position - 1;
          }
          const i = e.substring(o);
          return n.pattern.test(i);
        };
        return e;
      }
      function bR(t, e) {
        let n = 0;
        if (t.position !== 0) {
          n = t.position - 1;
        }
        const o = mR(t.marker, 0);
        const i = e.substring(n);
        const r = i.match(o);
        return r[2];
      }
      function wR(t) {
        return e => {
          const n = t.filter(t => {
            const n = typeof t == 'string' ? t : String(t.id);
            return n.toLowerCase().includes(e.toLowerCase());
          });
          return n;
        };
      }
      function _R(t) {
        const e = t.textNode && t.textNode.hasAttribute('mention');
        const n = t.nodeBefore;
        return e || (n && n.is('$text') && n.hasAttribute('mention'));
      }
      function vR(t) {
        const e = t.nodeAfter;
        return e && e.is('$text') && e.hasAttribute('mention');
      }
      function AR(t) {
        return t && t.length == 1;
      }
      function CR(t) {
        return t.model.markers.has('mention');
      }
      var yR = n(544);
      var xR = {
        injectType: 'singletonStyleTag',
        attributes: { 'data-cke': true },
      };
      xR.insert = 'head';
      xR.singleton = true;
      var ER = Bl()(yR.Z, xR);
      const DR = yR.Z.locals || {};
      class TR extends Sh {
        toMentionAttribute(t, e) {
          return UB(t, e);
        }
        static get pluginName() {
          return 'Mention';
        }
        static get requires() {
          return [GB, fR];
        }
      }
      class SR extends Bh {
        constructor(t) {
          super(t);
          this._isEnabledBasedOnSelection = false;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = hl(e.selection.getSelectedBlocks());
          this.value = !!n && n.is('element', 'paragraph');
          this.isEnabled = !!n && PR(n, t.schema);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.selection || n.selection;
          if (!e.canEditAt(o)) {
            return;
          }
          e.change(t => {
            const n = o.getSelectedBlocks();
            for (const o of n) {
              if (!o.is('element', 'paragraph') && PR(o, e.schema)) {
                t.rename(o, 'paragraph');
              }
            }
          });
        }
      }
      function PR(t, e) {
        return e.checkChild(t.parent, 'paragraph') && !e.isObject(t);
      }
      class BR extends Bh {
        constructor(t) {
          super(t);
          this._isEnabledBasedOnSelection = false;
        }
        execute(t) {
          const e = this.editor.model;
          const n = t.attributes;
          let o = t.position;
          if (!e.canEditAt(o)) {
            return;
          }
          e.change(t => {
            o = this._findPositionToInsertParagraph(o, t);
            if (!o) {
              return;
            }
            const i = t.createElement('paragraph');
            if (n) {
              e.schema.setAllowedAttributes(i, n, t);
            }
            e.insertContent(i, o);
            t.setSelection(i, 'in');
          });
        }
        _findPositionToInsertParagraph(t, e) {
          const n = this.editor.model;
          if (n.schema.checkChild(t, 'paragraph')) {
            return t;
          }
          const o = n.schema.findAllowedParent(t, 'paragraph');
          if (!o) {
            return null;
          }
          const i = t.parent;
          const r = n.schema.checkChild(i, '$text');
          if (i.isEmpty || (r && t.isAtEnd)) {
            return n.createPositionAfter(i);
          }
          if (!i.isEmpty && r && t.isAtStart) {
            return n.createPositionBefore(i);
          }
          return e.split(t, o).position;
        }
      }
      class RR extends Sh {
        static get pluginName() {
          return 'Paragraph';
        }
        init() {
          const t = this.editor;
          const e = t.model;
          t.commands.add('paragraph', new SR(t));
          t.commands.add('insertParagraph', new BR(t));
          e.schema.register('paragraph', { inheritAllFrom: '$block' });
          t.conversion.elementToElement({ model: 'paragraph', view: 'p' });
          t.conversion.for('upcast').elementToElement({
            model: (t, { writer: e }) => {
              if (!RR.paragraphLikeElements.has(t.name)) {
                return null;
              }
              if (t.isEmpty) {
                return null;
              }
              return e.createElement('paragraph');
            },
            view: /.+/,
            converterPriority: 'low',
          });
        }
      }
      RR.paragraphLikeElements = new Set([
        'blockquote',
        'dd',
        'div',
        'dt',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'li',
        'p',
        'td',
        'th',
      ]);
      const OR = NC.paragraph;
      class IR extends (null && Plugin) {
        static get requires() {
          return [Paragraph];
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add('paragraph', n => {
            const o = new ButtonView(n);
            const i = t.commands.get('paragraph');
            o.label = e('Paragraph');
            o.icon = OR;
            o.tooltip = true;
            o.isToggleable = true;
            o.bind('isEnabled').to(i);
            o.bind('isOn').to(i, 'value');
            o.on('execute', () => {
              t.execute('paragraph');
            });
            return o;
          });
        }
      }
      class MR extends MT {}
      MR.builtinPlugins = [$B, TR, RR];
      MR.defaultConfig = { toolbar: { items: [] }, language: 'en' };
      const VR = MR;
    })();
    o = o['default'];
    return o;
  })(),
);
//# sourceMappingURL=ckeditor.js.map
